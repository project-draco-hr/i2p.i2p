{
  dk=ns=ip=op=false;
  try {
    BufferedReader in=new BufferedReader(new InputStreamReader(server.getInputStream()));
    PrintStream out=new PrintStream(server.getOutputStream());
    prikey=new ByteArrayOutputStream();
    out.println("BOB " + BOBversion);
    out.println("OK");
    while ((line=in.readLine()) != null) {
      StringTokenizer token=new StringTokenizer(line," ");
      String Command="";
      String Arg="";
      nickname info;
      if (token.countTokens() != 0) {
        Command=token.nextToken();
        Command=Command.toLowerCase();
        if (token.countTokens() != 0) {
          Arg=token.nextToken();
        }
 else {
          Arg="";
        }
        if (Command.equals(C_help)) {
          for (int i=0; !C_ALL[i][0].equals(" "); i++) {
            if (C_ALL[i][0].equalsIgnoreCase(Arg)) {
              out.println("OK " + C_ALL[i][1]);
            }
          }
        }
 else         if (Command.equals(C_getdest)) {
          if (ns) {
            if (dk) {
              rlock();
              try {
                out.println("OK " + nickinfo.get(P_DEST));
              }
 catch (              Exception e) {
              }
              runlock();
            }
 else {
              out.println("ERROR keys not set.");
            }
          }
 else {
            nns(out);
          }
        }
 else         if (Command.equals(C_list)) {
          database.getReadLock();
          for (int i=0; i < database.getcount(); i++) {
            try {
              info=(nickname)database.getnext(i);
            }
 catch (            Exception b) {
              break;
            }
            try {
              out.print("DATA");
            }
 catch (            Exception e) {
            }
            info.getReadLock();
            nickprint(out,info);
            info.releaseReadLock();
          }
          database.releaseReadLock();
          out.println("OK Listing done");
        }
 else         if (Command.equals(C_quit)) {
          break;
        }
 else         if (Command.equals(C_newkeys)) {
          if (ns) {
            if (tunnelactive(nickinfo)) {
              out.println("ERROR tunnel is active");
            }
 else {
              try {
                prikey=new ByteArrayOutputStream();
                d=I2PClientFactory.createClient().createDestination(prikey);
                wlock();
                nickinfo.add(P_KEYS,prikey.toByteArray());
                nickinfo.add(P_DEST,d.toBase64());
                dk=true;
                wunlock();
                rlock();
                try {
                  out.println("OK " + nickinfo.get(P_DEST));
                }
 catch (                Exception e) {
                }
                runlock();
              }
 catch (              IOException ioe) {
                BOB.error("Error generating keys" + ioe);
                out.println("ERROR generating keys");
              }
catch (              I2PException ipe) {
                BOB.error("Error generating keys" + ipe);
                out.println("ERROR generating keys");
              }
            }
          }
 else {
            nns(out);
          }
        }
 else         if (Command.equals(C_getkeys)) {
          if (dk) {
            prikey=new ByteArrayOutputStream();
            rlock();
            prikey.write(((byte[])nickinfo.get(P_KEYS)));
            runlock();
            out.println("OK " + net.i2p.data.Base64.encode(prikey.toByteArray()));
          }
 else {
            out.println("ERROR no public key has been set");
          }
        }
 else         if (Command.equals(C_quiet)) {
          if (ns) {
            if (tunnelactive(nickinfo)) {
              out.println("ERROR tunnel is active");
            }
 else {
              wlock();
              nickinfo.add(P_QUIET,new Boolean(Boolean.parseBoolean(Arg) == true));
              wunlock();
              out.println("OK Quiet set");
            }
          }
 else {
            nns(out);
          }
        }
 else         if (Command.equals(C_setkeys)) {
          if (ns) {
            if (tunnelactive(nickinfo)) {
              out.println("ERROR tunnel is active");
            }
 else {
              try {
                prikey=new ByteArrayOutputStream();
                prikey.write(net.i2p.data.Base64.decode(Arg));
                d.fromBase64(Arg);
              }
 catch (              Exception ex) {
                Arg="";
              }
              if ((Arg.length() == 884) && is64ok(Arg)) {
                wlock();
                nickinfo.add(P_KEYS,prikey.toByteArray());
                nickinfo.add(P_DEST,d.toBase64());
                dk=true;
                wunlock();
                rlock();
                try {
                  out.println("OK " + nickinfo.get(P_DEST));
                }
 catch (                Exception e) {
                }
                runlock();
              }
 else {
                out.println("ERROR not in BASE64 format");
              }
            }
          }
 else {
            nns(out);
          }
        }
 else         if (Command.equals(C_setnick)) {
          ns=dk=ip=op=false;
          database.getReadLock();
          try {
            nickinfo=(nickname)database.get(Arg);
            if (!tunnelactive(nickinfo)) {
              nickinfo=null;
              ns=true;
            }
          }
 catch (          Exception b) {
            nickinfo=null;
            ns=true;
          }
          database.releaseReadLock();
          if (ns) {
            nickinfo=new nickname();
            wlock();
            database.add(Arg,nickinfo);
            nickinfo.add(P_NICKNAME,Arg);
            nickinfo.add(P_STARTING,Boolean.FALSE);
            nickinfo.add(P_RUNNING,Boolean.FALSE);
            nickinfo.add(P_STOPPING,Boolean.FALSE);
            nickinfo.add(P_QUIET,Boolean.FALSE);
            nickinfo.add(P_INHOST,"localhost");
            nickinfo.add(P_OUTHOST,"localhost");
            Properties Q=new Properties(props);
            Q.setProperty("inbound.nickname",Arg);
            Q.setProperty("outbound.nickname",Arg);
            nickinfo.add(P_PROPERTIES,Q);
            wunlock();
            out.println("OK Nickname set to " + Arg);
          }
 else {
            out.println("ERROR tunnel is active");
          }
        }
 else         if (Command.equals(C_option)) {
          if (ns) {
            if (tunnelactive(nickinfo)) {
              out.println("ERROR tunnel is active");
            }
 else {
              StringTokenizer otoken=new StringTokenizer(Arg,"=");
              if (otoken.countTokens() != 2) {
                out.println("ERROR to many or no options.");
              }
 else {
                String pname=otoken.nextToken();
                String pval=otoken.nextToken();
                rlock();
                Properties Q=(Properties)nickinfo.get(P_PROPERTIES);
                runlock();
                Q.setProperty(pname,pval);
                wlock();
                nickinfo.add(P_PROPERTIES,Q);
                wunlock();
                out.println("OK " + pname + " set to "+ pval);
              }
            }
          }
 else {
            nns(out);
          }
        }
 else         if (Command.equals(C_getnick)) {
          database.getReadLock();
          try {
            nickinfo=(nickname)database.get(Arg);
            ns=true;
          }
 catch (          RuntimeException b) {
            nns(out);
          }
          database.releaseReadLock();
          if (ns) {
            rlock();
            dk=nickinfo.exists(P_KEYS);
            ip=nickinfo.exists(P_INPORT);
            op=nickinfo.exists(P_OUTPORT);
            runlock();
            out.println("OK Nickname set to " + Arg);
          }
        }
 else         if (Command.equals(C_inport)) {
          if (ns) {
            if (tunnelactive(nickinfo)) {
              out.println("ERROR tunnel is active");
            }
 else {
              int prt;
              wlock();
              nickinfo.kill(P_INPORT);
              try {
                prt=Integer.parseInt(Arg);
                if (prt > 1 && prt < 65536) {
                  nickinfo.add(P_INPORT,new Integer(prt));
                }
              }
 catch (              NumberFormatException nfe) {
                out.println("ERROR not a number");
              }
              wunlock();
              rlock();
              ip=nickinfo.exists(P_INPORT);
              runlock();
              if (ip) {
                out.println("OK inbound port set");
              }
 else {
                out.println("ERROR port out of range");
              }
            }
          }
 else {
            nns(out);
          }
        }
 else         if (Command.equals(C_outport)) {
          if (ns) {
            if (tunnelactive(nickinfo)) {
              out.println("ERROR tunnel is active");
            }
 else {
              int prt;
              wlock();
              nickinfo.kill(P_OUTPORT);
              try {
                prt=Integer.parseInt(Arg);
                if (prt > 1 && prt < 65536) {
                  nickinfo.add(P_OUTPORT,new Integer(prt));
                }
              }
 catch (              NumberFormatException nfe) {
                out.println("ERROR not a number");
              }
              wunlock();
              rlock();
              ip=nickinfo.exists(P_OUTPORT);
              runlock();
              if (ip) {
                out.println("OK outbound port set");
              }
 else {
                out.println("ERROR port out of range");
              }
            }
          }
 else {
            nns(out);
          }
        }
 else         if (Command.equals(C_inhost)) {
          if (ns) {
            if (tunnelactive(nickinfo)) {
              out.println("ERROR tunnel is active");
            }
 else {
              wlock();
              nickinfo.add(P_INHOST,Arg);
              wunlock();
              out.println("OK inhost set");
            }
          }
 else {
            nns(out);
          }
        }
 else         if (Command.equals(C_outhost)) {
          if (ns) {
            if (tunnelactive(nickinfo)) {
              out.println("ERROR tunnel is active");
            }
 else {
              wlock();
              nickinfo.add(P_OUTHOST,Arg);
              wunlock();
              out.println("OK outhost set");
            }
          }
 else {
            nns(out);
          }
        }
 else         if (Command.equals(C_show)) {
          if (ns) {
            out.print("OK");
            rlock();
            nickprint(out,nickinfo);
            runlock();
          }
 else {
            nns(out);
          }
        }
 else         if (Command.equals(C_start)) {
          if (ns && dk && (ip || op)) {
            if (tunnelactive(nickinfo)) {
              out.println("ERROR tunnel is active");
            }
 else {
              MUXlisten tunnel;
              try {
                tunnel=new MUXlisten(database,nickinfo,_log);
                Thread t=new Thread(tunnel);
                t.start();
                out.println("OK tunnel starting");
              }
 catch (              I2PException e) {
                out.println("ERROR starting tunnel: " + e);
              }
catch (              IOException e) {
                out.println("ERROR starting tunnel: " + e);
              }
            }
          }
 else {
            out.println("ERROR tunnel settings incomplete");
          }
        }
 else         if (Command.equals(C_stop)) {
          if (ns) {
            rlock();
            if (nickinfo.get(P_RUNNING).equals(Boolean.TRUE) && nickinfo.get(P_STOPPING).equals(Boolean.FALSE) && nickinfo.get(P_STARTING).equals(Boolean.FALSE)) {
              runlock();
              wlock();
              nickinfo.add(P_STOPPING,Boolean.TRUE);
              wunlock();
              out.println("OK tunnel stopping");
            }
 else {
              runlock();
              out.println("ERROR tunnel is inactive");
            }
          }
 else {
            nns(out);
          }
        }
 else         if (Command.equals(C_clear)) {
          if (ns) {
            if (tunnelactive(nickinfo)) {
              out.println("ERROR tunnel is active");
            }
 else {
              database.getWriteLock();
              database.kill(nickinfo.get(P_NICKNAME));
              database.releaseWriteLock();
              dk=ns=ip=op=false;
              out.println("OK cleared");
            }
          }
 else {
            nns(out);
          }
        }
 else         if (Command.equals(C_status)) {
          if (database.exists(Arg)) {
            out.print("OK ");
            ttlpnt(out,Arg);
          }
 else {
            nns(out);
          }
        }
 else {
          out.println("ERROR UNKNOWN COMMAND! Try help");
        }
      }
    }
    out.println("OK Bye!");
    server.close();
  }
 catch (  IOException ioe) {
    BOB.warn("IOException on socket listen: " + ioe);
    ioe.printStackTrace();
  }
}
