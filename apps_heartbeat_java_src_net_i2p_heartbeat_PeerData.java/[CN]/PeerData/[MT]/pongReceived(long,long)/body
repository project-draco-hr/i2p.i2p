{
  long now=Clock.getInstance().now();
synchronized (_updateLock) {
    if (_pendingPings.size() <= 0) {
      _log.warn("Pong received (sent at " + dateSent + ", "+ (now - dateSent)+ "ms ago, pong delay "+ (pongSent - dateSent)+ "ms, pong receive delay "+ (now - pongSent)+ "ms)");
      return;
    }
    Long first=(Long)_pendingPings.firstKey();
    EventDataPoint data=(EventDataPoint)_pendingPings.remove(new Long(dateSent));
    if (data != null) {
      data.setPongReceived(now);
      data.setPongSent(pongSent);
      data.setWasPonged(true);
      locked_addDataPoint(data);
      if (dateSent != first.longValue()) {
        _log.error("Out of order delivery: received " + dateSent + " but the first pending is "+ first.longValue()+ " (delta "+ (dateSent - first.longValue())+ ")");
      }
 else {
        _log.info("In order delivery for " + dateSent + " in ping "+ _peer.getComment());
      }
    }
 else {
      _log.warn("Pong received, but no matching ping?  ping sent at = " + dateSent);
      return;
    }
  }
  _sendRate.addData(pongSent - dateSent,0);
  _receiveRate.addData(now - pongSent,0);
  _lifetimeReceived++;
}
