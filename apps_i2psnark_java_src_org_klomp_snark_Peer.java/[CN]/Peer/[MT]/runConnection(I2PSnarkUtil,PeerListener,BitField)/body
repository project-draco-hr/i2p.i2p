{
  if (state != null)   throw new IllegalStateException("Peer already started");
  _log.debug("Running connection to " + peerID.getAddress().calculateHash().toBase64(),new Exception("connecting"));
  try {
    if (din == null) {
      sock=util.connect(peerID);
      _log.debug("Connected to " + peerID + ": "+ sock);
      if ((sock == null) || (sock.isClosed())) {
        throw new IOException("Unable to reach " + peerID);
      }
      InputStream in=sock.getInputStream();
      OutputStream out=sock.getOutputStream();
      if (true) {
        in=new BufferedInputStream(sock.getInputStream());
      }
      byte[] id=handshake(in,out);
      byte[] expected_id=peerID.getID();
      if (expected_id == null)       peerID.setID(id);
 else       if (Arrays.equals(expected_id,id))       _log.debug("Handshake got matching IDs with " + toString());
 else       throw new IOException("Unexpected peerID '" + PeerID.idencode(id) + "' expected '"+ PeerID.idencode(expected_id)+ "'");
    }
 else {
      _log.debug("Already have din [" + sock + "] with "+ toString());
    }
    PeerConnectionIn in=new PeerConnectionIn(this,din);
    PeerConnectionOut out=new PeerConnectionOut(this,dout);
    PeerState s=new PeerState(this,listener,metainfo,in,out);
    if (bitfield != null)     s.out.sendBitfield(bitfield);
    state=s;
    listener.connected(this);
    _log.debug("Start running the reader with " + toString());
    out.startup();
    Thread.currentThread().setName("Snark reader from " + peerID);
    s.in.run();
  }
 catch (  IOException eofe) {
    if (_log.shouldLog(Log.DEBUG))     _log.debug(this.toString(),eofe);
  }
catch (  Throwable t) {
    _log.error(this + ": " + t.getMessage(),t);
    if (t instanceof OutOfMemoryError)     throw (OutOfMemoryError)t;
  }
 finally {
    if (deregister)     listener.disconnected(this);
    disconnect();
  }
}
