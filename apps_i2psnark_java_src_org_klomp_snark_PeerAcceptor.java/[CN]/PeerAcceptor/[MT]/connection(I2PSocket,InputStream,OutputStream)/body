{
  byte peerInfoHash[]=null;
  if (in instanceof BufferedInputStream) {
    in.mark(LOOKAHEAD_SIZE);
    peerInfoHash=readHash(in);
    in.reset();
  }
 else {
    try {
      peerInfoHash=readHash(in);
      if (_log.shouldLog(Log.INFO))       _log.info("infohash read from " + socket.getPeerDestination().calculateHash().toBase64() + ": "+ Base64.encode(peerInfoHash));
    }
 catch (    IOException ioe) {
      if (_log.shouldLog(Log.INFO))       _log.info("Unable to read the infohash from " + socket.getPeerDestination().calculateHash().toBase64());
      throw ioe;
    }
    in=new SequenceInputStream(new ByteArrayInputStream(peerInfoHash),in);
  }
  if (coordinator != null) {
    MetaInfo meta=coordinator.getMetaInfo();
    if (DataHelper.eq(meta.getInfoHash(),peerInfoHash)) {
      if (coordinator.needPeers()) {
        Peer peer=new Peer(socket,in,out,coordinator.getID(),coordinator.getMetaInfo());
        coordinator.addPeer(peer);
      }
 else       socket.close();
    }
 else {
      throw new IOException("Peer wants another torrent (" + Base64.encode(peerInfoHash) + ") while we only support ("+ Base64.encode(meta.getInfoHash())+ ")");
    }
  }
 else {
    for (Iterator iter=coordinators.iterator(); iter.hasNext(); ) {
      PeerCoordinator cur=(PeerCoordinator)iter.next();
      MetaInfo meta=cur.getMetaInfo();
      if (DataHelper.eq(meta.getInfoHash(),peerInfoHash)) {
        if (cur.needPeers()) {
          Peer peer=new Peer(socket,in,out,cur.getID(),cur.getMetaInfo());
          cur.addPeer(peer);
          return;
        }
 else {
          if (_log.shouldLog(Log.DEBUG))           _log.debug("Rejecting new peer for " + cur.getName());
          socket.close();
          return;
        }
      }
    }
    throw new IOException("Peer wants another torrent (" + Base64.encode(peerInfoHash) + ") while we don't support that hash");
  }
}
