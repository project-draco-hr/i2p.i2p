{
  thread=Thread.currentThread();
  try {
    PeerState ps=peer.state;
    while (!quit && ps != null) {
      int piece;
      int begin;
      int len;
      int i=din.readInt();
      lastRcvd=System.currentTimeMillis();
      if (i < 0 || i > PeerState.PARTSIZE + 9)       throw new IOException("Unexpected length prefix: " + i);
      if (i == 0) {
        ps.keepAliveMessage();
        if (_log.shouldLog(Log.DEBUG))         _log.debug("Received keepalive from " + peer + " on "+ peer.metainfo.getName());
        continue;
      }
      byte b=din.readByte();
      Message m=new Message();
      m.type=b;
switch (b) {
case 0:
        ps.chokeMessage(true);
      if (_log.shouldLog(Log.DEBUG))       _log.debug("Received choke from " + peer + " on "+ peer.metainfo.getName());
    break;
case 1:
  ps.chokeMessage(false);
if (_log.shouldLog(Log.DEBUG)) _log.debug("Received unchoke from " + peer + " on "+ peer.metainfo.getName());
break;
case 2:
ps.interestedMessage(true);
if (_log.shouldLog(Log.DEBUG)) _log.debug("Received interested from " + peer + " on "+ peer.metainfo.getName());
break;
case 3:
ps.interestedMessage(false);
if (_log.shouldLog(Log.DEBUG)) _log.debug("Received not interested from " + peer + " on "+ peer.metainfo.getName());
break;
case 4:
piece=din.readInt();
ps.haveMessage(piece);
if (_log.shouldLog(Log.DEBUG)) _log.debug("Received havePiece(" + piece + ") from "+ peer+ " on "+ peer.metainfo.getName());
break;
case 5:
byte[] bitmap=new byte[i - 1];
din.readFully(bitmap);
ps.bitfieldMessage(bitmap);
if (_log.shouldLog(Log.DEBUG)) _log.debug("Received bitmap from " + peer + " on "+ peer.metainfo.getName()+ ": size="+ (i - 1));
break;
case 6:
piece=din.readInt();
begin=din.readInt();
len=din.readInt();
ps.requestMessage(piece,begin,len);
if (_log.shouldLog(Log.DEBUG)) _log.debug("Received request(" + piece + ","+ begin+ ") from "+ peer+ " on "+ peer.metainfo.getName());
break;
case 7:
piece=din.readInt();
begin=din.readInt();
len=i - 9;
Request req=ps.getOutstandingRequest(piece,begin,len);
byte[] piece_bytes;
if (req != null) {
piece_bytes=req.bs;
din.readFully(piece_bytes,begin,len);
ps.pieceMessage(req);
if (_log.shouldLog(Log.DEBUG)) _log.debug("Received data(" + piece + ","+ begin+ ") from "+ peer+ " on "+ peer.metainfo.getName());
}
 else {
piece_bytes=new byte[len];
din.readFully(piece_bytes);
if (_log.shouldLog(Log.DEBUG)) _log.debug("Received UNWANTED data(" + piece + ","+ begin+ ") from "+ peer+ " on "+ peer.metainfo.getName());
}
break;
case 8:
piece=din.readInt();
begin=din.readInt();
len=din.readInt();
ps.cancelMessage(piece,begin,len);
if (_log.shouldLog(Log.DEBUG)) _log.debug("Received cancel(" + piece + ","+ begin+ ") from "+ peer+ " on "+ peer.metainfo.getName());
break;
case 9:
int port=din.readUnsignedShort();
ps.portMessage(port);
if (_log.shouldLog(Log.DEBUG)) _log.debug("Received port message from " + peer + " on "+ peer.metainfo.getName());
case 20:
int id=din.readUnsignedByte();
byte[] payload=new byte[i - 2];
din.readFully(payload);
ps.extensionMessage(id,payload);
if (_log.shouldLog(Log.DEBUG)) _log.debug("Received extension message from " + peer + " on "+ peer.metainfo.getName());
break;
default :
byte[] bs=new byte[i - 1];
din.readFully(bs);
ps.unknownMessage(b,bs);
if (_log.shouldLog(Log.DEBUG)) _log.debug("Received unknown message from " + peer + " on "+ peer.metainfo.getName());
}
}
}
 catch (IOException ioe) {
if (_log.shouldLog(Log.INFO)) _log.info("IOError talking with " + peer,ioe);
}
catch (Throwable t) {
_log.error("Error talking with " + peer,t);
if (t instanceof OutOfMemoryError) throw (OutOfMemoryError)t;
}
 finally {
peer.disconnect();
}
}
