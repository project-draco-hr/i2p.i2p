{
  if (halted) {
    if (_log.shouldLog(Log.WARN))     _log.warn("We don't want anything from the peer, as we are halted!  peer=" + peer);
    return -1;
  }
synchronized (wantedPieces) {
    Piece piece=null;
    Collections.sort(wantedPieces);
    List<Piece> requested=new ArrayList();
    Iterator<Piece> it=wantedPieces.iterator();
    while (piece == null && it.hasNext()) {
      Piece p=it.next();
      if (p.isDisabled())       break;
      if (havePieces.get(p.getId()) && !p.isRequested()) {
        piece=p;
      }
 else       if (p.isRequested()) {
        requested.add(p);
      }
    }
    if (piece == null) {
      if (wantedPieces.size() > END_GAME_THRESHOLD)       return -1;
      Collections.shuffle(requested,_random);
      Iterator<Piece> it2=requested.iterator();
      while (piece == null && it2.hasNext()) {
        Piece p=it2.next();
        if (havePieces.get(p.getId())) {
          piece=p;
        }
      }
      if (piece == null) {
        if (_log.shouldLog(Log.WARN))         _log.warn("nothing to even rerequest from " + peer + ": requested = "+ requested);
        return -1;
      }
 else {
        if (_log.shouldLog(Log.DEBUG))         _log.debug("parallel request (end game?) for " + peer + ": piece = "+ piece);
      }
    }
    if (_log.shouldLog(Log.DEBUG))     _log.debug("Now requesting: piece " + piece + " priority "+ piece.getPriority());
    piece.setRequested(true);
    return piece.getId();
  }
}
