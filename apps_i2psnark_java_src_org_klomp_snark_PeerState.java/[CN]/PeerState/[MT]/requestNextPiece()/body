{
  if (bitfield != null) {
    Request r=listener.getPeerPartial(bitfield);
    if (r != null) {
      int[] arr=getRequestedPieces();
      boolean found=false;
      for (int i=0; arr[i] >= 0; i++) {
        if (arr[i] == r.piece) {
          found=true;
          break;
        }
      }
      if (!found) {
        outstandingRequests.add(r);
        if (!choked)         out.sendRequest(r);
        lastRequest=r;
        return true;
      }
    }
    int nextPiece=listener.wantPiece(peer,bitfield);
    if (_log.shouldLog(Log.DEBUG))     _log.debug(peer + " want piece " + nextPiece);
    if (nextPiece != -1 && (lastRequest == null || lastRequest.piece != nextPiece)) {
      if (!interesting) {
        if (_log.shouldLog(Log.DEBUG))         _log.debug(peer + " transition to end game, setting interesting");
        interesting=true;
        out.sendInterest(true);
      }
      int piece_length=metainfo.getPieceLength(nextPiece);
      byte[] bs;
      try {
        bs=new byte[piece_length];
      }
 catch (      OutOfMemoryError oom) {
        _log.warn("Out of memory, can't request piece " + nextPiece,oom);
        return false;
      }
      int length=Math.min(piece_length,PARTSIZE);
      Request req=new Request(nextPiece,bs,0,length);
      outstandingRequests.add(req);
      if (!choked)       out.sendRequest(req);
      lastRequest=req;
      return true;
    }
  }
  if (interesting && lastRequest == null) {
    interesting=false;
    out.sendInterest(false);
    if (_log.shouldLog(Log.DEBUG))     _log.debug(peer + " nothing more to request, now uninteresting");
  }
  return false;
}
