{
  boolean changed=false;
  if (upLimit != null) {
    int limit=_util.getMaxUploaders();
    try {
      limit=Integer.parseInt(upLimit);
    }
 catch (    NumberFormatException nfe) {
    }
    if (limit != _util.getMaxUploaders()) {
      if (limit >= Snark.MIN_TOTAL_UPLOADERS) {
        _util.setMaxUploaders(limit);
        changed=true;
        _config.setProperty(PROP_UPLOADERS_TOTAL,"" + limit);
        addMessage(_("Total uploaders limit changed to {0}",limit));
      }
 else {
        addMessage(_("Minimum total uploaders limit is {0}",Snark.MIN_TOTAL_UPLOADERS));
      }
    }
  }
  if (upBW != null) {
    int limit=_util.getMaxUpBW();
    try {
      limit=Integer.parseInt(upBW);
    }
 catch (    NumberFormatException nfe) {
    }
    if (limit != _util.getMaxUpBW()) {
      if (limit >= MIN_UP_BW) {
        _util.setMaxUpBW(limit);
        changed=true;
        _config.setProperty(PROP_UPBW_MAX,"" + limit);
        addMessage(_("Up BW limit changed to {0}KBps",limit));
      }
 else {
        addMessage(_("Minimum up bandwidth limit is {0}KBps",MIN_UP_BW));
      }
    }
  }
  if (startDelay != null) {
    int minutes=_util.getStartupDelay();
    try {
      minutes=Integer.parseInt(startDelay);
    }
 catch (    NumberFormatException nfe) {
    }
    if (minutes != _util.getStartupDelay()) {
      _util.setStartupDelay(minutes);
      changed=true;
      _config.setProperty(PROP_STARTUP_DELAY,"" + minutes);
      addMessage(_("Startup delay changed to {0}",DataHelper.formatDuration2(minutes * 60 * 1000)));
    }
  }
  if (i2cpHost != null) {
    int oldI2CPPort=_util.getI2CPPort();
    String oldI2CPHost=_util.getI2CPHost();
    int port=oldI2CPPort;
    if (i2cpPort != null) {
      try {
        port=Integer.parseInt(i2cpPort);
      }
 catch (      NumberFormatException nfe) {
      }
    }
    String host=oldI2CPHost;
    Map opts=new HashMap();
    if (i2cpOpts == null)     i2cpOpts="";
    StringTokenizer tok=new StringTokenizer(i2cpOpts," \t\n");
    while (tok.hasMoreTokens()) {
      String pair=tok.nextToken();
      int split=pair.indexOf('=');
      if (split > 0)       opts.put(pair.substring(0,split),pair.substring(split + 1));
    }
    Map oldOpts=new HashMap();
    String oldI2CPOpts=_config.getProperty(PROP_I2CP_OPTS);
    if (oldI2CPOpts == null)     oldI2CPOpts="";
    tok=new StringTokenizer(oldI2CPOpts," \t\n");
    while (tok.hasMoreTokens()) {
      String pair=tok.nextToken();
      int split=pair.indexOf('=');
      if (split > 0)       oldOpts.put(pair.substring(0,split),pair.substring(split + 1));
    }
    if ((i2cpHost.trim().length() > 0) && (port > 0) && ((!host.equals(i2cpHost) || (port != _util.getI2CPPort()) || (!oldOpts.equals(opts))))) {
      boolean snarksActive=false;
      Set names=listTorrentFiles();
      for (Iterator iter=names.iterator(); iter.hasNext(); ) {
        Snark snark=getTorrent((String)iter.next());
        if ((snark != null) && (!snark.isStopped())) {
          snarksActive=true;
          break;
        }
      }
      if (snarksActive) {
        Properties p=new Properties();
        p.putAll(opts);
        _util.setI2CPConfig(i2cpHost,port,p);
        addMessage(_("I2CP and tunnel changes will take effect after stopping all torrents"));
        if (_log.shouldLog(Log.DEBUG))         _log.debug("i2cp host [" + i2cpHost + "] i2cp port "+ port+ " opts ["+ opts+ "] oldOpts ["+ oldOpts+ "]");
      }
 else {
        if (_util.connected()) {
          _util.disconnect();
          addMessage(_("Disconnecting old I2CP destination"));
        }
        Properties p=new Properties();
        p.putAll(opts);
        addMessage(_("I2CP settings changed to {0}",i2cpHost + ":" + port+ " ("+ i2cpOpts.trim()+ ")"));
        _util.setI2CPConfig(i2cpHost,port,p);
        boolean ok=_util.connect();
        if (!ok) {
          addMessage(_("Unable to connect with the new settings, reverting to the old I2CP settings"));
          _util.setI2CPConfig(oldI2CPHost,oldI2CPPort,oldOpts);
          ok=_util.connect();
          if (!ok)           addMessage(_("Unable to reconnect with the old settings!"));
        }
 else {
          addMessage(_("Reconnected on the new I2CP destination"));
          _config.setProperty(PROP_I2CP_HOST,i2cpHost.trim());
          _config.setProperty(PROP_I2CP_PORT,"" + port);
          _config.setProperty(PROP_I2CP_OPTS,i2cpOpts.trim());
          changed=true;
          for (Iterator iter=names.iterator(); iter.hasNext(); ) {
            String name=(String)iter.next();
            Snark snark=getTorrent(name);
            if (snark != null && snark.restartAcceptor()) {
              addMessage(_("I2CP listener restarted for \"{0}\"",snark.getBaseName()));
            }
          }
        }
      }
      changed=true;
    }
  }
  if (shouldAutoStart() != autoStart) {
    _config.setProperty(PROP_AUTO_START,autoStart + "");
    if (autoStart)     addMessage(_("Enabled autostart"));
 else     addMessage(_("Disabled autostart"));
    changed=true;
  }
  if (_util.shouldUseOpenTrackers() != useOpenTrackers) {
    _config.setProperty(I2PSnarkUtil.PROP_USE_OPENTRACKERS,useOpenTrackers + "");
    if (useOpenTrackers)     addMessage(_("Enabled open trackers - torrent restart required to take effect."));
 else     addMessage(_("Disabled open trackers - torrent restart required to take effect."));
    _util.setUseOpenTrackers(useOpenTrackers);
    changed=true;
  }
  if (openTrackers != null) {
    if (openTrackers.trim().length() > 0 && !openTrackers.trim().equals(_util.getOpenTrackerString())) {
      _config.setProperty(I2PSnarkUtil.PROP_OPENTRACKERS,openTrackers.trim());
      _util.setOpenTrackerString(openTrackers);
      addMessage(_("Open Tracker list changed - torrent restart required to take effect."));
      changed=true;
    }
  }
  if (theme != null) {
    if (!theme.equals(_config.getProperty(PROP_THEME))) {
      _config.setProperty(PROP_THEME,theme);
      addMessage(_("{0} theme loaded, return to main i2psnark page to view.",theme));
      changed=true;
    }
  }
  if (changed) {
    saveConfig();
  }
 else {
    addMessage(_("Configuration unchanged."));
  }
}
