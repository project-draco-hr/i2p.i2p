{
  boolean changed=false;
  if (eepHost != null) {
    int port=_util.getEepProxyPort();
    try {
      port=Integer.parseInt(eepPort);
    }
 catch (    NumberFormatException nfe) {
    }
    String host=_util.getEepProxyHost();
    if ((eepHost.trim().length() > 0) && (port > 0) && ((!host.equals(eepHost) || (port != _util.getEepProxyPort())))) {
      _util.setProxy(eepHost,port);
      changed=true;
      _config.setProperty(PROP_EEP_HOST,eepHost);
      _config.setProperty(PROP_EEP_PORT,eepPort + "");
      addMessage("EepProxy location changed to " + eepHost + ":"+ port);
    }
  }
  if (upLimit != null) {
    int limit=_util.getMaxUploaders();
    try {
      limit=Integer.parseInt(upLimit);
    }
 catch (    NumberFormatException nfe) {
    }
    if (limit != _util.getMaxUploaders()) {
      if (limit >= Snark.MIN_TOTAL_UPLOADERS) {
        _util.setMaxUploaders(limit);
        changed=true;
        _config.setProperty(PROP_UPLOADERS_TOTAL,"" + limit);
        addMessage("Total uploaders limit changed to " + limit);
      }
 else {
        addMessage("Minimum total uploaders limit is " + Snark.MIN_TOTAL_UPLOADERS);
      }
    }
  }
  if (upBW != null) {
    int limit=_util.getMaxUpBW();
    try {
      limit=Integer.parseInt(upBW);
    }
 catch (    NumberFormatException nfe) {
    }
    if (limit != _util.getMaxUpBW()) {
      if (limit >= MIN_UP_BW) {
        _util.setMaxUpBW(limit);
        changed=true;
        _config.setProperty(PROP_UPBW_MAX,"" + limit);
        addMessage("Up BW limit changed to " + limit + "KBps");
      }
 else {
        addMessage("Minimum Up BW limit is " + MIN_UP_BW + "KBps");
      }
    }
  }
  if (i2cpHost != null) {
    int oldI2CPPort=_util.getI2CPPort();
    String oldI2CPHost=_util.getI2CPHost();
    int port=oldI2CPPort;
    try {
      port=Integer.parseInt(i2cpPort);
    }
 catch (    NumberFormatException nfe) {
    }
    String host=oldI2CPHost;
    Map opts=new HashMap();
    if (i2cpOpts == null)     i2cpOpts="";
    StringTokenizer tok=new StringTokenizer(i2cpOpts," \t\n");
    while (tok.hasMoreTokens()) {
      String pair=tok.nextToken();
      int split=pair.indexOf('=');
      if (split > 0)       opts.put(pair.substring(0,split),pair.substring(split + 1));
    }
    Map oldOpts=new HashMap();
    String oldI2CPOpts=_config.getProperty(PROP_I2CP_OPTS);
    if (oldI2CPOpts == null)     oldI2CPOpts="";
    tok=new StringTokenizer(oldI2CPOpts," \t\n");
    while (tok.hasMoreTokens()) {
      String pair=tok.nextToken();
      int split=pair.indexOf('=');
      if (split > 0)       oldOpts.put(pair.substring(0,split),pair.substring(split + 1));
    }
    if ((i2cpHost.trim().length() > 0) && (port > 0) && ((!host.equals(i2cpHost) || (port != _util.getI2CPPort()) || (!oldOpts.equals(opts))))) {
      boolean snarksActive=false;
      Set names=listTorrentFiles();
      for (Iterator iter=names.iterator(); iter.hasNext(); ) {
        Snark snark=getTorrent((String)iter.next());
        if ((snark != null) && (!snark.stopped)) {
          snarksActive=true;
          break;
        }
      }
      if (snarksActive) {
        addMessage("Cannot change the I2CP settings while torrents are active");
        _log.debug("i2cp host [" + i2cpHost + "] i2cp port "+ port+ " opts ["+ opts+ "] oldOpts ["+ oldOpts+ "]");
      }
 else {
        if (_util.connected()) {
          _util.disconnect();
          addMessage("Disconnecting old I2CP destination");
        }
        Properties p=new Properties();
        p.putAll(opts);
        addMessage("I2CP settings changed to " + i2cpHost + ":"+ port+ " ("+ i2cpOpts.trim()+ ")");
        _util.setI2CPConfig(i2cpHost,port,p);
        boolean ok=_util.connect();
        if (!ok) {
          addMessage("Unable to connect with the new settings, reverting to the old I2CP settings");
          _util.setI2CPConfig(oldI2CPHost,oldI2CPPort,oldOpts);
          ok=_util.connect();
          if (!ok)           addMessage("Unable to reconnect with the old settings!");
        }
 else {
          addMessage("Reconnected on the new I2CP destination");
          _config.setProperty(PROP_I2CP_HOST,i2cpHost.trim());
          _config.setProperty(PROP_I2CP_PORT,"" + port);
          _config.setProperty(PROP_I2CP_OPTS,i2cpOpts.trim());
          changed=true;
          for (Iterator iter=names.iterator(); iter.hasNext(); ) {
            String name=(String)iter.next();
            Snark snark=getTorrent(name);
            if ((snark != null) && (snark.acceptor != null)) {
              snark.acceptor.restart();
              addMessage("I2CP listener restarted for " + snark.meta.getName());
            }
          }
        }
      }
      changed=true;
    }
  }
  if (shouldAutoStart() != autoStart) {
    _config.setProperty(PROP_AUTO_START,autoStart + "");
    addMessage("Adjusted autostart to " + autoStart);
    changed=true;
  }
  if (_util.shouldUseOpenTrackers() != useOpenTrackers) {
    _config.setProperty(I2PSnarkUtil.PROP_USE_OPENTRACKERS,useOpenTrackers + "");
    addMessage((useOpenTrackers ? "En" : "Dis") + "abled open trackers - torrent restart required to take effect.");
    changed=true;
  }
  if (openTrackers != null) {
    if (openTrackers.trim().length() > 0 && !openTrackers.trim().equals(_util.getOpenTrackerString())) {
      _config.setProperty(I2PSnarkUtil.PROP_OPENTRACKERS,openTrackers.trim());
      addMessage("Open Tracker list changed - torrent restart required to take effect.");
      changed=true;
    }
  }
  if (changed) {
    saveConfig();
  }
 else {
    addMessage("Configuration unchanged.");
  }
}
