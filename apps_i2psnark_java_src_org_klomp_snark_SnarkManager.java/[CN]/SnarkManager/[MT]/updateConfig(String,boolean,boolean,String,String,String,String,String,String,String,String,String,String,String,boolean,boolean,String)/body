{
  boolean changed=false;
  boolean interruptMonitor=false;
  if (upLimit != null) {
    int limit=_util.getMaxUploaders();
    try {
      limit=Integer.parseInt(upLimit.trim());
    }
 catch (    NumberFormatException nfe) {
    }
    if (limit != _util.getMaxUploaders()) {
      if (limit >= Snark.MIN_TOTAL_UPLOADERS) {
        _util.setMaxUploaders(limit);
        changed=true;
        _config.setProperty(PROP_UPLOADERS_TOTAL,Integer.toString(limit));
        addMessage(_("Total uploaders limit changed to {0}",limit));
      }
 else {
        addMessage(_("Minimum total uploaders limit is {0}",Snark.MIN_TOTAL_UPLOADERS));
      }
    }
  }
  if (upBW != null) {
    int limit=_util.getMaxUpBW();
    try {
      limit=Integer.parseInt(upBW.trim());
    }
 catch (    NumberFormatException nfe) {
    }
    if (limit != _util.getMaxUpBW()) {
      if (limit >= MIN_UP_BW) {
        _util.setMaxUpBW(limit);
        changed=true;
        _config.setProperty(PROP_UPBW_MAX,Integer.toString(limit));
        addMessage(_("Up BW limit changed to {0}KBps",limit));
      }
 else {
        addMessage(_("Minimum up bandwidth limit is {0}KBps",MIN_UP_BW));
      }
    }
  }
  if (startDelay != null) {
    int minutes=_util.getStartupDelay();
    try {
      minutes=Integer.parseInt(startDelay.trim());
    }
 catch (    NumberFormatException nfe) {
    }
    if (minutes != _util.getStartupDelay()) {
      _util.setStartupDelay(minutes);
      changed=true;
      _config.setProperty(PROP_STARTUP_DELAY,Integer.toString(minutes));
      addMessage(_("Startup delay changed to {0}",DataHelper.formatDuration2(minutes * (60L * 1000))));
    }
  }
  if (refreshDelay != null) {
    try {
      int secs=Integer.parseInt(refreshDelay.trim());
      if (secs != getRefreshDelaySeconds()) {
        changed=true;
        _config.setProperty(PROP_REFRESH_DELAY,Integer.toString(secs));
        if (secs >= 0)         addMessage(_("Refresh time changed to {0}",DataHelper.formatDuration2(secs * 1000)));
 else         addMessage(_("Refresh disabled"));
      }
    }
 catch (    NumberFormatException nfe) {
    }
  }
  if (pageSize != null) {
    try {
      int size=Integer.parseInt(pageSize.trim());
      if (size <= 0)       size=999999;
 else       if (size < 5)       size=5;
      if (size != getPageSize()) {
        changed=true;
        pageSize=Integer.toString(size);
        _config.setProperty(PROP_PAGE_SIZE,pageSize);
        addMessage(_("Page size changed to {0}",pageSize));
      }
    }
 catch (    NumberFormatException nfe) {
    }
  }
  if (dataDir != null && !dataDir.equals(getDataDir().getAbsolutePath())) {
    dataDir=dataDir.trim();
    File dd=new File(dataDir);
    if (!dd.isAbsolute()) {
      addMessage(_("Data directory must be an absolute path") + ": " + dataDir);
    }
 else     if (!dd.exists()) {
      addMessage(_("Data directory does not exist") + ": " + dataDir);
    }
 else     if (!dd.isDirectory()) {
      addMessage(_("Not a directory") + ": " + dataDir);
    }
 else     if (!dd.canRead()) {
      addMessage(_("Unreadable") + ": " + dataDir);
    }
 else {
      changed=true;
      interruptMonitor=true;
      _config.setProperty(PROP_DIR,dataDir);
      addMessage(_("Data directory changed to {0}",dataDir));
    }
  }
  int oldI2CPPort=_util.getI2CPPort();
  String oldI2CPHost=_util.getI2CPHost();
  int port=oldI2CPPort;
  if (i2cpPort != null) {
    try {
      port=Integer.parseInt(i2cpPort);
    }
 catch (    NumberFormatException nfe) {
    }
  }
  Map<String,String> opts=new HashMap<String,String>();
  if (i2cpOpts == null)   i2cpOpts="";
  StringTokenizer tok=new StringTokenizer(i2cpOpts," \t\n");
  while (tok.hasMoreTokens()) {
    String pair=tok.nextToken();
    int split=pair.indexOf('=');
    if (split > 0)     opts.put(pair.substring(0,split),pair.substring(split + 1));
  }
  Map<String,String> oldOpts=new HashMap<String,String>();
  String oldI2CPOpts=_config.getProperty(PROP_I2CP_OPTS);
  if (oldI2CPOpts == null)   oldI2CPOpts="";
  tok=new StringTokenizer(oldI2CPOpts," \t\n");
  while (tok.hasMoreTokens()) {
    String pair=tok.nextToken();
    int split=pair.indexOf('=');
    if (split > 0)     oldOpts.put(pair.substring(0,split),pair.substring(split + 1));
  }
  boolean reconnect=i2cpHost != null && i2cpHost.trim().length() > 0 && port > 0 && (port != _util.getI2CPPort() || !oldI2CPHost.equals(i2cpHost));
  if (reconnect || !oldOpts.equals(opts)) {
    boolean snarksActive=false;
    if (reconnect) {
      for (      Snark snark : _snarks.values()) {
        if (!snark.isStopped()) {
          snarksActive=true;
          break;
        }
      }
    }
    if (_log.shouldLog(Log.DEBUG))     _log.debug("i2cp host [" + i2cpHost + "] i2cp port "+ port+ " opts ["+ opts+ "] oldOpts ["+ oldOpts+ "]");
    if (snarksActive) {
      Properties p=new Properties();
      p.putAll(opts);
      _util.setI2CPConfig(i2cpHost,port,p);
      _util.setMaxUpBW(getInt(PROP_UPBW_MAX,DEFAULT_MAX_UP_BW));
      addMessage(_("I2CP and tunnel changes will take effect after stopping all torrents"));
    }
 else     if (!reconnect) {
      _config.setProperty(PROP_I2CP_OPTS,i2cpOpts.trim());
      addMessage(_("I2CP options changed to {0}",i2cpOpts));
      _util.setI2CPConfig(oldI2CPHost,oldI2CPPort,opts);
    }
 else {
      if (_util.connected()) {
        _util.disconnect();
        addMessage(_("Disconnecting old I2CP destination"));
      }
      addMessage(_("I2CP settings changed to {0}",i2cpHost + ':' + port+ ' '+ i2cpOpts));
      _util.setI2CPConfig(i2cpHost,port,opts);
      _util.setMaxUpBW(getInt(PROP_UPBW_MAX,DEFAULT_MAX_UP_BW));
      boolean ok=_util.connect();
      if (!ok) {
        addMessage(_("Unable to connect with the new settings, reverting to the old I2CP settings"));
        _util.setI2CPConfig(oldI2CPHost,oldI2CPPort,oldOpts);
        ok=_util.connect();
        if (!ok)         addMessage(_("Unable to reconnect with the old settings!"));
      }
 else {
        addMessage(_("Reconnected on the new I2CP destination"));
        _config.setProperty(PROP_I2CP_HOST,i2cpHost.trim());
        _config.setProperty(PROP_I2CP_PORT,"" + port);
        _config.setProperty(PROP_I2CP_OPTS,i2cpOpts.trim());
        for (        Snark snark : _snarks.values()) {
          if (snark.restartAcceptor()) {
            addMessage(_("I2CP listener restarted for \"{0}\"",snark.getBaseName()));
            break;
          }
        }
      }
    }
    changed=true;
  }
  if (areFilesPublic() != filesPublic) {
    _config.setProperty(PROP_FILES_PUBLIC,Boolean.toString(filesPublic));
    _util.setFilesPublic(filesPublic);
    if (filesPublic)     addMessage(_("New files will be publicly readable"));
 else     addMessage(_("New files will not be publicly readable"));
    changed=true;
  }
  if (shouldAutoStart() != autoStart) {
    _config.setProperty(PROP_AUTO_START,Boolean.toString(autoStart));
    if (autoStart)     addMessage(_("Enabled autostart"));
 else     addMessage(_("Disabled autostart"));
    changed=true;
  }
  if (_util.shouldUseOpenTrackers() != useOpenTrackers) {
    _config.setProperty(PROP_USE_OPENTRACKERS,useOpenTrackers + "");
    if (useOpenTrackers)     addMessage(_("Enabled open trackers - torrent restart required to take effect."));
 else     addMessage(_("Disabled open trackers - torrent restart required to take effect."));
    _util.setUseOpenTrackers(useOpenTrackers);
    changed=true;
  }
  if (_util.shouldUseDHT() != useDHT) {
    _config.setProperty(PROP_USE_DHT,Boolean.toString(useDHT));
    if (useDHT)     addMessage(_("Enabled DHT."));
 else     addMessage(_("Disabled DHT."));
    if (_util.connected())     addMessage(_("DHT change requires tunnel shutdown and reopen"));
    _util.setUseDHT(useDHT);
    changed=true;
  }
  if (theme != null) {
    if (!theme.equals(_config.getProperty(PROP_THEME))) {
      _config.setProperty(PROP_THEME,theme);
      addMessage(_("{0} theme loaded, return to main i2psnark page to view.",theme));
      changed=true;
    }
  }
  if (changed) {
    saveConfig();
    if (interruptMonitor)     _monitor.interrupt();
  }
 else {
    addMessage(_("Configuration unchanged."));
  }
}
