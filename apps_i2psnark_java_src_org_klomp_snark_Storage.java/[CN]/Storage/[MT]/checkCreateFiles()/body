{
  boolean resume=false;
  _probablyComplete=true;
  needed=metainfo.getPieces();
  for (int i=0; i < rafs.length; i++) {
    long length=RAFfile[i].length();
    if (RAFfile[i].exists() && length == lengths[i]) {
      if (listener != null)       listener.storageAllocated(this,length);
      resume=true;
    }
 else     if (length == 0) {
      changed=true;
synchronized (RAFlock[i]) {
        allocateFile(i);
      }
    }
 else {
      _util.debug("File '" + names[i] + "' exists, but has wrong length - repairing corruption",Snark.ERROR);
      changed=true;
      _probablyComplete=false;
synchronized (RAFlock[i]) {
        checkRAF(i);
        rafs[i].setLength(lengths[i]);
      }
    }
  }
  if (resume) {
    pieces=metainfo.getPieces();
    byte[] piece=new byte[metainfo.getPieceLength(0)];
    for (int i=0; i < pieces; i++) {
      int length=getUncheckedPiece(i,piece);
      boolean correctHash=metainfo.checkPiece(i,piece,0,length);
      if (correctHash) {
        bitfield.set(i);
        needed--;
      }
      if (listener != null)       listener.storageChecked(this,i,correctHash);
    }
  }
  _probablyComplete=complete();
  for (int i=0; i < rafs.length; i++) {
synchronized (RAFlock[i]) {
      try {
        closeRAF(i);
      }
 catch (      IOException ioe) {
      }
    }
  }
  if (listener != null) {
    listener.storageAllChecked(this);
    if (needed <= 0)     listener.storageCompleted(this);
  }
}
