{
  boolean resume=false;
  _probablyComplete=true;
  needed=metainfo.getPieces();
  for (int i=0; i < rafs.length; i++) {
    long length=RAFfile[i].length();
    if (RAFfile[i].exists() && length == lengths[i]) {
      if (listener != null)       listener.storageAllocated(this,length);
      resume=true;
    }
 else     if (length == 0) {
      changed=true;
synchronized (RAFlock[i]) {
        allocateFile(i);
        try {
          closeRAF(i);
        }
 catch (        IOException ioe) {
        }
      }
    }
 else {
      _util.debug("File '" + names[i] + "' exists, but has wrong length - repairing corruption",Snark.ERROR);
      changed=true;
      _probablyComplete=false;
synchronized (RAFlock[i]) {
        checkRAF(i);
        rafs[i].setLength(lengths[i]);
        try {
          closeRAF(i);
        }
 catch (        IOException ioe) {
        }
      }
    }
  }
  if (resume) {
    pieces=metainfo.getPieces();
    byte[] piece=new byte[metainfo.getPieceLength(0)];
    int file=0;
    long fileEnd=lengths[0];
    long pieceEnd=0;
    for (int i=0; i < pieces; i++) {
      int length=getUncheckedPiece(i,piece);
      boolean correctHash=metainfo.checkPiece(i,piece,0,length);
      pieceEnd+=length;
      while (fileEnd <= pieceEnd) {
synchronized (RAFlock[file]) {
          try {
            closeRAF(file);
          }
 catch (          IOException ioe) {
          }
        }
        if (++file >= rafs.length)         break;
        fileEnd+=lengths[file];
      }
      if (correctHash) {
        bitfield.set(i);
        needed--;
      }
      if (listener != null)       listener.storageChecked(this,i,correctHash);
    }
  }
  _probablyComplete=complete();
  if (listener != null) {
    listener.storageAllChecked(this);
    if (needed <= 0)     listener.storageCompleted(this);
  }
}
