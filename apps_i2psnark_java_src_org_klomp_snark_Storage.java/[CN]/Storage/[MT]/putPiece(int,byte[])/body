{
  byte[] bs=(byte[])ba.clone();
  int length=bs.length;
  boolean correctHash=metainfo.checkPiece(piece,bs,0,length);
  if (listener != null)   listener.storageChecked(this,piece,correctHash);
  if (!correctHash)   return false;
synchronized (bitfield) {
    if (bitfield.get(piece))     return true;
  }
  long start=(long)piece * (long)metainfo.getPieceLength(0);
  int i=0;
  long raflen=lengths[i];
  while (start > raflen) {
    i++;
    start-=raflen;
    raflen=lengths[i];
  }
  int written=0;
  int off=0;
  while (written < length) {
    int need=length - written;
    int len=(start + need < raflen) ? need : (int)(raflen - start);
synchronized (RAFlock[i]) {
      checkRAF(i);
      rafs[i].seek(start);
      rafs[i].write(bs,off + written,len);
    }
    written+=len;
    if (need - len > 0) {
      i++;
      raflen=lengths[i];
      start=0;
    }
  }
  changed=true;
  boolean complete=false;
synchronized (bitfield) {
    if (!bitfield.get(piece)) {
      bitfield.set(piece);
      needed--;
      complete=needed == 0;
    }
  }
  if (complete) {
    checkCreateFiles(true);
    if (needed > 0) {
      if (listener != null)       listener.setWantedPieces(this);
      _util.debug("WARNING: Not really done, missing " + needed + " pieces",Snark.WARNING);
    }
  }
  return true;
}
