{
  String infoHash=urlencode(snark.getInfoHash());
  String peerID=urlencode(snark.getID());
  trackers=new ArrayList(2);
  String primary=null;
  if (meta != null)   primary=meta.getAnnounce();
 else   if (additionalTrackerURL != null)   primary=additionalTrackerURL;
  if (primary != null) {
    if (isValidAnnounce(primary)) {
      trackers.add(new Tracker(primary,true));
      _log.debug("Announce: [" + primary + "] infoHash: "+ infoHash);
    }
 else {
      _log.warn("Skipping invalid or non-i2p announce: " + primary);
    }
  }
 else {
    _log.warn("No primary announce");
    primary="";
  }
  List tlist=_util.getOpenTrackers();
  if (tlist != null) {
    for (int i=0; i < tlist.size(); i++) {
      String url=(String)tlist.get(i);
      if (!isValidAnnounce(url)) {
        _log.error("Bad announce URL: [" + url + "]");
        continue;
      }
      int slash=url.indexOf('/',7);
      if (slash <= 7) {
        _log.error("Bad announce URL: [" + url + "]");
        continue;
      }
      if (primary.startsWith(url.substring(0,slash)))       continue;
      String dest=_util.lookup(url.substring(7,slash));
      if (dest == null) {
        _log.error("Announce host unknown: [" + url.substring(7,slash) + "]");
        continue;
      }
      if (primary.startsWith("http://" + dest))       continue;
      if (primary.startsWith("http://i2p/" + dest))       continue;
      trackers.add(new Tracker(url,primary.equals("")));
      _log.debug("Additional announce: [" + url + "] for infoHash: "+ infoHash);
    }
  }
  if (trackers.isEmpty()) {
    stop=true;
    SnarkManager.instance().addMessage("No valid trackers for " + this.snark.getBaseName() + " - enable opentrackers?");
    _log.error("No valid trackers for " + this.snark.getBaseName());
    this.snark.stopTorrent();
    return;
  }
  long uploaded=coordinator.getUploaded();
  long downloaded=coordinator.getDownloaded();
  long left=coordinator.getLeft();
  boolean completed=(left == 0);
  int sleptTime=0;
  try {
    if (!verifyConnected())     return;
    boolean runStarted=false;
    boolean firstTime=true;
    int consecutiveFails=0;
    Random r=I2PAppContext.getGlobalContext().random();
    while (!stop) {
      if (_util.getDHT() != null)       _util.getDHT().announce(snark.getInfoHash());
      try {
        int delay;
        int random=r.nextInt(120 * 1000);
        if (firstTime) {
          delay=r.nextInt(30 * 1000);
          firstTime=false;
        }
 else         if (completed && runStarted)         delay=3 * SLEEP * 60* 1000 + random;
 else         if (snark.getTrackerProblems() != null && ++consecutiveFails < MAX_CONSEC_FAILS)         delay=INITIAL_SLEEP;
 else         delay=SLEEP * 60 * 1000 + random;
        if (delay > 0)         Thread.sleep(delay);
      }
 catch (      InterruptedException interrupt) {
      }
      if (stop)       break;
      if (!verifyConnected())       return;
      uploaded=coordinator.getUploaded();
      downloaded=coordinator.getDownloaded();
      left=coordinator.getLeft();
      String event;
      if (!completed && left == 0) {
        completed=true;
        event=COMPLETED_EVENT;
      }
 else       event=NO_EVENT;
      sleptTime=0;
      int maxSeenPeers=0;
      for (Iterator iter=trackers.iterator(); iter.hasNext(); ) {
        Tracker tr=(Tracker)iter.next();
        if ((!stop) && (!tr.stop) && (completed || coordinator.needPeers())&& (event.equals(COMPLETED_EVENT) || System.currentTimeMillis() > tr.lastRequestTime + tr.interval)) {
          try {
            if (!tr.started)             event=STARTED_EVENT;
            TrackerInfo info=doRequest(tr,infoHash,peerID,uploaded,downloaded,left,event);
            snark.setTrackerProblems(null);
            tr.trackerProblems=null;
            tr.registerFails=0;
            tr.consecutiveFails=0;
            if (tr.isPrimary)             consecutiveFails=0;
            runStarted=true;
            tr.started=true;
            Set<Peer> peers=info.getPeers();
            tr.seenPeers=info.getPeerCount();
            if (snark.getTrackerSeenPeers() < tr.seenPeers)             snark.setTrackerSeenPeers(tr.seenPeers);
            if (_util.getDHT() != null) {
              for (              Peer peer : peers) {
                _util.getDHT().announce(snark.getInfoHash(),peer.getPeerID().getDestHash());
              }
            }
            if ((left != 0) && (!completed)) {
              List<Peer> ordered=new ArrayList(peers);
              Collections.shuffle(ordered,r);
              Iterator<Peer> it=ordered.iterator();
              while ((!stop) && it.hasNext()) {
                Peer cur=it.next();
                if (coordinator.addPeer(cur) && it.hasNext()) {
                  int delay=(DELAY_MUL * r.nextInt(10)) + DELAY_MIN;
                  sleptTime+=delay;
                  try {
                    Thread.sleep(delay);
                  }
 catch (                  InterruptedException ie) {
                  }
                }
              }
            }
          }
 catch (          IOException ioe) {
            _util.debug("WARNING: Could not contact tracker at '" + tr.announce + "': "+ ioe,Snark.WARNING);
            tr.trackerProblems=ioe.getMessage();
            if (tr.isPrimary)             snark.setTrackerProblems(tr.trackerProblems);
            if (tr.trackerProblems.toLowerCase().startsWith(NOT_REGISTERED)) {
              if (trackers.size() == 1) {
                stop=true;
                snark.stopTorrent();
              }
 else {
                if (tr.registerFails++ > MAX_REGISTER_FAILS)                 tr.stop=true;
              }
            }
            if (++tr.consecutiveFails == MAX_CONSEC_FAILS) {
              tr.seenPeers=0;
              if (tr.interval < LONG_SLEEP)               tr.interval=LONG_SLEEP;
            }
          }
        }
        if ((!tr.stop) && maxSeenPeers < tr.seenPeers)         maxSeenPeers=tr.seenPeers;
      }
      if (left > 0 && coordinator.needPeers() && !stop) {
        Set<PeerID> pids=coordinator.getPEXPeers();
        if (!pids.isEmpty()) {
          _util.debug("Got " + pids.size() + " from PEX",Snark.INFO);
          List<Peer> peers=new ArrayList(pids.size());
          for (          PeerID pID : pids) {
            peers.add(new Peer(pID,snark.getID(),snark.getInfoHash(),snark.getMetaInfo()));
          }
          Collections.shuffle(peers,r);
          Iterator<Peer> it=peers.iterator();
          while ((!stop) && it.hasNext()) {
            Peer cur=it.next();
            if (coordinator.addPeer(cur) && it.hasNext()) {
              int delay=(DELAY_MUL * r.nextInt(10)) + DELAY_MIN;
              try {
                Thread.sleep(delay);
              }
 catch (              InterruptedException ie) {
              }
            }
          }
        }
      }
      if (_util.getDHT() != null && !stop) {
        int numwant;
        if (left == 0 || event.equals(STOPPED_EVENT) || !coordinator.needPeers())         numwant=1;
 else         numwant=_util.getMaxConnections();
        List<Hash> hashes=_util.getDHT().getPeers(snark.getInfoHash(),numwant,2 * 60 * 1000);
        _util.debug("Got " + hashes + " from DHT",Snark.INFO);
        if (!stop) {
          int good=_util.getDHT().announce(snark.getInfoHash(),8,5 * 60 * 1000);
          _util.debug("Sent " + good + " good announces to DHT",Snark.INFO);
        }
        if ((!stop) && !hashes.isEmpty()) {
          List<Peer> peers=new ArrayList(hashes.size());
          for (          Hash h : hashes) {
            PeerID pID=new PeerID(h.getData());
            peers.add(new Peer(pID,snark.getID(),snark.getInfoHash(),snark.getMetaInfo()));
          }
          Collections.shuffle(peers,r);
          Iterator<Peer> it=peers.iterator();
          while ((!stop) && it.hasNext()) {
            Peer cur=it.next();
            if (coordinator.addPeer(cur) && it.hasNext()) {
              int delay=(DELAY_MUL * r.nextInt(10)) + DELAY_MIN;
              try {
                Thread.sleep(delay);
              }
 catch (              InterruptedException ie) {
              }
            }
          }
        }
      }
      snark.setTrackerSeenPeers(maxSeenPeers);
      if (!runStarted)       _util.debug("         Retrying in one minute...",Snark.DEBUG);
    }
  }
 catch (  Throwable t) {
    _util.debug("TrackerClient: " + t,Snark.ERROR,t);
    if (t instanceof OutOfMemoryError)     throw (OutOfMemoryError)t;
  }
 finally {
    if (_util.getDHT() != null)     _util.getDHT().unannounce(snark.getInfoHash());
    try {
      for (Iterator iter=trackers.iterator(); iter.hasNext(); ) {
        if (!_util.connected())         return;
        Tracker tr=(Tracker)iter.next();
        if (tr.started && (!tr.stop) && tr.trackerProblems == null)         doRequest(tr,infoHash,peerID,uploaded,downloaded,left,STOPPED_EVENT);
      }
    }
 catch (    IOException ioe) {
    }
  }
}
