{
  String infoHash=urlencode(meta.getInfoHash());
  String peerID=urlencode(coordinator.getID());
  _log.debug("Announce: [" + meta.getAnnounce() + "] infoHash: "+ infoHash);
  trackers=new ArrayList(2);
  String primary=meta.getAnnounce();
  if (isValidAnnounce(primary)) {
    trackers.add(new Tracker(meta.getAnnounce(),true));
  }
 else {
    _log.warn("Skipping invalid or non-i2p announce: " + primary);
  }
  List tlist=_util.getOpenTrackers();
  if (tlist != null) {
    for (int i=0; i < tlist.size(); i++) {
      String url=(String)tlist.get(i);
      if (!isValidAnnounce(url)) {
        _log.error("Bad announce URL: [" + url + "]");
        continue;
      }
      int slash=url.indexOf('/',7);
      if (slash <= 7) {
        _log.error("Bad announce URL: [" + url + "]");
        continue;
      }
      if (primary.startsWith(url.substring(0,slash)))       continue;
      String dest=_util.lookup(url.substring(7,slash));
      if (dest == null) {
        _log.error("Announce host unknown: [" + url.substring(7,slash) + "]");
        continue;
      }
      if (primary.startsWith("http://" + dest))       continue;
      if (primary.startsWith("http://i2p/" + dest))       continue;
      trackers.add(new Tracker(url,false));
      _log.debug("Additional announce: [" + url + "] for infoHash: "+ infoHash);
    }
  }
  if (tlist.isEmpty()) {
    stop=true;
    _log.error("No valid trackers for infoHash: " + infoHash);
    return;
  }
  long uploaded=coordinator.getUploaded();
  long downloaded=coordinator.getDownloaded();
  long left=coordinator.getLeft();
  boolean completed=(left == 0);
  int sleptTime=0;
  try {
    if (!verifyConnected())     return;
    boolean runStarted=false;
    boolean firstTime=true;
    int consecutiveFails=0;
    Random r=I2PAppContext.getGlobalContext().random();
    while (!stop) {
      try {
        int delay;
        int random=r.nextInt(120 * 1000);
        if (firstTime) {
          delay=r.nextInt(30 * 1000);
          firstTime=false;
        }
 else         if (completed && runStarted)         delay=3 * SLEEP * 60* 1000 + random;
 else         if (coordinator.trackerProblems != null && ++consecutiveFails < MAX_CONSEC_FAILS)         delay=INITIAL_SLEEP;
 else         delay=SLEEP * 60 * 1000 + random;
        if (delay > 0)         Thread.sleep(delay);
      }
 catch (      InterruptedException interrupt) {
      }
      if (stop)       break;
      if (!verifyConnected())       return;
      uploaded=coordinator.getUploaded();
      downloaded=coordinator.getDownloaded();
      left=coordinator.getLeft();
      String event;
      if (!completed && left == 0) {
        completed=true;
        event=COMPLETED_EVENT;
      }
 else       event=NO_EVENT;
      sleptTime=0;
      int maxSeenPeers=0;
      for (Iterator iter=trackers.iterator(); iter.hasNext(); ) {
        Tracker tr=(Tracker)iter.next();
        if ((!stop) && (!tr.stop) && (completed || coordinator.needPeers())&& (event.equals(COMPLETED_EVENT) || System.currentTimeMillis() > tr.lastRequestTime + tr.interval)) {
          try {
            if (!tr.started)             event=STARTED_EVENT;
            TrackerInfo info=doRequest(tr,infoHash,peerID,uploaded,downloaded,left,event);
            coordinator.trackerProblems=null;
            tr.trackerProblems=null;
            tr.registerFails=0;
            tr.consecutiveFails=0;
            if (tr.isPrimary)             consecutiveFails=0;
            runStarted=true;
            tr.started=true;
            Set peers=info.getPeers();
            tr.seenPeers=info.getPeerCount();
            if (coordinator.trackerSeenPeers < tr.seenPeers)             coordinator.trackerSeenPeers=tr.seenPeers;
            if ((left > 0) && (!completed)) {
              List ordered=new ArrayList(peers);
              Collections.shuffle(ordered);
              Iterator it=ordered.iterator();
              while (it.hasNext()) {
                Peer cur=(Peer)it.next();
                if (coordinator.addPeer(cur)) {
                  int delay=DELAY_MUL;
                  delay*=((int)cur.getPeerID().getAddress().calculateHash().toBase64().charAt(0)) % 10;
                  delay+=DELAY_MIN;
                  sleptTime+=delay;
                  try {
                    Thread.sleep(delay);
                  }
 catch (                  InterruptedException ie) {
                  }
                }
              }
            }
          }
 catch (          IOException ioe) {
            _util.debug("WARNING: Could not contact tracker at '" + tr.announce + "': "+ ioe,Snark.WARNING);
            tr.trackerProblems=ioe.getMessage();
            if (tr.isPrimary)             coordinator.trackerProblems=tr.trackerProblems;
            if (tr.trackerProblems.toLowerCase().startsWith(NOT_REGISTERED)) {
              if (trackers.size() == 1) {
                stop=true;
                coordinator.snark.stopTorrent();
              }
 else {
                if (tr.registerFails++ > MAX_REGISTER_FAILS)                 tr.stop=true;
              }
            }
            if (++tr.consecutiveFails == MAX_CONSEC_FAILS) {
              tr.seenPeers=0;
              if (tr.interval < LONG_SLEEP)               tr.interval=LONG_SLEEP;
            }
          }
        }
        if ((!tr.stop) && maxSeenPeers < tr.seenPeers)         maxSeenPeers=tr.seenPeers;
      }
      coordinator.trackerSeenPeers=maxSeenPeers;
      if (!runStarted)       _util.debug("         Retrying in one minute...",Snark.DEBUG);
    }
  }
 catch (  Throwable t) {
    _util.debug("TrackerClient: " + t,Snark.ERROR,t);
    if (t instanceof OutOfMemoryError)     throw (OutOfMemoryError)t;
  }
 finally {
    try {
      for (Iterator iter=trackers.iterator(); iter.hasNext(); ) {
        if (!_util.connected())         return;
        Tracker tr=(Tracker)iter.next();
        if (tr.started && (!tr.stop) && tr.trackerProblems == null)         doRequest(tr,infoHash,peerID,uploaded,downloaded,left,STOPPED_EVENT);
      }
    }
 catch (    IOException ioe) {
    }
  }
}
