{
  super(localPort + " (uninitialized)",notifyThis,tunnel);
  _clientId=++__clientId;
  this.localPort=localPort;
  this.l=l;
  _ownDest=ownDest;
  _handlerName=handlerName;
  _context=tunnel.getContext();
  _context.statManager().createRateStat("i2ptunnel.client.closeBacklog","How many pending sockets remain when we close one due to backlog?","I2PTunnel",new long[]{60 * 1000,10 * 60 * 1000,60 * 60 * 1000});
  _context.statManager().createRateStat("i2ptunnel.client.closeNoBacklog","How many pending sockets remain when it was removed prior to backlog timeout?","I2PTunnel",new long[]{60 * 1000,10 * 60 * 1000,60 * 60 * 1000});
  _context.statManager().createRateStat("i2ptunnel.client.manageTime","How long it takes to accept a socket and fire it into an i2ptunnel runner (or queue it for the pool)?","I2PTunnel",new long[]{60 * 1000,10 * 60 * 1000,60 * 60 * 1000});
  _context.statManager().createRateStat("i2ptunnel.client.buildRunTime","How long it takes to run a queued socket into an i2ptunnel runner?","I2PTunnel",new long[]{60 * 1000,10 * 60 * 1000,60 * 60 * 1000});
  _log=_context.logManager().getLog(getClass());
synchronized (_executorLock) {
    if (_executor == null)     _executor=new CustomThreadPoolExecutor();
  }
  if (pkf != null) {
    File keyFile=new File(pkf);
    if (!keyFile.isAbsolute())     keyFile=new File(_context.getConfigDir(),pkf);
    this.privKeyFile=keyFile.getAbsolutePath();
  }
  boolean dccEnabled=(this instanceof I2PTunnelIRCClient) && Boolean.parseBoolean(tunnel.getClientOptions().getProperty(I2PTunnelIRCClient.PROP_DCC));
  if (!dccEnabled)   tunnel.getClientOptions().setProperty("i2cp.dontPublishLeaseSet","true");
}
