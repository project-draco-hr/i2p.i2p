{
  Hash peerHash=socket.getPeerDestination().calculateHash();
  if (_log.shouldLog(Log.INFO))   _log.info("Incoming connection to '" + toString() + "' port "+ socket.getLocalPort()+ " from: "+ peerHash+ " port "+ socket.getPort());
  try {
    long afterAccept=getTunnel().getContext().clock().now();
    socket.setReadTimeout(HEADER_TIMEOUT);
    InputStream in=socket.getInputStream();
    StringBuilder command=new StringBuilder(128);
    Map<String,List<String>> headers=readHeaders(in,command,CLIENT_SKIPHEADERS,getTunnel().getContext());
    long afterHeaders=getTunnel().getContext().clock().now();
    Properties opts=getTunnel().getClientOptions();
    if (Boolean.parseBoolean(opts.getProperty(OPT_REJECT_INPROXY)) && (headers.containsKey("X-Forwarded-For") || headers.containsKey("X-Forwarded-Server") || headers.containsKey("X-Forwarded-Host"))) {
      if (_log.shouldLog(Log.WARN))       _log.warn("Refusing inproxy access: " + peerHash.toBase64());
      try {
        socket.getOutputStream().write(ERR_INPROXY);
      }
 catch (      IOException ioe) {
      }
      try {
        socket.close();
      }
 catch (      IOException ioe) {
      }
      return;
    }
    if (_postThrottler != null && command.length() >= 5 && command.substring(0,5).toUpperCase(Locale.US).equals("POST ")) {
      if (_postThrottler.shouldThrottle(peerHash)) {
        if (_log.shouldLog(Log.WARN))         _log.warn("Refusing POST since peer is throttled: " + peerHash.toBase64());
        try {
          socket.getOutputStream().write(ERR_DENIED);
        }
 catch (        IOException ioe) {
        }
        try {
          socket.close();
        }
 catch (        IOException ioe) {
        }
        return;
      }
    }
    addEntry(headers,HASH_HEADER,peerHash.toBase64());
    addEntry(headers,DEST32_HEADER,Base32.encode(peerHash.getData()) + ".b32.i2p");
    addEntry(headers,DEST64_HEADER,socket.getPeerDestination().toBase64());
    String spoofHost;
    int ourPort=socket.getLocalPort();
    if (ourPort != 80 && ourPort > 0 && ourPort <= 65535 && opts != null) {
      String portSpoof=opts.getProperty("spoofedHost." + ourPort);
      if (portSpoof != null)       spoofHost=portSpoof.trim();
 else       spoofHost=_spoofHost;
    }
 else {
      spoofHost=_spoofHost;
    }
    if (spoofHost != null)     setEntry(headers,"Host",spoofHost);
    setEntry(headers,"Connection","close");
    String enc=getEntryOrNull(headers,"Accept-encoding");
    String altEnc=getEntryOrNull(headers,"X-Accept-encoding");
    setEntry(headers,"Accept-encoding","");
    socket.setReadTimeout(readTimeout);
    Socket s=getSocket(socket.getPeerDestination().calculateHash(),socket.getLocalPort());
    long afterSocket=getTunnel().getContext().clock().now();
    boolean allowGZIP=true;
    if (opts != null) {
      String val=opts.getProperty("i2ptunnel.gzip");
      if ((val != null) && (!Boolean.parseBoolean(val)))       allowGZIP=false;
    }
    if (_log.shouldLog(Log.INFO))     _log.info("HTTP server encoding header: " + enc + "/"+ altEnc);
    boolean alt=(altEnc != null) && (altEnc.indexOf("x-i2p-gzip") >= 0);
    boolean useGZIP=alt || ((enc != null) && (enc.indexOf("x-i2p-gzip") >= 0));
    if (alt)     headers.remove("X-Accept-encoding");
    String modifiedHeader=formatHeaders(headers,command);
    if (_log.shouldLog(Log.DEBUG))     _log.debug("Modified header: [" + modifiedHeader + "]");
    if (allowGZIP && useGZIP) {
      I2PAppThread req=new I2PAppThread(new CompressedRequestor(s,socket,modifiedHeader,getTunnel().getContext(),_log),Thread.currentThread().getName() + ".hc");
      req.start();
    }
 else {
      Thread t=new I2PTunnelRunner(s,socket,slock,null,modifiedHeader.getBytes(),null,(I2PTunnelRunner.FailCallback)null);
      t.start();
    }
    long afterHandle=getTunnel().getContext().clock().now();
    long timeToHandle=afterHandle - afterAccept;
    getTunnel().getContext().statManager().addRateData("i2ptunnel.httpserver.blockingHandleTime",timeToHandle,0);
    if ((timeToHandle > 1000) && (_log.shouldLog(Log.WARN)))     _log.warn("Took a while to handle the request for " + remoteHost + ':'+ remotePort+ " ["+ timeToHandle+ ", read headers: "+ (afterHeaders - afterAccept)+ ", socket create: "+ (afterSocket - afterHeaders)+ ", start runners: "+ (afterHandle - afterSocket)+ "]");
  }
 catch (  SocketException ex) {
    try {
      socket.getOutputStream().write(ERR_UNAVAILABLE);
    }
 catch (    IOException ioe) {
    }
    try {
      socket.close();
    }
 catch (    IOException ioe) {
    }
    int level=getTunnel().getContext().clock().now() - _startedOn > START_INTERVAL ? Log.ERROR : Log.WARN;
    if (_log.shouldLog(level))     _log.log(level,"Error connecting to HTTP server " + remoteHost + ':'+ remotePort,ex);
  }
catch (  IOException ex) {
    try {
      socket.close();
    }
 catch (    IOException ioe) {
    }
    if (_log.shouldLog(Log.WARN))     _log.warn("Error while receiving the new HTTP request",ex);
  }
catch (  OutOfMemoryError oom) {
    try {
      socket.getOutputStream().write(ERR_UNAVAILABLE);
    }
 catch (    IOException ioe) {
    }
    try {
      socket.close();
    }
 catch (    IOException ioe) {
    }
    if (_log.shouldLog(Log.ERROR))     _log.error("OOM in HTTP server",oom);
  }
}
