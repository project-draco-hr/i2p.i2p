{
  Hash peerHash=socket.getPeerDestination().calculateHash();
  if (_log.shouldLog(Log.INFO))   _log.info("Incoming connection to '" + toString() + "' port "+ socket.getLocalPort()+ " from: "+ peerHash+ " port "+ socket.getPort());
  try {
    if (socket.getLocalPort() == 443) {
      if (getTunnel().getClientOptions().getProperty("targetForPort.443") == null) {
        try {
          socket.getOutputStream().write(ERR_SSL.getBytes("UTF-8"));
        }
 catch (        IOException ioe) {
        }
 finally {
          try {
            socket.close();
          }
 catch (          IOException ioe) {
          }
        }
        return;
      }
      Socket s=getSocket(socket.getPeerDestination().calculateHash(),443);
      Runnable t=new I2PTunnelRunner(s,socket,slock,null,null,null,(I2PTunnelRunner.FailCallback)null);
      _clientExecutor.execute(t);
      return;
    }
    long afterAccept=getTunnel().getContext().clock().now();
    StringBuilder command=new StringBuilder(128);
    Map<String,List<String>> headers=readHeaders(socket,null,command,CLIENT_SKIPHEADERS,getTunnel().getContext());
    long afterHeaders=getTunnel().getContext().clock().now();
    Properties opts=getTunnel().getClientOptions();
    if (Boolean.parseBoolean(opts.getProperty(OPT_REJECT_INPROXY)) && (headers.containsKey("X-Forwarded-For") || headers.containsKey("X-Forwarded-Server") || headers.containsKey("X-Forwarded-Host"))) {
      if (_log.shouldLog(Log.WARN)) {
        StringBuilder buf=new StringBuilder();
        buf.append("Refusing inproxy access: ").append(peerHash.toBase64());
        List<String> h=headers.get("X-Forwarded-For");
        if (h != null)         buf.append(" from: ").append(h.get(0));
        h=headers.get("X-Forwarded-Server");
        if (h != null)         buf.append(" via: ").append(h.get(0));
        h=headers.get("X-Forwarded-Host");
        if (h != null)         buf.append(" for: ").append(h.get(0));
        _log.warn(buf.toString());
      }
      try {
        socket.getOutputStream().write(ERR_INPROXY.getBytes("UTF-8"));
      }
 catch (      IOException ioe) {
      }
      try {
        socket.close();
      }
 catch (      IOException ioe) {
      }
      return;
    }
    if (_postThrottler != null && command.length() >= 5 && command.substring(0,5).toUpperCase(Locale.US).equals("POST ")) {
      if (_postThrottler.shouldThrottle(peerHash)) {
        if (_log.shouldLog(Log.WARN))         _log.warn("Refusing POST since peer is throttled: " + peerHash.toBase64());
        try {
          socket.getOutputStream().write(ERR_DENIED.getBytes("UTF-8"));
        }
 catch (        IOException ioe) {
        }
        try {
          socket.close();
        }
 catch (        IOException ioe) {
        }
        return;
      }
    }
    addEntry(headers,HASH_HEADER,peerHash.toBase64());
    addEntry(headers,DEST32_HEADER,socket.getPeerDestination().toBase32());
    addEntry(headers,DEST64_HEADER,socket.getPeerDestination().toBase64());
    String spoofHost;
    int ourPort=socket.getLocalPort();
    if (ourPort != 80 && ourPort > 0 && ourPort <= 65535) {
      String portSpoof=opts.getProperty("spoofedHost." + ourPort);
      if (portSpoof != null)       spoofHost=portSpoof.trim();
 else       spoofHost=_spoofHost;
    }
 else {
      spoofHost=_spoofHost;
    }
    if (spoofHost != null)     setEntry(headers,"Host",spoofHost);
    setEntry(headers,"Connection","close");
    String enc=getEntryOrNull(headers,"Accept-encoding");
    String altEnc=getEntryOrNull(headers,"X-Accept-encoding");
    setEntry(headers,"Accept-encoding","");
    socket.setReadTimeout(readTimeout);
    Socket s=getSocket(socket.getPeerDestination().calculateHash(),socket.getLocalPort());
    long afterSocket=getTunnel().getContext().clock().now();
    boolean allowGZIP=true;
    String val=opts.getProperty("i2ptunnel.gzip");
    if ((val != null) && (!Boolean.parseBoolean(val)))     allowGZIP=false;
    if (_log.shouldLog(Log.INFO))     _log.info("HTTP server encoding header: " + enc + "/"+ altEnc);
    boolean alt=(altEnc != null) && (altEnc.indexOf("x-i2p-gzip") >= 0);
    boolean useGZIP=alt || ((enc != null) && (enc.indexOf("x-i2p-gzip") >= 0));
    if (alt)     headers.remove("X-Accept-encoding");
    String modifiedHeader=formatHeaders(headers,command);
    if (_log.shouldLog(Log.DEBUG))     _log.debug("Modified header: [" + modifiedHeader + "]");
    Runnable t;
    if (allowGZIP && useGZIP) {
      t=new CompressedRequestor(s,socket,modifiedHeader,getTunnel().getContext(),_log);
    }
 else {
      t=new I2PTunnelRunner(s,socket,slock,null,modifiedHeader.getBytes(),null,(I2PTunnelRunner.FailCallback)null);
    }
    _clientExecutor.execute(t);
    long afterHandle=getTunnel().getContext().clock().now();
    long timeToHandle=afterHandle - afterAccept;
    getTunnel().getContext().statManager().addRateData("i2ptunnel.httpserver.blockingHandleTime",timeToHandle);
    if ((timeToHandle > 1000) && (_log.shouldLog(Log.WARN)))     _log.warn("Took a while to handle the request for " + remoteHost + ':'+ remotePort+ " ["+ timeToHandle+ ", read headers: "+ (afterHeaders - afterAccept)+ ", socket create: "+ (afterSocket - afterHeaders)+ ", start runners: "+ (afterHandle - afterSocket)+ "]");
  }
 catch (  SocketException ex) {
    try {
      socket.getOutputStream().write(ERR_UNAVAILABLE.getBytes("UTF-8"));
    }
 catch (    IOException ioe) {
    }
    try {
      socket.close();
    }
 catch (    IOException ioe) {
    }
    int level=getTunnel().getContext().clock().now() - _startedOn > START_INTERVAL ? Log.ERROR : Log.WARN;
    if (_log.shouldLog(level))     _log.log(level,"Error connecting to HTTP server " + remoteHost + ':'+ remotePort,ex);
  }
catch (  IOException ex) {
    try {
      socket.close();
    }
 catch (    IOException ioe) {
    }
    if (_log.shouldLog(Log.WARN))     _log.warn("Error while receiving the new HTTP request",ex);
  }
catch (  OutOfMemoryError oom) {
    try {
      socket.getOutputStream().write(ERR_UNAVAILABLE.getBytes("UTF-8"));
    }
 catch (    IOException ioe) {
    }
    try {
      socket.close();
    }
 catch (    IOException ioe) {
    }
    if (_log.shouldLog(Log.ERROR))     _log.error("OOM in HTTP server",oom);
  }
}
