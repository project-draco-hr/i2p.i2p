{
  this.l=l;
  this.remoteHost=host;
  this.remotePort=port;
  Properties props=new Properties();
  props.putAll(getTunnel().getClientOptions());
  int portNum=7654;
  if (getTunnel().port != null) {
    try {
      portNum=Integer.parseInt(getTunnel().port);
    }
 catch (    NumberFormatException nfe) {
      _log.error("Invalid port specified [" + getTunnel().port + "], reverting to "+ portNum);
    }
  }
  ByteArrayInputStream privDataCopy;
  try {
    privDataCopy=copyOfInputStream(privData);
  }
 catch (  IOException ioe) {
    _log.log(Log.CRIT,"Cannot read private key data for " + privkeyname,ioe);
    return;
  }
  _usePool=!getClass().equals(I2PTunnelServer.class);
  if (_usePool) {
    String usePool=getTunnel().getClientOptions().getProperty(PROP_USE_POOL);
    if (usePool != null)     _usePool="true".equalsIgnoreCase(usePool);
 else     _usePool=DEFAULT_USE_POOL;
  }
  int retries=0;
  while (sockMgr == null) {
synchronized (slock) {
      sockMgr=I2PSocketManagerFactory.createManager(privDataCopy,getTunnel().host,portNum,props);
    }
    if (sockMgr == null) {
      String msg="Unable to connect to the router at " + getTunnel().host + ':'+ portNum+ " and build tunnels for the server at "+ getTunnel().listenHost+ ':'+ port;
      if (++retries < MAX_RETRIES) {
        this.l.log(msg + ", retrying in " + (RETRY_DELAY / 1000)+ " seconds");
        _log.error(msg + ", retrying in " + (RETRY_DELAY / 1000)+ " seconds");
      }
 else {
        this.l.log(msg + ", giving up");
        _log.log(Log.CRIT,msg + ", giving up");
        throw new IllegalArgumentException(msg);
      }
      try {
        Thread.sleep(RETRY_DELAY);
      }
 catch (      InterruptedException ie) {
      }
      privDataCopy.reset();
    }
  }
  sockMgr.setName("Server");
  getTunnel().addSession(sockMgr.getSession());
  l.log("Tunnels ready for server at " + getTunnel().listenHost + ':'+ port);
  notifyEvent("openServerResult","ok");
  open=true;
}
