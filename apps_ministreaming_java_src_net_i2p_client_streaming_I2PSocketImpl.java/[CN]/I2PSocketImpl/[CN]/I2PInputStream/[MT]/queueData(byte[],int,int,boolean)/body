{
  if (_log.shouldLog(Log.DEBUG))   _log.debug(getStreamPrefix() + "Insert " + len+ " bytes into queue: "+ hashCode());
  Clock clock=I2PAppContext.getGlobalContext().clock();
  long endAfter=clock.now() + _options.getWriteTimeout();
synchronized (bc) {
    if (allowBlock) {
      if (_options.getMaxBufferSize() > 0) {
        while (bc.getCurrentSize() > _options.getMaxBufferSize()) {
          if (_log.shouldLog(Log.DEBUG))           _log.debug(getStreamPrefix() + "Buffer size exceeded: pending " + bc.getCurrentSize()+ " limit "+ _options.getMaxBufferSize());
          if (_options.getWriteTimeout() > 0) {
            long timeLeft=endAfter - clock.now();
            if (timeLeft <= 0) {
              long waited=_options.getWriteTimeout() - timeLeft;
              throw new InterruptedIOException(getStreamPrefix() + "Waited too long (" + waited+ "ms) to write "+ len+ " with a buffer at "+ bc.getCurrentSize());
            }
          }
          if (inStreamClosed)           throw new IOException(getStreamPrefix() + "Stream closed while writing");
          if (_closedOn > 0)           throw new IOException(getStreamPrefix() + "I2PSocket closed while writing");
          try {
            bc.wait(1000);
          }
 catch (          InterruptedException ie) {
          }
        }
      }
    }
    bc.append(data,off,len);
  }
synchronized (I2PInputStream.this) {
    I2PInputStream.this.notifyAll();
  }
  if (_log.shouldLog(Log.DEBUG))   _log.debug(getStreamPrefix() + "After insert " + len+ " bytes into queue: "+ hashCode());
}
