{
  byte[] buffer=new byte[MAX_PACKET_SIZE];
  ByteCollector bc=new ByteCollector();
  boolean sent=true;
  try {
    int len, bcsize;
    while (true) {
      len=in.read(buffer);
      bcsize=bc.getCurrentSize();
      if (len != -1) {
        bc.append(buffer,len);
      }
 else       if (bcsize == 0) {
        break;
      }
      if ((bcsize < MAX_PACKET_SIZE) && (in.available() == 0)) {
        _log.debug("Runner Point d: " + this.hashCode());
        try {
          Thread.sleep(PACKET_DELAY);
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
      }
      if ((bcsize >= MAX_PACKET_SIZE) || (in.available() == 0)) {
        byte[] data=bc.startToByteArray(MAX_PACKET_SIZE);
        if (data.length > 0) {
          _log.debug("Message size is: " + data.length);
          sent=sendBlock(data);
          if (!sent) {
            _log.error("Error sending message to peer.  Killing socket runner");
            break;
          }
        }
      }
    }
    if ((bc.getCurrentSize() > 0) && sent) {
      _log.error("A SCARY MONSTER HAS EATEN SOME DATA! " + "(input stream: " + in.hashCode() + "; "+ "queue size: "+ bc.getCurrentSize()+ ")");
    }
synchronized (flagLock) {
      closed2=true;
    }
    boolean sc;
synchronized (flagLock) {
      sc=sendClose;
    }
    if (sc) {
      _log.info("Sending close packet: " + outgoing);
      byte[] packet=I2PSocketManager.makePacket((byte)(getMask(0x02)),remoteID,new byte[0]);
synchronized (manager.getSession()) {
        sent=manager.getSession().sendMessage(remote,packet);
      }
      if (!sent) {
        _log.error("Error sending close packet to peer");
      }
    }
    manager.removeSocket(I2PSocketImpl.this);
  }
 catch (  InterruptedIOException ex) {
    _log.error("BUG! read() operations should not timeout!",ex);
  }
catch (  IOException ex) {
    _log.error("Error running - **INCONSISTENT STATE!!!**",ex);
  }
catch (  I2PException ex) {
    _log.error("Error running - **INCONSISTENT STATE!!!**",ex);
  }
}
