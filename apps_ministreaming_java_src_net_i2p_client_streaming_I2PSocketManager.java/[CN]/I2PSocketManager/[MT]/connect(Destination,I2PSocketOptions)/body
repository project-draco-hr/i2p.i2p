{
  String localID, lcID;
  I2PSocketImpl s;
synchronized (lock) {
    localID=makeID(_outSockets);
    lcID=getReadableForm(localID);
    s=new I2PSocketImpl(peer,this,true,localID);
    _outSockets.put(localID,s);
  }
  if (_log.shouldLog(Log.DEBUG))   _log.debug(getName() + ": connect(" + peer.calculateHash().toBase64().substring(0,6)+ ", ...): localID = "+ lcID);
  try {
    ByteArrayOutputStream pubkey=new ByteArrayOutputStream();
    _session.getMyDestination().writeBytes(pubkey);
    String remoteID;
    byte[] packet=makePacket((byte)SYN,localID,pubkey.toByteArray());
    boolean sent=false;
    sent=_session.sendMessage(peer,packet);
    if (!sent) {
      _log.info(getName() + ": Unable to send & receive ack for SYN packet for socket " + s+ " with localID = "+ lcID);
synchronized (lock) {
        _outSockets.remove(s.getLocalID());
      }
      _context.statManager().addRateData("streaming.synNoAck",1,1);
      throw new I2PException("Error sending through I2P network");
    }
 else {
      if (_log.shouldLog(Log.DEBUG))       _log.debug(getName() + ": syn sent ok to " + peer.calculateHash().toBase64().substring(0,6)+ " with localID = "+ lcID);
    }
    if (options != null)     remoteID=s.getRemoteID(true,options.getConnectTimeout());
 else     remoteID=s.getRemoteID(true,getDefaultOptions().getConnectTimeout());
    if (_log.shouldLog(Log.DEBUG))     _log.debug(getName() + ": remoteID received from " + peer.calculateHash().toBase64().substring(0,6)+ ": "+ getReadableForm(remoteID)+ " with localID = "+ lcID);
    if (remoteID == null) {
      _context.statManager().addRateData("streaming.nackReceived",1,1);
      throw new ConnectException("Connection refused by peer for socket " + s);
    }
    if ("".equals(remoteID)) {
      _context.statManager().addRateData("streaming.synNoAck",1,1);
      throw new NoRouteToHostException("Unable to reach peer for socket " + s);
    }
    if (_log.shouldLog(Log.DEBUG))     _log.debug(getName() + ": TIMING: s given out for remoteID " + getReadableForm(remoteID)+ " for socket "+ s);
    return s;
  }
 catch (  InterruptedIOException ioe) {
    if (_log.shouldLog(Log.WARN))     _log.warn(getName() + ": Timeout waiting for ack from syn for id " + lcID+ " to "+ peer.calculateHash().toBase64().substring(0,6)+ " for socket "+ s,ioe);
synchronized (lock) {
      _outSockets.remove(s.getLocalID());
    }
    s.internalClose();
    _context.statManager().addRateData("streaming.synNoAck",1,1);
    throw new InterruptedIOException("Timeout waiting for ack");
  }
catch (  ConnectException ex) {
    if (_log.shouldLog(Log.DEBUG))     _log.debug(getName() + ": Connection error waiting for ack from syn for id " + lcID+ " to "+ peer.calculateHash().toBase64().substring(0,6)+ " for socket "+ s,ex);
    s.internalClose();
    throw ex;
  }
catch (  NoRouteToHostException ex) {
    if (_log.shouldLog(Log.DEBUG))     _log.debug(getName() + ": No route to host waiting for ack from syn for id " + lcID+ " to "+ peer.calculateHash().toBase64().substring(0,6)+ " for socket "+ s,ex);
    s.internalClose();
    throw ex;
  }
catch (  IOException ex) {
    if (_log.shouldLog(Log.WARN))     _log.warn(getName() + ": Error sending syn on id " + lcID+ " to "+ peer.calculateHash().toBase64().substring(0,6)+ " for socket "+ s,ex);
synchronized (lock) {
      _outSockets.remove(s.getLocalID());
    }
    s.internalClose();
    throw new I2PException("Unhandled IOException occurred");
  }
catch (  I2PException ex) {
    if (_log.shouldLog(Log.INFO))     _log.info(getName() + ": Error sending syn on id " + lcID+ " to "+ peer.calculateHash().toBase64().substring(0,6)+ " for socket "+ s,ex);
synchronized (lock) {
      _outSockets.remove(s.getLocalID());
    }
    s.internalClose();
    throw ex;
  }
catch (  Exception e) {
    s.internalClose();
    _log.warn(getName() + ": Unhandled error connecting on " + lcID+ " to "+ peer.calculateHash().toBase64().substring(0,6)+ " for socket "+ s,e);
    throw new ConnectException("Unhandled error connecting: " + e.getMessage());
  }
}
