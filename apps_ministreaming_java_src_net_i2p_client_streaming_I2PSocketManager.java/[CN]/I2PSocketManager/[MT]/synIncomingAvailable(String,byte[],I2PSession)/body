{
  Destination d=new Destination();
  d.fromByteArray(payload);
  I2PSocketImpl s=null;
  boolean acceptConnections=(_serverSocket != null);
  String newLocalID=null;
synchronized (lock) {
    newLocalID=makeID(_inSockets);
    if (acceptConnections) {
      s=new I2PSocketImpl(d,this,false,newLocalID);
      s.setRemoteID(id);
    }
  }
  _log.debug("*Syn! for socket " + s);
  if (!acceptConnections) {
    byte[] packet=makePacket((byte)CLOSE_OUT,id,toBytes(newLocalID));
    boolean replySentOk=false;
synchronized (_session) {
      replySentOk=_session.sendMessage(d,packet);
    }
    if (!replySentOk) {
      _log.error("Error sending close to " + d.calculateHash().toBase64() + " in response to a new con message",new Exception("Failed creation"));
    }
    return;
  }
  if (_serverSocket.addWaitForAccept(s,_acceptTimeout)) {
    _inSockets.put(newLocalID,s);
    byte[] packet=makePacket((byte)ACK,id,toBytes(newLocalID));
    boolean replySentOk=false;
    replySentOk=_session.sendMessage(d,packet);
    if (!replySentOk) {
      if (_log.shouldLog(Log.WARN))       _log.warn("Error sending reply to " + d.calculateHash().toBase64() + " in response to a new con message for socket "+ s,new Exception("Failed creation"));
      s.internalClose();
    }
  }
 else {
    byte[] packet=toBytes(" " + id);
    packet[0]=CLOSE_OUT;
    boolean nackSent=session.sendMessage(d,packet);
    if (!nackSent) {
      _log.warn("Error sending NACK for session creation for socket " + s);
    }
    s.internalClose();
  }
  return;
}
