{
  String uri;
  String ext;
  SigningPrivateKey _privKey=null;
  SigningPublicKey _pubKey=null;
  if (_data == null) {
    throw new QException("No data");
  }
  if (containsKey("privateKey") && !isClient) {
    throw new QException("Only Q applications can pass in a privateKey");
  }
  if (containsKey("dataHash")) {
    if (!get("dataHash").equals(QUtil.sha64(_data))) {
      throw new QException("Invalid dataHash");
    }
  }
 else {
    put("dataHash",QUtil.sha64(_data));
  }
  if (containsKey("size")) {
    if (!get("size").toString().equals(String.valueOf(_data.length))) {
      throw new QException("Invalid size");
    }
  }
 else {
    put("size",new Integer(_data.length));
  }
  if (!containsKey("title")) {
    put("title",get("dataHash"));
  }
  if (!containsKey("type")) {
    put("type","other");
  }
  if (containsKey("path")) {
    _path=get("path").toString();
    if (_path.length() > 0) {
      if (!_path.startsWith("/")) {
        _path="/" + _path;
        put("path",_path);
      }
    }
    String[] bits=_path.split("/");
    String name=bits[bits.length - 1];
    bits=name.split("\\.",2);
    ext="." + bits[bits.length - 1];
  }
 else {
    String mime=(String)get("mimetype");
    if (mime == null) {
      mime="application/octet-stream";
      put("mimetype",mime);
    }
    ext=Mimetypes.guessExtension(mime);
    _path="/" + ((String)get("dataHash")).substring(0,10) + ext;
    put("path",_path);
  }
  if (!containsKey("mimetype")) {
    String mimetype=Mimetypes.guessType(ext);
    put("mimetype",mimetype);
  }
  if (containsKey("privateKey") && (containsKey("publicKey") || containsKey("signature"))) {
    throw new QException("Metadata must NOT contain privateKey and one of publicKey or signature");
  }
  if (containsKey("publicKey") ^ containsKey("signature")) {
    throw new QException("Either both or neither of 'publicKey' and 'signature' must be present");
  }
  if (containsKey("privateKey") || containsKey("publicKey")) {
    DSAEngine dsa=DSAEngine.getInstance();
    if (containsKey("privateKey")) {
      _privKey=new SigningPrivateKey();
      String priv64=get("privateKey").toString();
      try {
        _privKey.fromBase64(priv64);
      }
 catch (      Exception e) {
        throw new QException("Invalid privateKey",e);
      }
      this.remove("privateKey");
      _pubKey=_privKey.toPublic();
      put("publicKey",_pubKey.toBase64());
      QUtil.debug("before sig, asSortedString give:\n" + asSortedString());
      Signature sig=dsa.sign(asSortedString().getBytes(),_privKey);
      String sigBase64=sig.toBase64();
      put("signature",sigBase64);
    }
 else {
      if (!(containsKey("publicKey") && containsKey("signature"))) {
        throw new QException("need both publicKey and signature");
      }
      _pubKey=new SigningPublicKey();
      String pub64=get("publicKey").toString();
      try {
        _pubKey.fromBase64(pub64);
      }
 catch (      Exception e) {
        throw new QException("Invalid publicKey",e);
      }
    }
    byte[] thisAsBytes=asSortedString().getBytes();
    String sig64=get("signature").toString();
    Signature sig1=new Signature();
    try {
      sig1.fromBase64(sig64);
    }
 catch (    DataFormatException e) {
      throw new QException("Invalid signature string",e);
    }
    if (!dsa.verifySignature(sig1,thisAsBytes,_pubKey)) {
      throw new QException("Invalid signature");
    }
    String pubHash=QUtil.hashPubKey(_pubKey);
    uri="Q:" + pubHash + _path;
  }
 else {
    String thisHashed=QUtil.sha64(asSortedString());
    uri="Q:" + thisHashed + ext;
  }
  if (containsKey("uri")) {
    if (!get("uri").toString().equals(uri)) {
      throw new QException("Invalid URI");
    }
  }
 else {
    put("uri",uri);
  }
}
