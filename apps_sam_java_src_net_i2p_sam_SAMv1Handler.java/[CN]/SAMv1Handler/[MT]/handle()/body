{
  String msg=null;
  String domain=null;
  String opcode=null;
  boolean canContinue=false;
  StringTokenizer tok;
  Properties props;
  this.thread.setName("SAMv1Handler " + _id);
  if (_log.shouldLog(Log.DEBUG))   _log.debug("SAM handling started");
  try {
    while (true) {
      if (shouldStop()) {
        if (_log.shouldLog(Log.DEBUG))         _log.debug("Stop request found");
        break;
      }
      SocketChannel clientSocketChannel=getClientSocket();
      if (clientSocketChannel == null) {
        _log.info("Connection closed by client");
        break;
      }
      if (clientSocketChannel.socket() == null) {
        _log.info("Connection closed by client");
        break;
      }
      java.io.InputStream is=clientSocketChannel.socket().getInputStream();
      if (is == null) {
        _log.info("Connection closed by client");
        break;
      }
      msg=DataHelper.readLine(is);
      if (msg == null) {
        _log.info("Connection closed by client (line read : null)");
        break;
      }
      msg=msg.trim();
      if (_log.shouldLog(Log.DEBUG)) {
        _log.debug("New message received: [" + msg + "]");
      }
      if (msg.equals("")) {
        if (_log.shouldLog(Log.DEBUG))         _log.debug("Ignoring newline");
        continue;
      }
      tok=new StringTokenizer(msg," ");
      if (tok.countTokens() < 2) {
        if (_log.shouldLog(Log.DEBUG))         _log.debug("Error in message format");
        break;
      }
      domain=tok.nextToken();
      opcode=tok.nextToken();
      if (_log.shouldLog(Log.DEBUG)) {
        _log.debug("Parsing (domain: \"" + domain + "\"; opcode: \""+ opcode+ "\")");
      }
      props=SAMUtils.parseParams(tok);
      if (domain.equals("STREAM")) {
        canContinue=execStreamMessage(opcode,props);
      }
 else       if (domain.equals("DATAGRAM")) {
        canContinue=execDatagramMessage(opcode,props);
      }
 else       if (domain.equals("RAW")) {
        canContinue=execRawMessage(opcode,props);
      }
 else       if (domain.equals("SESSION")) {
        if (i2cpProps != null)         props.putAll(i2cpProps);
        canContinue=execSessionMessage(opcode,props);
      }
 else       if (domain.equals("DEST")) {
        canContinue=execDestMessage(opcode,props);
      }
 else       if (domain.equals("NAMING")) {
        canContinue=execNamingMessage(opcode,props);
      }
 else {
        if (_log.shouldLog(Log.DEBUG))         _log.debug("Unrecognized message domain: \"" + domain + "\"");
        break;
      }
      if (!canContinue) {
        break;
      }
    }
  }
 catch (  IOException e) {
    if (_log.shouldLog(Log.DEBUG))     _log.debug("Caught IOException for message [" + msg + "]",e);
  }
catch (  SAMException e) {
    _log.error("Unexpected exception for message [" + msg + "]",e);
  }
catch (  RuntimeException e) {
    _log.error("Unexpected exception for message [" + msg + "]",e);
  }
 finally {
    if (_log.shouldLog(Log.DEBUG))     _log.debug("Stopping handler");
    try {
      closeClientSocket();
    }
 catch (    IOException e) {
      if (_log.shouldWarn())       _log.warn("Error closing socket",e);
    }
    if (getRawSession() != null) {
      getRawSession().close();
    }
    if (getDatagramSession() != null) {
      getDatagramSession().close();
    }
    if (getStreamSession() != null) {
      getStreamSession().close();
    }
  }
}
