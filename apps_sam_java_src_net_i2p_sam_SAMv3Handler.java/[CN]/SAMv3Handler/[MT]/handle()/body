{
  String msg=null;
  String domain=null;
  String opcode=null;
  boolean canContinue=false;
  StringTokenizer tok;
  Properties props;
  this.thread.setName("SAMv3Handler " + _id);
  if (_log.shouldLog(Log.DEBUG))   _log.debug("SAMv3 handling started");
  try {
    Socket socket=getClientSocket().socket();
    InputStream in=socket.getInputStream();
    StringBuilder buf=new StringBuilder(1024);
    while (true) {
      if (shouldStop()) {
        if (_log.shouldLog(Log.DEBUG))         _log.debug("Stop request found");
        break;
      }
      String line;
      if (sendPorts) {
        try {
          ReadLine.readLine(socket,buf,READ_TIMEOUT);
          line=buf.toString();
          buf.setLength(0);
        }
 catch (        SocketTimeoutException ste) {
          long now=System.currentTimeMillis();
          if (buf.length() <= 0) {
            if (_lastPing > 0) {
              if (now - _lastPing >= READ_TIMEOUT) {
                if (_log.shouldWarn())                 _log.warn("Failed to respond to PING");
                writeString("SESSION STATUS RESULT=I2P_ERROR MESSAGE=\"PONG timeout\"\n");
                break;
              }
            }
 else {
              if (_log.shouldDebug())               _log.debug("Sendng PING " + now);
              _lastPing=now;
              if (!writeString("PING " + now + '\n'))               break;
            }
          }
 else {
            if (_lastPing > 0) {
              if (now - _lastPing >= 2 * READ_TIMEOUT) {
                if (_log.shouldWarn())                 _log.warn("Failed to respond to PING");
                writeString("SESSION STATUS RESULT=I2P_ERROR MESSAGE=\"PONG timeout\"\n");
                break;
              }
            }
 else             if (_lastPing < 0) {
              if (_log.shouldWarn())               _log.warn("2nd timeout");
              writeString("SESSION STATUS RESULT=I2P_ERROR MESSAGE=\"command timeout, bye\"\n");
              break;
            }
 else {
              _lastPing=-1;
              if (_log.shouldWarn())               _log.warn("timeout after partial: " + buf);
            }
          }
          if (_log.shouldDebug())           _log.debug("loop after timeout");
          continue;
        }
      }
 else {
        buf.setLength(0);
        if (DataHelper.readLine(in,buf))         line=buf.toString();
 else         line=null;
      }
      if (line == null) {
        if (_log.shouldLog(Log.DEBUG))         _log.debug("Connection closed by client (line read : null)");
        break;
      }
      msg=line.trim();
      if (_log.shouldLog(Log.DEBUG)) {
        if (_log.shouldLog(Log.DEBUG))         _log.debug("New message received: [" + msg + "]");
      }
      if (msg.equals("")) {
        if (_log.shouldLog(Log.DEBUG))         _log.debug("Ignoring newline");
        continue;
      }
      tok=new StringTokenizer(msg," ");
      int count=tok.countTokens();
      if (count <= 0) {
        if (_log.shouldLog(Log.DEBUG))         _log.debug("Ignoring whitespace");
        continue;
      }
      domain=tok.nextToken();
      if (domain.equals("PING")) {
        execPingMessage(tok);
        continue;
      }
 else       if (domain.equals("PONG")) {
        execPongMessage(tok);
        continue;
      }
 else       if (domain.equals("QUIT") || domain.equals("STOP") || domain.equals("EXIT")) {
        writeString(domain + " STATUS RESULT=OK MESSAGE=bye\n");
        break;
      }
      if (count <= 1) {
        if (writeString(domain + " STATUS RESULT=I2P_ERROR MESSAGE=\"command not specified\"\n"))         continue;
 else         break;
      }
      opcode=tok.nextToken();
      if (_log.shouldLog(Log.DEBUG)) {
        _log.debug("Parsing (domain: \"" + domain + "\"; opcode: \""+ opcode+ "\")");
      }
      props=SAMUtils.parseParams(tok);
      if (domain.equals("STREAM")) {
        canContinue=execStreamMessage(opcode,props);
      }
 else       if (domain.equals("SESSION")) {
        if (i2cpProps != null)         props.putAll(i2cpProps);
        canContinue=execSessionMessage(opcode,props);
      }
 else       if (domain.equals("DEST")) {
        canContinue=execDestMessage(opcode,props);
      }
 else       if (domain.equals("NAMING")) {
        canContinue=execNamingMessage(opcode,props);
      }
 else       if (domain.equals("DATAGRAM")) {
        canContinue=execDatagramMessage(opcode,props);
      }
 else       if (domain.equals("RAW")) {
        canContinue=execRawMessage(opcode,props);
      }
 else       if (domain.equals("AUTH")) {
        canContinue=execAuthMessage(opcode,props);
      }
 else {
        if (_log.shouldLog(Log.DEBUG))         _log.debug("Unrecognized message domain: \"" + domain + "\"");
        break;
      }
      if (!canContinue) {
        break;
      }
    }
  }
 catch (  IOException e) {
    if (_log.shouldLog(Log.DEBUG))     _log.debug("Caught IOException in handler",e);
  }
catch (  SAMException e) {
    _log.error("Unexpected exception for message [" + msg + ']',e);
  }
catch (  RuntimeException e) {
    _log.error("Unexpected exception for message [" + msg + ']',e);
  }
 finally {
    if (_log.shouldLog(Log.DEBUG))     _log.debug("Stopping handler");
    if (!this.stolenSocket) {
      try {
        closeClientSocket();
      }
 catch (      IOException e) {
        if (_log.shouldWarn())         _log.warn("Error closing socket",e);
      }
    }
    if (streamForwardingSocket) {
      if (this.getStreamSession() != null) {
        try {
          ((SAMv3StreamSession)streamSession).stopForwardingIncoming();
        }
 catch (        SAMException e) {
          if (_log.shouldWarn())           _log.warn("Error while stopping forwarding connections",e);
        }
catch (        InterruptedIOException e) {
          if (_log.shouldWarn())           _log.warn("Interrupted while stopping forwarding connections",e);
        }
      }
    }
    die();
  }
}
