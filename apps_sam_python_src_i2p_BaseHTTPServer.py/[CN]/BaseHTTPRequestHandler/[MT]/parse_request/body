def parse_request(self):
    'Parse a request (internal).\n    \n        The request should be stored in self.raw_requestline; the results\n        are in self.command, self.path, self.request_version and\n        self.headers.\n    \n        Return True for success, False for failure; on failure, an\n        error is sent back.\n    \n        '
    self.command = None
    self.request_version = version = 'HTTP/0.9'
    self.close_connection = 1
    requestline = self.raw_requestline
    if (requestline[(-2):] == '\r\n'):
        requestline = requestline[:(-2)]
    elif (requestline[(-1):] == '\n'):
        requestline = requestline[:(-1)]
    self.requestline = requestline
    words = requestline.split()
    if (len(words) == 3):
        [command, path, version] = words
        if (version[:5] != 'HTTP/'):
            self.send_error(400, ('Bad request version (%s)' % `version`))
            return False
        try:
            base_version_number = version.split('/', 1)[1]
            version_number = base_version_number.split('.')
            if (len(version_number) != 2):
                raise ValueError
            version_number = (int(version_number[0]), int(version_number[1]))
        except (ValueError, IndexError):
            self.send_error(400, ('Bad request version (%s)' % `version`))
            return False
        if ((version_number >= (1, 1)) and (self.protocol_version >= 'HTTP/1.1')):
            self.close_connection = 0
        if (version_number >= (2, 0)):
            self.send_error(505, ('Invalid HTTP Version (%s)' % base_version_number))
            return False
    elif (len(words) == 2):
        [command, path] = words
        self.close_connection = 1
        if (command != 'GET'):
            self.send_error(400, ('Bad HTTP/0.9 request type (%s)' % `command`))
            return False
    elif (not words):
        return False
    else:
        self.send_error(400, ('Bad request syntax (%s)' % `requestline`))
        return False
    (self.command, self.path, self.request_version) = (command, path, version)
    bytes = ''
    while 1:
        line = self.rfile.readline()
        bytes = (bytes + line)
        if ((line == '\r\n') or (line == '\n') or (line == '')):
            break
    hfile = cStringIO.StringIO(bytes)
    self.headers = self.MessageClass(hfile)
    conntype = self.headers.get('Connection', '')
    if (conntype.lower() == 'close'):
        self.close_connection = 1
    elif ((conntype.lower() == 'keep-alive') and (self.protocol_version >= 'HTTP/1.1')):
        self.close_connection = 0
    return True
