{
  if (_packet.getAckTime() > 0)   return;
  if (_resetSent || _resetReceived) {
    _packet.cancelled();
    return;
  }
  boolean resend=false;
  boolean isLowest=false;
synchronized (_outboundPackets) {
    if (_packet.getSequenceNum() == _highestAckedThrough + 1)     isLowest=true;
    if (_outboundPackets.containsKey(new Long(_packet.getSequenceNum())))     resend=true;
  }
  if ((resend) && (_packet.getAckTime() < 0)) {
    if (!isLowest) {
      if (_log.shouldLog(Log.WARN))       _log.warn("Delaying resend of " + _packet + " as there are "+ _activeResends+ " active resends already in play");
      SimpleTimer.getInstance().addEvent(ResendPacketEvent.this,1000);
      return;
    }
    _inputStream.updateAcks(_packet);
    _packet.setOptionalDelay(getOptions().getChoke());
    _packet.setOptionalMaxSize(getOptions().getMaxMessageSize());
    _packet.setResendDelay(getOptions().getResendDelay());
    _packet.setReceiveStreamId(_receiveStreamId);
    _packet.setSendStreamId(_sendStreamId);
    int newWindowSize=getOptions().getWindowSize();
    if (_ackSinceCongestion) {
      if (_packet.getSequenceNum() > _lastCongestionHighestUnacked) {
        congestionOccurred();
        _context.statManager().addRateData("stream.con.windowSizeAtCongestion",newWindowSize,_packet.getLifetime());
        newWindowSize/=2;
        if (newWindowSize <= 0)         newWindowSize=1;
        getOptions().setRTT(getOptions().getRTT() + 10 * 1000);
        getOptions().setWindowSize(newWindowSize);
        if (_log.shouldLog(Log.WARN))         _log.warn("Congestion resending packet " + _packet.getSequenceNum() + ": new windowSize "+ newWindowSize+ "/"+ getOptions().getWindowSize()+ ") for "+ Connection.this.toString());
        windowAdjusted();
      }
    }
    int numSends=_packet.getNumSends() + 1;
    if (numSends == 2) {
      _activeResends++;
    }
    int failTagsAt=_options.getMaxResends() - 2;
    if ((newWindowSize == 1) && (numSends == failTagsAt)) {
      if (_log.shouldLog(Log.WARN))       _log.warn("Optimistically failing tags at resend " + numSends);
      _context.sessionKeyManager().failTags(_remotePeer.getPublicKey());
    }
    if (numSends - 1 <= _options.getMaxResends()) {
      if (_log.shouldLog(Log.WARN))       _log.warn("Resend packet " + _packet + " time "+ numSends+ " activeResends: "+ _activeResends+ " (wsize "+ newWindowSize+ " lifetime "+ (_context.clock().now() - _packet.getCreatedOn())+ "ms)");
      _outboundQueue.enqueue(_packet);
    }
    _lastSendTime=_context.clock().now();
    if ((_packet.getAckTime() > 0) && (_packet.getNumSends() > 1)) {
      _activeResends--;
synchronized (_outboundPackets) {
        _outboundPackets.notifyAll();
      }
      return;
    }
    if (numSends - 1 > _options.getMaxResends()) {
      if (_log.shouldLog(Log.DEBUG))       _log.debug("Too many resends");
      _packet.cancelled();
      disconnect(false);
    }
 else {
      long rtt=_options.getRTT();
      if (rtt < MIN_RESEND_DELAY)       rtt=MIN_RESEND_DELAY;
      long timeout=rtt << (numSends - 1);
      if ((timeout > MAX_RESEND_DELAY) || (timeout <= 0))       timeout=MAX_RESEND_DELAY;
      if (_log.shouldLog(Log.DEBUG))       _log.debug("Scheduling resend in " + timeout + "ms for "+ _packet);
      SimpleTimer.getInstance().addEvent(ResendPacketEvent.this,timeout);
    }
  }
 else {
  }
}
