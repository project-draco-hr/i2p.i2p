{
  _context=ctx;
  _log=ctx.logManager().getLog(Connection.class);
  _receiver=new ConnectionDataReceiver(ctx,this);
  _inputStream=new MessageInputStream(ctx);
  _outputStream=new MessageOutputStream(ctx,_receiver);
  _chooser=chooser;
  _outboundPackets=new TreeMap();
  _outboundQueue=queue;
  _handler=handler;
  _options=(opts != null ? opts : new ConnectionOptions());
  _lastSendId=-1;
  _nextSendTime=-1;
  _ackedPackets=0;
  _createdOn=ctx.clock().now();
  _closeSentOn=-1;
  _closeReceivedOn=-1;
  _unackedPacketsReceived=0;
  _congestionWindowEnd=0;
  _highestAckedThrough=-1;
  _lastCongestionSeenAt=MAX_WINDOW_SIZE;
  _connectionManager=manager;
  _resetReceived=false;
  _connected=true;
  _disconnectScheduled=false;
  _lastReceivedOn=-1;
  _activityTimer=new ActivityTimer();
  _ackSinceCongestion=true;
  _connectLock=new Object();
  _activeResends=0;
  _context.statManager().createRateStat("stream.con.windowSizeAtCongestion","How large was our send window when we send a dup?","Stream",new long[]{60 * 1000,10 * 60 * 1000,60 * 60 * 1000});
  _context.statManager().createRateStat("stream.chokeSizeBegin","How many messages were outstanding when we started to choke?","Stream",new long[]{60 * 1000,10 * 60 * 1000,60 * 60 * 1000});
  _context.statManager().createRateStat("stream.chokeSizeEnd","How many messages were outstanding when we stopped being choked?","Stream",new long[]{60 * 1000,10 * 60 * 1000,60 * 60 * 1000});
}
