{
  if (nacks == null) {
    _highestAckedThrough=ackThrough;
  }
 else {
    long lowest=-1;
    for (int i=0; i < nacks.length; i++) {
      if ((lowest < 0) || (nacks[i] < lowest))       lowest=nacks[i];
    }
    if (lowest - 1 > _highestAckedThrough)     _highestAckedThrough=lowest - 1;
  }
  List acked=null;
synchronized (_outboundPackets) {
    for (Iterator iter=_outboundPackets.keySet().iterator(); iter.hasNext(); ) {
      Long id=(Long)iter.next();
      if (id.longValue() <= ackThrough) {
        boolean nacked=false;
        if (nacks != null) {
          for (int i=0; i < nacks.length; i++) {
            if (nacks[i] == id.longValue()) {
              nacked=true;
              break;
            }
          }
        }
        if (!nacked) {
          if (acked == null)           acked=new ArrayList(1);
          PacketLocal ackedPacket=(PacketLocal)_outboundPackets.get(id);
          ackedPacket.ackReceived();
          acked.add(ackedPacket);
        }
      }
 else {
        break;
      }
    }
    if (acked != null) {
      for (int i=0; i < acked.size(); i++) {
        PacketLocal p=(PacketLocal)acked.get(i);
        _outboundPackets.remove(new Long(p.getSequenceNum()));
        _ackedPackets++;
        if (p.getNumSends() > 1) {
          _activeResends--;
          if (_log.shouldLog(Log.INFO))           _log.info("Active resend of " + p + " successful, # active left: "+ _activeResends);
        }
      }
    }
    if ((_outboundPackets.size() <= 0) && (_activeResends != 0)) {
      if (_log.shouldLog(Log.WARN))       _log.warn("All outbound packets acked, clearing " + _activeResends);
      _activeResends=0;
    }
    _outboundPackets.notifyAll();
  }
  if ((acked != null) && (acked.size() > 0))   _ackSinceCongestion=true;
  return acked;
}
