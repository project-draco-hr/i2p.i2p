{
  if (ackThrough < _highestAckedThrough) {
  }
 else {
    if (nacks == null) {
      _highestAckedThrough=ackThrough;
    }
 else {
      long lowest=-1;
      for (int i=0; i < nacks.length; i++) {
        if ((lowest < 0) || (nacks[i] < lowest))         lowest=nacks[i];
      }
      if (lowest - 1 > _highestAckedThrough)       _highestAckedThrough=lowest - 1;
    }
  }
  List<PacketLocal> acked=null;
synchronized (_outboundPackets) {
    for (Iterator<Long> iter=_outboundPackets.keySet().iterator(); iter.hasNext(); ) {
      Long id=iter.next();
      if (id.longValue() <= ackThrough) {
        boolean nacked=false;
        if (nacks != null) {
          for (int i=0; i < nacks.length; i++) {
            if (nacks[i] == id.longValue()) {
              nacked=true;
              PacketLocal nackedPacket=_outboundPackets.get(id);
              nackedPacket.incrementNACKs();
              break;
            }
          }
        }
        if (!nacked) {
          if (acked == null)           acked=new ArrayList(1);
          PacketLocal ackedPacket=_outboundPackets.get(id);
          ackedPacket.ackReceived();
          acked.add(ackedPacket);
        }
      }
 else {
        break;
      }
    }
    if (acked != null) {
      for (int i=0; i < acked.size(); i++) {
        PacketLocal p=acked.get(i);
        _outboundPackets.remove(new Long(p.getSequenceNum()));
        _ackedPackets++;
        if (p.getNumSends() > 1) {
          _activeResends--;
          if (_log.shouldLog(Log.DEBUG))           _log.debug("Active resend of " + p + " successful, # active left: "+ _activeResends);
        }
      }
    }
    if ((_outboundPackets.isEmpty()) && (_activeResends != 0)) {
      if (_log.shouldLog(Log.INFO))       _log.info("All outbound packets acked, clearing " + _activeResends);
      _activeResends=0;
    }
    _outboundPackets.notifyAll();
  }
  if ((acked != null) && (acked.size() > 0))   _ackSinceCongestion=true;
  return acked;
}
