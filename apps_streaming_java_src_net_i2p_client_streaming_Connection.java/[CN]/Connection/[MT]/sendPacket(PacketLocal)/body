{
  if (packet == null)   return;
  setNextSendTime(-1);
  _unackedPacketsReceived=0;
  if (_options.getRequireFullySigned()) {
    packet.setFlag(Packet.FLAG_SIGNATURE_INCLUDED);
    packet.setFlag(Packet.FLAG_SIGNATURE_REQUESTED);
  }
  boolean ackOnly=false;
  if ((packet.getSequenceNum() == 0) && (!packet.isFlagSet(Packet.FLAG_SYNCHRONIZE))) {
    ackOnly=true;
    if (_log.shouldLog(Log.DEBUG))     _log.debug("No resend for " + packet);
  }
 else {
    int remaining=0;
synchronized (_outboundPackets) {
      _outboundPackets.put(new Long(packet.getSequenceNum()),packet);
      remaining=_options.getWindowSize() - _outboundPackets.size();
      _outboundPackets.notifyAll();
    }
    if (remaining < 0)     remaining=0;
    if (packet.isFlagSet(Packet.FLAG_CLOSE) || (remaining < 2)) {
      packet.setOptionalDelay(0);
    }
 else {
      int delay=_options.getRTT() / 2;
      packet.setOptionalDelay(delay);
      _log.debug("Requesting ack delay of " + delay + "ms for packet "+ packet);
    }
    packet.setFlag(Packet.FLAG_DELAY_REQUESTED);
    long timeout=(_options.getRTT() < MIN_RESEND_DELAY ? MIN_RESEND_DELAY : _options.getRTT());
    if (timeout > MAX_RESEND_DELAY)     timeout=MAX_RESEND_DELAY;
    if (_log.shouldLog(Log.DEBUG))     _log.debug("Resend in " + timeout + " for "+ packet,new Exception("Sent by"));
    SimpleTimer.getInstance().addEvent(new ResendPacketEvent(packet),timeout);
  }
  _lastSendTime=_context.clock().now();
  _outboundQueue.enqueue(packet);
  resetActivityTimer();
  if (ackOnly) {
    if ((packet.getTagsSent() != null) && (packet.getTagsSent().size() > 0)) {
      _log.warn("Sending a ping since the ACK we just sent has " + packet.getTagsSent().size() + " tags");
      _connectionManager.ping(_remotePeer,_options.getRTT() * 2,false,packet.getKeyUsed(),packet.getTagsSent(),new PingNotifier());
    }
  }
}
