{
  if (packet == null)   return;
  setNextSendTime(-1);
  _unackedPacketsReceived=0;
  if (_options.getRequireFullySigned()) {
    packet.setFlag(Packet.FLAG_SIGNATURE_INCLUDED);
    packet.setFlag(Packet.FLAG_SIGNATURE_REQUESTED);
  }
  boolean ackOnly=false;
  if ((packet.getSequenceNum() == 0) && (!packet.isFlagSet(Packet.FLAG_SYNCHRONIZE))) {
    ackOnly=true;
    if (_log.shouldLog(Log.DEBUG))     _log.debug("No resend for " + packet);
  }
 else {
    int remaining=0;
synchronized (_outboundPackets) {
      _outboundPackets.put(new Long(packet.getSequenceNum()),packet);
      remaining=_options.getWindowSize() - _outboundPackets.size();
      _outboundPackets.notifyAll();
    }
    if (remaining < 0)     remaining=0;
    if (packet.isFlagSet(Packet.FLAG_CLOSE) || (remaining < 2)) {
      packet.setOptionalDelay(0);
      packet.setFlag(Packet.FLAG_DELAY_REQUESTED);
    }
 else {
      int delay=_options.getRTO() / 2;
      packet.setOptionalDelay(delay);
      if (delay > 0)       packet.setFlag(Packet.FLAG_DELAY_REQUESTED);
      if (_log.shouldLog(Log.DEBUG))       _log.debug("Requesting ack delay of " + delay + "ms for packet "+ packet);
    }
    packet.setFlag(Packet.FLAG_DELAY_REQUESTED);
    long timeout=_options.getRTO();
    if (timeout > MAX_RESEND_DELAY)     timeout=MAX_RESEND_DELAY;
    if (_log.shouldLog(Log.DEBUG))     _log.debug("Resend in " + timeout + " for "+ packet,new Exception("Sent by"));
    RetransmissionTimer.getInstance().addEvent(new ResendPacketEvent(packet,timeout + _context.clock().now()),timeout);
  }
  _context.statManager().getStatLog().addData(Packet.toId(_sendStreamId),"stream.rtt",_options.getRTT(),_options.getWindowSize());
  _lastSendTime=_context.clock().now();
  _outboundQueue.enqueue(packet);
  resetActivityTimer();
}
