{
  Connection con=null;
  long receiveId=_context.random().nextLong(Packet.MAX_STREAM_ID - 1) + 1;
  long expiration=_context.clock().now() + opts.getConnectTimeout();
  if (opts.getConnectTimeout() <= 0)   expiration=_context.clock().now() + DEFAULT_STREAM_DELAY_MAX;
  _numWaiting++;
  while (true) {
    long remaining=expiration - _context.clock().now();
    if (remaining <= 0) {
      _log.logAlways(Log.WARN,"Refusing to connect since we have exceeded our max of " + _maxConcurrentStreams + " connections");
      _numWaiting--;
      return null;
    }
    if (locked_tooManyStreams()) {
      if (_numWaiting > _maxConcurrentStreams) {
        _log.logAlways(Log.WARN,"Refusing connection since we have exceeded our max of " + _maxConcurrentStreams + " and there are "+ _numWaiting+ " waiting already");
        _numWaiting--;
        return null;
      }
      try {
        Thread.sleep(remaining / 4);
      }
 catch (      InterruptedException ie) {
      }
    }
 else {
      con=new Connection(_context,this,_schedulerChooser,_outboundQueue,_conPacketHandler,opts);
      con.setRemotePeer(peer);
      while (_connectionByInboundId.containsKey(Long.valueOf(receiveId))) {
        receiveId=_context.random().nextLong(Packet.MAX_STREAM_ID - 1) + 1;
      }
      _connectionByInboundId.put(Long.valueOf(receiveId),con);
      break;
    }
  }
  con.setReceiveStreamId(receiveId);
  con.eventOccurred();
  if (_log.shouldLog(Log.DEBUG))   _log.debug("Connect() conDelay = " + opts.getConnectDelay());
  if (opts.getConnectDelay() <= 0) {
    con.waitForConnect();
  }
  if (_numWaiting > 0)   _numWaiting--;
  _context.statManager().addRateData("stream.connectionCreated",1,0);
  return con;
}
