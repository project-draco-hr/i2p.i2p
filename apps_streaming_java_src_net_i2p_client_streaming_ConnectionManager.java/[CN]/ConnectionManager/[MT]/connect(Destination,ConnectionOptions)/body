{
  Connection con=null;
  long receiveId=_context.random().nextLong(Packet.MAX_STREAM_ID - 1) + 1;
  long expiration=_context.clock().now() + opts.getConnectTimeout();
  if (opts.getConnectTimeout() <= 0)   expiration=_context.clock().now() + DEFAULT_STREAM_DELAY_MAX;
  _numWaiting++;
  while (true) {
    long remaining=expiration - _context.clock().now();
    if (remaining <= 0) {
      if (_log.shouldLog(Log.WARN))       _log.warn("Refusing to connect since we have exceeded our max of " + _maxConcurrentStreams + " connections");
      _numWaiting--;
      return null;
    }
    boolean reject=false;
synchronized (_connectionLock) {
      if (locked_tooManyStreams()) {
        if (_numWaiting > _maxConcurrentStreams) {
          if (_log.shouldLog(Log.WARN))           _log.warn("Refusing connection since we have exceeded our max of " + _maxConcurrentStreams + " and there are "+ _numWaiting+ " waiting already");
          _numWaiting--;
          return null;
        }
        try {
          _connectionLock.wait(remaining);
        }
 catch (        InterruptedException ie) {
        }
      }
 else {
        con=new Connection(_context,this,_schedulerChooser,_outboundQueue,_conPacketHandler,opts);
        con.setRemotePeer(peer);
        while (_connectionByInboundId.containsKey(new Long(receiveId))) {
          receiveId=_context.random().nextLong(Packet.MAX_STREAM_ID - 1) + 1;
        }
        _connectionByInboundId.put(new Long(receiveId),con);
        break;
      }
    }
  }
  con.setReceiveStreamId(receiveId);
  con.eventOccurred();
  _log.debug("Connect() conDelay = " + opts.getConnectDelay());
  if (opts.getConnectDelay() <= 0) {
    con.waitForConnect();
  }
  if (_numWaiting > 0)   _numWaiting--;
  _context.statManager().addRateData("stream.connectionCreated",1,0);
  return con;
}
