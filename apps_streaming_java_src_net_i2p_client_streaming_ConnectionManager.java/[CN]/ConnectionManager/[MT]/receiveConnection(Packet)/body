{
  Connection con=new Connection(_context,this,_schedulerChooser,_outboundQueue,_conPacketHandler);
  byte receiveId[]=new byte[4];
  _context.random().nextBytes(receiveId);
  boolean reject=false;
synchronized (_connectionLock) {
    if (locked_tooManyStreams()) {
      reject=true;
    }
 else {
      while (true) {
        Connection oldCon=(Connection)_connectionByInboundId.put(new ByteArray(receiveId),con);
        if (oldCon == null) {
          break;
        }
 else {
          _connectionByInboundId.put(new ByteArray(receiveId),oldCon);
          _context.random().nextBytes(receiveId);
        }
      }
    }
  }
  if (reject) {
    if (_log.shouldLog(Log.WARN))     _log.warn("Refusing connection since we have exceeded our max of " + _maxConcurrentStreams + " connections");
    PacketLocal reply=new PacketLocal(_context,synPacket.getOptionalFrom());
    reply.setFlag(Packet.FLAG_RESET);
    reply.setFlag(Packet.FLAG_SIGNATURE_INCLUDED);
    reply.setAckThrough(synPacket.getSequenceNum());
    reply.setSendStreamId(synPacket.getReceiveStreamId());
    reply.setReceiveStreamId(null);
    reply.setOptionalFrom(_session.getMyDestination());
    _outboundQueue.enqueue(reply);
    return null;
  }
  con.setReceiveStreamId(receiveId);
  try {
    con.getPacketHandler().receivePacket(synPacket,con);
  }
 catch (  I2PException ie) {
synchronized (_connectionLock) {
      _connectionByInboundId.remove(new ByteArray(receiveId));
    }
    return null;
  }
  return con;
}
