{
  Connection con=new Connection(_context,this,_schedulerChooser,_outboundQueue,_conPacketHandler,new ConnectionOptions(_defaultOptions));
  byte receiveId[]=new byte[4];
  _context.random().nextBytes(receiveId);
  boolean reject=false;
  int active=0;
  int total=0;
synchronized (_connectionLock) {
    total=_connectionByInboundId.size();
    for (Iterator iter=_connectionByInboundId.values().iterator(); iter.hasNext(); ) {
      if (((Connection)iter.next()).getIsConnected())       active++;
    }
    if (locked_tooManyStreams()) {
      reject=true;
    }
 else {
      while (true) {
        ByteArray ba=new ByteArray(receiveId);
        Connection oldCon=(Connection)_connectionByInboundId.put(ba,con);
        if (oldCon == null) {
          break;
        }
 else {
          _connectionByInboundId.put(ba,oldCon);
          receiveId=new byte[4];
          _context.random().nextBytes(receiveId);
        }
      }
    }
  }
  _context.statManager().addRateData("stream.receiveActive",active,total);
  if (reject) {
    if (_log.shouldLog(Log.WARN))     _log.warn("Refusing connection since we have exceeded our max of " + _maxConcurrentStreams + " connections");
    PacketLocal reply=new PacketLocal(_context,synPacket.getOptionalFrom());
    reply.setFlag(Packet.FLAG_RESET);
    reply.setFlag(Packet.FLAG_SIGNATURE_INCLUDED);
    reply.setAckThrough(synPacket.getSequenceNum());
    reply.setSendStreamId(synPacket.getReceiveStreamId());
    reply.setReceiveStreamId(null);
    reply.setOptionalFrom(_session.getMyDestination());
    _outboundQueue.enqueue(reply);
    return null;
  }
  con.setReceiveStreamId(receiveId);
  try {
    con.getPacketHandler().receivePacket(synPacket,con);
  }
 catch (  I2PException ie) {
synchronized (_connectionLock) {
      _connectionByInboundId.remove(new ByteArray(receiveId));
    }
    return null;
  }
  _context.statManager().addRateData("stream.connectionReceived",1,0);
  return con;
}
