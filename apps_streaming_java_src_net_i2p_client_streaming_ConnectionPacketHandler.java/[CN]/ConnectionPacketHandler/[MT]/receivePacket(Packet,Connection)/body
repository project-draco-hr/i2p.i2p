{
  boolean ok=verifyPacket(packet,con);
  if (!ok)   return;
  con.packetReceived();
  if (con.getInputStream().getTotalQueuedSize() > con.getOptions().getInboundBufferSize()) {
    if (_log.shouldLog(Log.WARN))     _log.warn("Inbound buffer exceeded on connection " + con + ": dropping "+ packet);
    con.getOptions().setChoke(5 * 1000);
    return;
  }
  con.getOptions().setChoke(0);
  boolean isNew=con.getInputStream().messageReceived(packet.getSequenceNum(),packet.getPayload());
  if (packet.isFlagSet(Packet.FLAG_CLOSE) && packet.isFlagSet(Packet.FLAG_SIGNATURE_INCLUDED))   con.closeReceived();
  if (isNew) {
    con.incrementUnackedPacketsReceived();
    if (packet.isFlagSet(Packet.FLAG_DELAY_REQUESTED) && (packet.getOptionalDelay() <= 0)) {
      if (_log.shouldLog(Log.DEBUG))       _log.debug("Scheduling immediate ack for " + packet);
      con.setNextSendTime(_context.clock().now() + con.getOptions().getSendAckDelay());
    }
 else {
      int delay=con.getOptions().getSendAckDelay();
      if (packet.isFlagSet(Packet.FLAG_DELAY_REQUESTED))       delay+=packet.getOptionalDelay();
      con.setNextSendTime(delay + _context.clock().now());
      if (_log.shouldLog(Log.DEBUG))       _log.debug("Scheduling ack in " + delay + "ms for received packet "+ packet);
    }
  }
 else {
    if ((packet.getSequenceNum() > 0) || (packet.getPayloadSize() > 0)) {
      if (_log.shouldLog(Log.WARN))       _log.warn("congestion.. dup " + packet);
      SimpleTimer.getInstance().addEvent(new AckDup(con),con.getOptions().getSendAckDelay());
      con.setNextSendTime(_context.clock().now() + con.getOptions().getSendAckDelay());
    }
 else {
      if (packet.isFlagSet(Packet.FLAG_SYNCHRONIZE)) {
        con.setNextSendTime(_context.clock().now() + con.getOptions().getSendAckDelay());
      }
 else {
        if (_log.shouldLog(Log.DEBUG))         _log.debug("ACK only packet received: " + packet);
      }
    }
  }
  int numResends=0;
  List acked=con.ackPackets(packet.getAckThrough(),packet.getNacks());
  if ((acked != null) && (acked.size() > 0)) {
    if (_log.shouldLog(Log.DEBUG))     _log.debug(acked.size() + " of our packets acked with " + packet);
    int highestRTT=-1;
    for (int i=0; i < acked.size(); i++) {
      PacketLocal p=(PacketLocal)acked.get(i);
      if (p.getAckTime() > highestRTT) {
        highestRTT=p.getAckTime();
      }
      if (p.getNumSends() > 1)       numResends++;
      if ((p.getKeyUsed() != null) && (p.getTagsSent() != null) && (p.getTagsSent().size() > 0)) {
        _context.sessionKeyManager().tagsDelivered(p.getTo().getPublicKey(),p.getKeyUsed(),p.getTagsSent());
      }
      if (_log.shouldLog(Log.DEBUG))       _log.debug("Packet acked after " + p.getAckTime() + "ms: "+ p);
    }
    if (highestRTT > 0) {
      con.getOptions().updateRTT(highestRTT);
    }
  }
  boolean fastAck=adjustWindow(con,isNew,packet.getSequenceNum(),numResends,(acked != null ? acked.size() : 0));
  con.eventOccurred();
  if (fastAck) {
    if (con.getLastSendTime() + con.getOptions().getRTT() < _context.clock().now()) {
      if (_log.shouldLog(Log.DEBUG))       _log.debug("Fast ack for dup " + packet);
      con.ackImmediately();
    }
  }
}
