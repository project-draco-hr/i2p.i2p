{
  boolean ok=verifyPacket(packet,con);
  if (!ok) {
    if ((!packet.isFlagSet(Packet.FLAG_RESET)) && (_log.shouldLog(Log.ERROR)))     _log.error("Packet does NOT verify: " + packet + " on "+ con);
    packet.releasePayload();
    return;
  }
  if (con.getHardDisconnected()) {
    if ((packet.getSequenceNum() > 0) || (packet.getPayloadSize() > 0) || (packet.isFlagSet(Packet.FLAG_SYNCHRONIZE))|| (packet.isFlagSet(Packet.FLAG_CLOSE))) {
      if (_log.shouldLog(Log.WARN))       _log.warn("Received a data packet after hard disconnect: " + packet + " on "+ con);
      con.sendReset();
    }
 else {
      if (_log.shouldLog(Log.WARN))       _log.warn("Received a packet after hard disconnect, ignoring: " + packet + " on "+ con);
    }
    packet.releasePayload();
    return;
  }
  if (packet.isFlagSet(Packet.FLAG_MAX_PACKET_SIZE_INCLUDED)) {
    if (packet.getOptionalMaxSize() < con.getOptions().getMaxMessageSize()) {
      if (_log.shouldLog(Log.INFO))       _log.info("Reducing our max message size to " + packet.getOptionalMaxSize() + " from "+ con.getOptions().getMaxMessageSize());
      con.getOptions().setMaxMessageSize(packet.getOptionalMaxSize());
      con.getOutputStream().setBufferSize(packet.getOptionalMaxSize());
    }
  }
  con.packetReceived();
  boolean choke=false;
  if (packet.isFlagSet(Packet.FLAG_DELAY_REQUESTED)) {
    if (packet.getOptionalDelay() > 60000) {
      choke=true;
      con.getOptions().setRTT(con.getOptions().getRTT() + 10 * 1000);
    }
  }
  long ready=con.getInputStream().getHighestReadyBockId();
  int available=con.getOptions().getInboundBufferSize() - con.getInputStream().getTotalReadySize();
  int allowedBlocks=available / con.getOptions().getMaxMessageSize();
  if ((packet.getPayloadSize() > 0) && (packet.getSequenceNum() > ready + allowedBlocks)) {
    if (_log.shouldLog(Log.WARN))     _log.warn("Inbound buffer exceeded on connection " + con + " ("+ ready+ "/"+ (ready + allowedBlocks)+ "/"+ available+ ": dropping "+ packet);
    ack(con,packet.getAckThrough(),packet.getNacks(),null,false,choke);
    con.getOptions().setChoke(61 * 1000);
    packet.releasePayload();
    con.ackImmediately();
    return;
  }
  con.getOptions().setChoke(0);
  _context.statManager().addRateData("stream.con.receiveMessageSize",packet.getPayloadSize(),0);
  boolean isNew=false;
  boolean allowAck=true;
  if ((!packet.isFlagSet(Packet.FLAG_SYNCHRONIZE)) && ((packet.getSendStreamId() <= 0) || (packet.getReceiveStreamId() <= 0)))   allowAck=false;
  if (allowAck) {
    isNew=con.getInputStream().messageReceived(packet.getSequenceNum(),packet.getPayload());
  }
 else {
    con.getInputStream().notifyActivity();
    isNew=false;
  }
  if ((packet.getSequenceNum() == 0) && (packet.getPayloadSize() > 0)) {
    if (_log.shouldLog(Log.DEBUG))     _log.debug("seq=0 && size=" + packet.getPayloadSize() + ": isNew? "+ isNew+ " packet: "+ packet+ " con: "+ con);
  }
  if (packet.isFlagSet(Packet.FLAG_CLOSE) && packet.isFlagSet(Packet.FLAG_SIGNATURE_INCLUDED))   con.closeReceived();
  boolean fastAck=false;
  boolean ackOnly=false;
  if (isNew) {
    con.incrementUnackedPacketsReceived();
    con.incrementBytesReceived(packet.getPayloadSize());
    if (packet.isFlagSet(Packet.FLAG_DELAY_REQUESTED) && (packet.getOptionalDelay() <= 0)) {
      if (_log.shouldLog(Log.DEBUG))       _log.debug("Scheduling immediate ack for " + packet);
      con.setNextSendTime(_context.clock().now() + con.getOptions().getSendAckDelay());
    }
 else {
      int delay=con.getOptions().getSendAckDelay();
      if (packet.isFlagSet(Packet.FLAG_DELAY_REQUESTED))       delay=packet.getOptionalDelay();
      con.setNextSendTime(delay + _context.clock().now());
      if (_log.shouldLog(Log.DEBUG))       _log.debug("Scheduling ack in " + delay + "ms for received packet "+ packet);
    }
  }
 else {
    if ((packet.getSequenceNum() > 0) || (packet.getPayloadSize() > 0) || (packet.isFlagSet(Packet.FLAG_SYNCHRONIZE))) {
      _context.statManager().addRateData("stream.con.receiveDuplicateSize",packet.getPayloadSize(),0);
      con.incrementDupMessagesReceived(1);
      if (_log.shouldLog(Log.WARN))       _log.warn("congestion.. dup " + packet);
      SimpleTimer.getInstance().addEvent(new AckDup(con),con.getOptions().getSendAckDelay());
    }
 else {
      if (packet.isFlagSet(Packet.FLAG_SYNCHRONIZE)) {
        con.setNextSendTime(_context.clock().now() + con.getOptions().getSendAckDelay());
      }
 else {
        if (_log.shouldLog(Log.DEBUG))         _log.debug("ACK only packet received: " + packet);
        ackOnly=true;
      }
    }
  }
  if (packet.isFlagSet(Packet.FLAG_SYNCHRONIZE) && (packet.getSendStreamId() <= 0)) {
  }
 else {
    fastAck=ack(con,packet.getAckThrough(),packet.getNacks(),packet,isNew,choke);
  }
  con.eventOccurred();
  if (fastAck) {
    if (!isNew) {
    }
 else {
      if (con.getLastSendTime() + 2000 < _context.clock().now()) {
        if (_log.shouldLog(Log.DEBUG))         _log.debug("Fast ack for dup " + packet);
        con.ackImmediately();
      }
    }
  }
  if (ackOnly || !isNew) {
    packet.releasePayload();
  }
}
