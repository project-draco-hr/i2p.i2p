{
synchronized (_dataLock) {
    if (_log.shouldLog(Log.DEBUG))     _log.debug("received " + messageId + " with "+ payload.length);
    if (messageId <= _highestReadyBlockId) {
      if (_log.shouldLog(Log.DEBUG))       _log.debug("ignoring dup message " + messageId);
      _dataLock.notifyAll();
      return false;
    }
    if (messageId > _highestBlockId)     _highestBlockId=messageId;
    if (_highestReadyBlockId + 1 == messageId) {
      if (!_locallyClosed && payload.length > 0) {
        if (_log.shouldLog(Log.DEBUG))         _log.debug("accepting bytes as ready: " + payload.length);
        _readyDataBlocks.add(new ByteArray(payload));
      }
      _highestReadyBlockId=messageId;
      long cur=_highestReadyBlockId + 1;
      while (_notYetReadyBlocks.containsKey(new Long(cur))) {
        ByteArray ba=(ByteArray)_notYetReadyBlocks.remove(new Long(cur));
        if ((ba != null) && (ba.getData() != null) && (ba.getData().length > 0)) {
          _readyDataBlocks.add(ba);
        }
        if (_log.shouldLog(Log.DEBUG))         _log.debug("making ready the block " + cur);
        cur++;
        _highestReadyBlockId++;
      }
      _dataLock.notifyAll();
    }
 else {
      if (_log.shouldLog(Log.DEBUG))       _log.debug("message is out of order: " + messageId);
      if (_locallyClosed)       _notYetReadyBlocks.put(new Long(messageId),new ByteArray(null));
 else       _notYetReadyBlocks.put(new Long(messageId),new ByteArray(payload));
      _dataLock.notifyAll();
    }
  }
  return true;
}
