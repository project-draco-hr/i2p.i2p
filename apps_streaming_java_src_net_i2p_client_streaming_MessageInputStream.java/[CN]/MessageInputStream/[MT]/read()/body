{
  if (_locallyClosed)   throw new IOException("Already locally closed");
  throwAnyError();
  long expiration=-1;
  if (_readTimeout > 0)   expiration=_readTimeout + System.currentTimeMillis();
synchronized (_dataLock) {
    while (_readyDataBlocks.size() <= 0) {
      if ((_notYetReadyBlocks.size() <= 0) && (_closeReceived)) {
        if (_log.shouldLog(Log.DEBUG))         _log.debug("read() got EOF: " + toString());
        return -1;
      }
 else {
        if (_readTimeout < 0) {
          if (_log.shouldLog(Log.DEBUG))           _log.debug("read() with no timeout: " + toString());
          try {
            _dataLock.wait();
          }
 catch (          InterruptedException ie) {
          }
          if (_log.shouldLog(Log.DEBUG))           _log.debug("read() with no timeout complete: " + toString());
          throwAnyError();
        }
 else         if (_readTimeout > 0) {
          if (_log.shouldLog(Log.DEBUG))           _log.debug("read() with timeout: " + _readTimeout + ": "+ toString());
          try {
            _dataLock.wait(_readTimeout);
          }
 catch (          InterruptedException ie) {
          }
          if (_log.shouldLog(Log.DEBUG))           _log.debug("read() with timeout complete: " + _readTimeout + ": "+ toString());
          throwAnyError();
        }
 else {
          if (_log.shouldLog(Log.DEBUG))           _log.debug("read() with nonblocking setup: " + toString());
        }
        if (_readyDataBlocks.size() <= 0) {
          if ((_readTimeout > 0) && (expiration > System.currentTimeMillis()))           throw new InterruptedIOException("Timeout reading (timeout=" + _readTimeout + ")");
        }
      }
    }
    ByteArray cur=(ByteArray)_readyDataBlocks.get(0);
    byte rv=cur.getData()[_readyDataBlockIndex];
    _readyDataBlockIndex++;
    if (cur.getData().length <= _readyDataBlockIndex) {
      _readyDataBlockIndex=0;
      _readyDataBlocks.remove(0);
    }
    return (rv < 0 ? rv + 256 : rv);
  }
}
