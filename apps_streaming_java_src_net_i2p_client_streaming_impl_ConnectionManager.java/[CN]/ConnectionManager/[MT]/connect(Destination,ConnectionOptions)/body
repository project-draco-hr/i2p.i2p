{
  Connection con=null;
  long receiveId=_context.random().nextLong(Packet.MAX_STREAM_ID - 1) + 1;
  long expiration=_context.clock().now() + opts.getConnectTimeout();
  if (opts.getConnectTimeout() <= 0)   expiration=_context.clock().now() + DEFAULT_STREAM_DELAY_MAX;
  _numWaiting.incrementAndGet();
  while (true) {
    long remaining=expiration - _context.clock().now();
    if (remaining <= 0) {
      _log.logAlways(Log.WARN,"Refusing to connect since we have exceeded our max of " + _defaultOptions.getMaxConns() + " connections");
      _numWaiting.decrementAndGet();
      return null;
    }
    if (locked_tooManyStreams()) {
      int max=_defaultOptions.getMaxConns();
      if (_numWaiting.get() > max) {
        _log.logAlways(Log.WARN,"Refusing connection since we have exceeded our max of " + max + " and there are "+ _numWaiting+ " waiting already");
        _numWaiting.decrementAndGet();
        return null;
      }
      try {
        Thread.sleep(remaining / 4);
      }
 catch (      InterruptedException ie) {
      }
    }
 else {
      con=new Connection(_context,this,_schedulerChooser,_timer,_outboundQueue,_conPacketHandler,opts,false);
      con.setRemotePeer(peer);
      while (_connectionByInboundId.containsKey(Long.valueOf(receiveId))) {
        receiveId=_context.random().nextLong(Packet.MAX_STREAM_ID - 1) + 1;
      }
      _connectionByInboundId.put(Long.valueOf(receiveId),con);
      break;
    }
  }
  con.setReceiveStreamId(receiveId);
  con.eventOccurred();
  if (_log.shouldLog(Log.DEBUG))   _log.debug("Connect() conDelay = " + opts.getConnectDelay());
  if (opts.getConnectDelay() <= 0) {
    con.waitForConnect();
  }
  for (; ; ) {
    int n=_numWaiting.get();
    if (n <= 0)     break;
    if (_numWaiting.compareAndSet(n,n - 1))     break;
  }
  _context.statManager().addRateData("stream.connectionCreated",1,0);
  return con;
}
