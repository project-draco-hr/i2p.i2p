{
  if (filteredAuthors.size() <= 0) {
    boolean allAuthorsIgnored=true;
    for (Iterator iter=node.getRecursiveAuthorIterator(); iter.hasNext(); ) {
      Hash author=(Hash)iter.next();
      if (!ignoredAuthors.contains(author)) {
        allAuthorsIgnored=false;
        break;
      }
    }
    if ((allAuthorsIgnored) && (ignoredAuthors.size() > 0))     return true;
  }
 else {
    boolean filteredAuthorMatches=false;
    for (Iterator iter=filteredAuthors.iterator(); iter.hasNext(); ) {
      Hash author=(Hash)iter.next();
      if (node.containsAuthor(author)) {
        filteredAuthorMatches=true;
        break;
      }
    }
    if (!filteredAuthorMatches)     return true;
  }
  if (requestedTags.size() > 0) {
    Collection nodeTags=node.getRecursiveTags();
    for (Iterator iter=requestedTags.iterator(); iter.hasNext(); )     if (nodeTags.contains(iter.next()))     return false;
    return true;
  }
 else {
    return false;
  }
}
