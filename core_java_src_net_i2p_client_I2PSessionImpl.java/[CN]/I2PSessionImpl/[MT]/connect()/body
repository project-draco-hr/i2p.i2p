{
  setOpening(true);
  _closed=false;
  _availabilityNotifier.stopNotifying();
  I2PThread notifier=new I2PThread(_availabilityNotifier);
  notifier.setName("Notifier " + _myDestination.calculateHash().toBase64().substring(0,4));
  notifier.setDaemon(true);
  notifier.start();
  if ((_options != null) && (I2PClient.PROP_RELIABILITY_GUARANTEED.equals(_options.getProperty(I2PClient.PROP_RELIABILITY,I2PClient.PROP_RELIABILITY_BEST_EFFORT)))) {
    if (_log.shouldLog(Log.ERROR))     _log.error("I2CP guaranteed delivery mode has been removed, using best effort.");
  }
  long startConnect=_context.clock().now();
  try {
    if (_log.shouldLog(Log.DEBUG))     _log.debug(getPrefix() + "connect begin to " + _hostname+ ":"+ _portNum);
    _socket=new Socket(_hostname,_portNum);
    _out=_socket.getOutputStream();
synchronized (_out) {
      _out.write(I2PClient.PROTOCOL_BYTE);
    }
    InputStream in=_socket.getInputStream();
    _reader=new I2CPMessageReader(in,this);
    if (_log.shouldLog(Log.DEBUG))     _log.debug(getPrefix() + "before startReading");
    _reader.startReading();
    if (_log.shouldLog(Log.DEBUG))     _log.debug(getPrefix() + "Before getDate");
    sendMessage(new GetDateMessage());
    if (_log.shouldLog(Log.DEBUG))     _log.debug(getPrefix() + "After getDate / begin waiting for a response");
    int waitcount=0;
    while (!_dateReceived) {
      if (waitcount++ > 30)       throw new IOException("no date handshake");
      try {
synchronized (_dateReceivedLock) {
          _dateReceivedLock.wait(1000);
        }
      }
 catch (      InterruptedException ie) {
      }
    }
    if (_log.shouldLog(Log.DEBUG))     _log.debug(getPrefix() + "After received a SetDate response");
    if (_log.shouldLog(Log.DEBUG))     _log.debug(getPrefix() + "Before producer.connect()");
    _producer.connect(this);
    if (_log.shouldLog(Log.DEBUG))     _log.debug(getPrefix() + "After  producer.connect()");
    waitcount=0;
    while (_leaseSet == null) {
      if (waitcount++ > 5 * 60)       throw new IOException("no leaseset");
synchronized (_leaseSetWait) {
        try {
          _leaseSetWait.wait(1000);
        }
 catch (        InterruptedException ie) {
        }
      }
    }
    long connected=_context.clock().now();
    if (_log.shouldLog(Log.INFO))     _log.info(getPrefix() + "Lease set created with inbound tunnels after " + (connected - startConnect)+ "ms - ready to participate in the network!");
    startIdleMonitor();
    setOpening(false);
  }
 catch (  UnknownHostException uhe) {
    _closed=true;
    setOpening(false);
    throw new I2PSessionException(getPrefix() + "Invalid session configuration",uhe);
  }
catch (  IOException ioe) {
    _closed=true;
    setOpening(false);
    throw new I2PSessionException(getPrefix() + "Problem connecting to " + _hostname+ " on port "+ _portNum,ioe);
  }
}
