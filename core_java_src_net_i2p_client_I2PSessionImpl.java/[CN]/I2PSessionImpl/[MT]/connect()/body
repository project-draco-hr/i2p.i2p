{
  setOpening(true);
  _closed=false;
  _availabilityNotifier.stopNotifying();
  if ((_options != null) && (I2PClient.PROP_RELIABILITY_GUARANTEED.equals(_options.getProperty(I2PClient.PROP_RELIABILITY,I2PClient.PROP_RELIABILITY_BEST_EFFORT)))) {
    if (_log.shouldLog(Log.ERROR))     _log.error("I2CP guaranteed delivery mode has been removed, using best effort.");
  }
  long startConnect=_context.clock().now();
  try {
    if (_context.isRouterContext()) {
      InternalClientManager mgr=_context.internalClientManager();
      if (mgr == null)       throw new I2PSessionException("Router is not ready for connections");
      _queue=mgr.connect();
      _reader=new QueuedI2CPMessageReader(_queue,this);
    }
 else {
      _socket=new Socket(_hostname,_portNum);
      _out=_socket.getOutputStream();
synchronized (_out) {
        _out.write(I2PClient.PROTOCOL_BYTE);
        _out.flush();
      }
      _writer=new ClientWriterRunner(_out,this);
      InputStream in=_socket.getInputStream();
      _reader=new I2CPMessageReader(in,this);
    }
    Thread notifier=new I2PAppThread(_availabilityNotifier,"ClientNotifier " + getPrefix(),true);
    notifier.start();
    if (_log.shouldLog(Log.DEBUG))     _log.debug(getPrefix() + "before startReading");
    _reader.startReading();
    if (_log.shouldLog(Log.DEBUG))     _log.debug(getPrefix() + "Before getDate");
    sendMessage(new GetDateMessage());
    if (_log.shouldLog(Log.DEBUG))     _log.debug(getPrefix() + "After getDate / begin waiting for a response");
    int waitcount=0;
    while (!_dateReceived) {
      if (waitcount++ > 30) {
        closeSocket();
        throw new IOException("No handshake received from the router");
      }
      try {
synchronized (_dateReceivedLock) {
          _dateReceivedLock.wait(1000);
        }
      }
 catch (      InterruptedException ie) {
      }
    }
    if (_log.shouldLog(Log.DEBUG))     _log.debug(getPrefix() + "After received a SetDate response");
    if (_log.shouldLog(Log.DEBUG))     _log.debug(getPrefix() + "Before producer.connect()");
    _producer.connect(this);
    if (_log.shouldLog(Log.DEBUG))     _log.debug(getPrefix() + "After  producer.connect()");
    waitcount=0;
    while (_leaseSet == null) {
      if (waitcount++ > 5 * 60) {
        try {
          _producer.disconnect(this);
        }
 catch (        I2PSessionException ipe) {
        }
        closeSocket();
        throw new IOException("No tunnels built after waiting 5 minutes... are there network problems?");
      }
synchronized (_leaseSetWait) {
        try {
          _leaseSetWait.wait(1000);
        }
 catch (        InterruptedException ie) {
        }
      }
    }
    long connected=_context.clock().now();
    if (_log.shouldLog(Log.INFO))     _log.info(getPrefix() + "Lease set created with inbound tunnels after " + (connected - startConnect)+ "ms - ready to participate in the network!");
    startIdleMonitor();
    setOpening(false);
  }
 catch (  UnknownHostException uhe) {
    _closed=true;
    setOpening(false);
    throw new I2PSessionException(getPrefix() + "Cannot connect to the router on " + _hostname+ ':'+ _portNum,uhe);
  }
catch (  IOException ioe) {
    _closed=true;
    setOpening(false);
    throw new I2PSessionException(getPrefix() + "Cannot connect to the router on " + _hostname+ ':'+ _portNum,ioe);
  }
}
