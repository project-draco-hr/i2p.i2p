{
synchronized (_stateLock) {
    boolean wasOpening=false;
    boolean loop=true;
    while (loop) {
switch (_state) {
case CLOSED:
        if (wasOpening)         throw new I2PSessionException("connect by other thread failed");
      loop=false;
    break;
case OPENING:
  wasOpening=true;
try {
  _stateLock.wait(10 * 1000);
}
 catch (InterruptedException ie) {
  throw new I2PSessionException("Interrupted",ie);
}
break;
case CLOSING:
throw new I2PSessionException("close in progress");
case OPEN:
return;
}
}
changeState(State.OPENING);
}
_availabilityNotifier.stopNotifying();
if ((_options != null) && (I2PClient.PROP_RELIABILITY_GUARANTEED.equals(_options.getProperty(I2PClient.PROP_RELIABILITY,I2PClient.PROP_RELIABILITY_BEST_EFFORT)))) {
if (_log.shouldLog(Log.ERROR)) _log.error("I2CP guaranteed delivery mode has been removed, using best effort.");
}
boolean success=false;
long startConnect=_context.clock().now();
try {
synchronized (_stateLock) {
if (_context.isRouterContext()) {
InternalClientManager mgr=_context.internalClientManager();
if (mgr == null) throw new I2PSessionException("Router is not ready for connections");
_queue=mgr.connect();
_reader=new QueuedI2CPMessageReader(_queue,this);
}
 else {
if (Boolean.parseBoolean(_options.getProperty(PROP_ENABLE_SSL))) {
try {
I2PSSLSocketFactory fact=new I2PSSLSocketFactory(_context,false,"certificates/i2cp");
_socket=fact.createSocket(_hostname,_portNum);
}
 catch (GeneralSecurityException gse) {
IOException ioe=new IOException("SSL Fail");
ioe.initCause(gse);
throw ioe;
}
}
 else {
_socket=new Socket(_hostname,_portNum);
}
OutputStream out=_socket.getOutputStream();
out.write(I2PClient.PROTOCOL_BYTE);
out.flush();
_writer=new ClientWriterRunner(out,this);
InputStream in=new BufferedInputStream(_socket.getInputStream(),BUF_SIZE);
_reader=new I2CPMessageReader(in,this);
}
}
if (_log.shouldLog(Log.DEBUG)) _log.debug(getPrefix() + "before startReading");
_reader.startReading();
if (_log.shouldLog(Log.DEBUG)) _log.debug(getPrefix() + "Before getDate");
sendMessage(new GetDateMessage(CoreVersion.VERSION));
if (_log.shouldLog(Log.DEBUG)) _log.debug(getPrefix() + "After getDate / begin waiting for a response");
int waitcount=0;
while (!_dateReceived) {
if (waitcount++ > 30) {
throw new IOException("No handshake received from the router");
}
synchronized (_dateReceivedLock) {
_dateReceivedLock.wait(1000);
}
}
if (_log.shouldLog(Log.DEBUG)) _log.debug(getPrefix() + "After received a SetDate response");
if (_log.shouldLog(Log.DEBUG)) _log.debug(getPrefix() + "Before producer.connect()");
_producer.connect(this);
if (_log.shouldLog(Log.DEBUG)) _log.debug(getPrefix() + "After producer.connect()");
waitcount=0;
while (_leaseSet == null) {
if (waitcount++ > 5 * 60) {
throw new IOException("No tunnels built after waiting 5 minutes. Your network connection may be down, or there is severe network congestion.");
}
synchronized (_leaseSetWait) {
_leaseSetWait.wait(1000);
}
}
if (_log.shouldLog(Log.INFO)) {
long connected=_context.clock().now();
_log.info(getPrefix() + "Lease set created with inbound tunnels after " + (connected - startConnect)+ "ms - ready to participate in the network!");
}
Thread notifier=new I2PAppThread(_availabilityNotifier,"ClientNotifier " + getPrefix(),true);
notifier.start();
startIdleMonitor();
startVerifyUsage();
success=true;
}
 catch (InterruptedException ie) {
throw new I2PSessionException("Interrupted",ie);
}
catch (UnknownHostException uhe) {
throw new I2PSessionException(getPrefix() + "Cannot connect to the router on " + _hostname+ ':'+ _portNum,uhe);
}
catch (IOException ioe) {
throw new I2PSessionException(getPrefix() + "Cannot connect to the router on " + _hostname+ ':'+ _portNum,ioe);
}
 finally {
if (success) {
changeState(State.OPEN);
}
 else {
_availabilityNotifier.stopNotifying();
synchronized (_stateLock) {
changeState(State.CLOSING);
try {
_producer.disconnect(this);
}
 catch (I2PSessionException ipe) {
}
closeSocket();
}
}
}
}
