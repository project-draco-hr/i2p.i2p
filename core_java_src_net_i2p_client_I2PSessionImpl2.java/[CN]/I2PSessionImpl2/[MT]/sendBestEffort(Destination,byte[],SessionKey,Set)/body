{
  long begin=_context.clock().now();
  if (_log.shouldLog(Log.DEBUG))   _log.debug("begin sendBestEffort");
  SessionKey key=_context.sessionKeyManager().getCurrentKey(dest.getPublicKey());
  if (_log.shouldLog(Log.DEBUG))   _log.debug("key fetched");
  if (key == null)   key=_context.sessionKeyManager().createSession(dest.getPublicKey());
  SessionTag tag=_context.sessionKeyManager().consumeNextAvailableTag(dest.getPublicKey(),key);
  if (_log.shouldLog(Log.DEBUG))   _log.debug("tag consumed");
  Set sentTags=null;
  int oldTags=_context.sessionKeyManager().getAvailableTags(dest.getPublicKey(),key);
  long availTimeLeft=_context.sessionKeyManager().getAvailableTimeLeft(dest.getPublicKey(),key);
  if ((tagsSent == null) || (tagsSent.size() <= 0)) {
    if (oldTags < NUM_TAGS) {
      sentTags=createNewTags(NUM_TAGS);
      if (_log.shouldLog(Log.DEBUG))       _log.debug("** sendBestEffort only had " + oldTags + " with "+ availTimeLeft+ ", adding "+ NUM_TAGS+ ": "+ sentTags);
    }
 else     if (availTimeLeft < 2 * 60 * 1000) {
      sentTags=createNewTags(NUM_TAGS);
      if (_log.shouldLog(Log.DEBUG))       _log.debug(getPrefix() + "Tags expiring in " + availTimeLeft+ ", adding "+ NUM_TAGS+ " new ones: "+ sentTags);
    }
 else {
      if (_log.shouldLog(Log.DEBUG))       _log.debug("sendBestEffort old tags: " + oldTags + " available time left: "+ availTimeLeft);
    }
  }
 else {
    if (_log.shouldLog(Log.DEBUG))     _log.debug("sendBestEffort is sending " + tagsSent.size() + " with "+ availTimeLeft+ "ms left, "+ oldTags+ " tags known and "+ (tag == null ? "no tag" : " a valid tag"));
  }
  SessionKey newKey=null;
  if (false)   newKey=_context.keyGenerator().generateSessionKey();
  if ((tagsSent != null) && (tagsSent.size() > 0)) {
    if (sentTags == null)     sentTags=new HashSet();
    sentTags.addAll(tagsSent);
  }
  if (_log.shouldLog(Log.DEBUG))   _log.debug("before creating nonce");
  long nonce=_context.random().nextInt(Integer.MAX_VALUE);
  if (_log.shouldLog(Log.DEBUG))   _log.debug("before sync state");
  MessageState state=new MessageState(_context,nonce,getPrefix());
  state.setKey(key);
  state.setTags(sentTags);
  state.setNewKey(newKey);
  state.setTo(dest);
  if (_log.shouldLog(Log.DEBUG))   _log.debug(getPrefix() + "Setting key = " + key);
  if (keyUsed != null) {
    if (newKey != null)     keyUsed.setData(newKey.getData());
 else     keyUsed.setData(key.getData());
  }
  if (tagsSent != null) {
    if (sentTags != null) {
      tagsSent.addAll(sentTags);
    }
  }
  if (_log.shouldLog(Log.DEBUG))   _log.debug("before sync state");
  long beforeSendingSync=_context.clock().now();
  long inSendingSync=0;
synchronized (_sendingStates) {
    inSendingSync=_context.clock().now();
    _sendingStates.add(state);
  }
  long afterSendingSync=_context.clock().now();
  if (_log.shouldLog(Log.DEBUG))   _log.debug(getPrefix() + "Adding sending state " + state.getMessageId()+ " / "+ state.getNonce()+ " for best effort "+ " sync took "+ (inSendingSync - beforeSendingSync)+ " add took "+ (afterSendingSync - inSendingSync));
  _producer.sendMessage(this,dest,nonce,payload,tag,key,sentTags,newKey);
  boolean actuallyWait=false;
  long beforeWaitFor=_context.clock().now();
  if (actuallyWait)   state.waitFor(MessageStatusMessage.STATUS_SEND_ACCEPTED,_context.clock().now() + getTimeout());
  long afterWaitFor=_context.clock().now();
  long inRemovingSync=0;
synchronized (_sendingStates) {
    inRemovingSync=_context.clock().now();
    _sendingStates.remove(state);
  }
  long afterRemovingSync=_context.clock().now();
  boolean found=!actuallyWait || state.received(MessageStatusMessage.STATUS_SEND_ACCEPTED);
  if (_log.shouldLog(Log.DEBUG))   _log.debug(getPrefix() + "After waitFor sending state " + state.getMessageId()+ " / "+ state.getNonce()+ " found = "+ found);
  long timeToSend=afterRemovingSync - beforeSendingSync;
  if ((timeToSend > 10 * 1000) && (_log.shouldLog(Log.WARN))) {
    _log.warn("wtf, took " + timeToSend + "ms to send the message?!",new Exception("baz"));
  }
  if ((afterRemovingSync - begin > 500) && (_log.shouldLog(Log.WARN))) {
    _log.warn("Took " + (afterRemovingSync - begin) + "ms to sendBestEffort, "+ (afterSendingSync - begin)+ "ms to prepare, "+ (beforeWaitFor - afterSendingSync)+ "ms to send, "+ (afterRemovingSync - beforeWaitFor)+ "ms waiting for reply");
  }
  _context.statManager().addRateData("i2cp.sendBestEffortTotalTime",afterRemovingSync - begin,0);
  if (found) {
    if (_log.shouldLog(Log.INFO))     _log.info(getPrefix() + "Message sent after " + state.getElapsed()+ "ms with "+ payload.length+ " bytes");
  }
 else {
    if (_log.shouldLog(Log.INFO))     _log.info(getPrefix() + "Message send failed after " + state.getElapsed()+ "ms with "+ payload.length+ " bytes");
    if (_log.shouldLog(Log.ERROR))     _log.error(getPrefix() + "Never received *accepted* from the router!  dropping and reconnecting");
    disconnect();
    return false;
  }
  return found;
}
