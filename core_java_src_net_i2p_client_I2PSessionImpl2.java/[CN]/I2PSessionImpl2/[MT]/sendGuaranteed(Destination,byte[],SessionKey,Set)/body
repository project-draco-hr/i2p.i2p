{
  SessionKey key=_context.sessionKeyManager().getCurrentKey(dest.getPublicKey());
  if (key == null)   key=_context.sessionKeyManager().createSession(dest.getPublicKey());
  SessionTag tag=_context.sessionKeyManager().consumeNextAvailableTag(dest.getPublicKey(),key);
  Set sentTags=null;
  if (_context.sessionKeyManager().getAvailableTags(dest.getPublicKey(),key) < 10) {
    sentTags=createNewTags(50);
  }
 else   if (_context.sessionKeyManager().getAvailableTimeLeft(dest.getPublicKey(),key) < 2 * 60 * 1000) {
    sentTags=createNewTags(50);
    if (_log.shouldLog(Log.DEBUG))     _log.debug(getPrefix() + "Tags are almost expired, adding 50 new ones");
  }
  SessionKey newKey=null;
  if (false)   newKey=_context.keyGenerator().generateSessionKey();
  long nonce=_context.random().nextInt(Integer.MAX_VALUE);
  MessageState state=new MessageState(nonce,getPrefix());
  state.setKey(key);
  state.setTags(sentTags);
  state.setNewKey(newKey);
  state.setTo(dest);
  if (_log.shouldLog(Log.DEBUG))   _log.debug(getPrefix() + "Setting key = " + key);
  if (keyUsed != null) {
    if (newKey != null)     keyUsed.setData(newKey.getData());
 else     keyUsed.setData(key.getData());
  }
  if (tagsSent != null) {
    if (sentTags != null) {
      tagsSent.addAll(sentTags);
    }
  }
  long beforeSendingSync=_context.clock().now();
  long inSendingSync=0;
synchronized (_sendingStates) {
    inSendingSync=_context.clock().now();
    _sendingStates.add(state);
  }
  long afterSendingSync=_context.clock().now();
  if (_log.shouldLog(Log.DEBUG))   _log.debug(getPrefix() + "Adding sending state " + state.getMessageId()+ " / "+ state.getNonce()+ " for guaranteed "+ " sync took "+ (inSendingSync - beforeSendingSync)+ " add took "+ (afterSendingSync - inSendingSync));
  _producer.sendMessage(this,dest,nonce,payload,tag,key,sentTags,newKey);
  long beforeWaitFor=_context.clock().now();
  if (isGuaranteed())   state.waitFor(MessageStatusMessage.STATUS_SEND_GUARANTEED_SUCCESS,_context.clock().now() + SEND_TIMEOUT);
 else   state.waitFor(MessageStatusMessage.STATUS_SEND_ACCEPTED,_context.clock().now() + SEND_TIMEOUT);
  long afterWaitFor=_context.clock().now();
  long inRemovingSync=0;
synchronized (_sendingStates) {
    inRemovingSync=_context.clock().now();
    _sendingStates.remove(state);
  }
  long afterRemovingSync=_context.clock().now();
  boolean guaranteed=isGuaranteed();
  boolean found=false;
  boolean accepted=state.received(MessageStatusMessage.STATUS_SEND_ACCEPTED);
  if (guaranteed)   found=state.received(MessageStatusMessage.STATUS_SEND_GUARANTEED_SUCCESS);
 else   found=accepted;
  if ((!accepted) || (state.getMessageId() == null)) {
    if (_log.shouldLog(Log.CRIT))     _log.log(Log.CRIT,getPrefix() + "State with nonce " + state.getNonce()+ " was not accepted?  (no messageId!! found="+ found+ " msgId="+ state.getMessageId()+ ", sendingSync="+ (afterSendingSync - beforeSendingSync)+ ", sendMessage="+ (beforeWaitFor - afterSendingSync)+ ", waitFor="+ (afterWaitFor - beforeWaitFor)+ ", removingSync="+ (afterRemovingSync - afterWaitFor)+ ")");
    if (guaranteed)     nackTags(state);
    return false;
  }
  if (_log.shouldLog(Log.DEBUG))   _log.debug(getPrefix() + "After waitFor sending state " + state.getMessageId().getMessageId()+ " / "+ state.getNonce()+ " found = "+ found);
  if (guaranteed) {
    if (found) {
      if (_log.shouldLog(Log.INFO))       _log.info(getPrefix() + "Message sent after " + state.getElapsed()+ "ms with "+ payload.length+ " bytes");
      ackTags(state);
    }
 else {
      if (_log.shouldLog(Log.INFO))       _log.info(getPrefix() + "Message send failed after " + state.getElapsed()+ "ms with "+ payload.length+ " bytes");
      nackTags(state);
    }
  }
 else {
    if (_log.shouldLog(Log.INFO))     _log.info(getPrefix() + "Message send enqueued after " + state.getElapsed()+ "ms with "+ payload.length+ " bytes");
  }
  return found;
}
