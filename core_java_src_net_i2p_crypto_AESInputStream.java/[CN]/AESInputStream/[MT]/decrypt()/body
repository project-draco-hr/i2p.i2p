{
  byte encrypted[]=_encryptedBuf.toByteArray();
  _encryptedBuf.reset();
  if ((encrypted == null) || (encrypted.length <= 0))   throw new IOException("Error decrypting - no data to decrypt");
  int numBlocks=encrypted.length / BLOCK_SIZE;
  if ((encrypted.length % BLOCK_SIZE) != 0) {
    int trailing=encrypted.length % BLOCK_SIZE;
    _encryptedBuf.write(encrypted,encrypted.length - trailing,trailing);
    byte nencrypted[]=new byte[encrypted.length - trailing];
    System.arraycopy(encrypted,0,nencrypted,0,nencrypted.length);
    encrypted=nencrypted;
    if (_log.shouldLog(Log.WARN))     _log.warn("Decrypt got odd segment - " + trailing + " bytes pushed back for later decryption - corrupted or slow data stream perhaps?");
  }
 else {
    if (_log.shouldLog(Log.DEBUG))     _log.debug(encrypted.length + " bytes makes up " + numBlocks+ " blocks to decrypt normally");
  }
  for (int i=0; i < numBlocks; i++) {
    _context.aes().decrypt(encrypted,i * BLOCK_SIZE,encrypted,i * BLOCK_SIZE,_key,_lastBlock,BLOCK_SIZE);
    DataHelper.xor(encrypted,i * BLOCK_SIZE,_lastBlock,0,encrypted,i * BLOCK_SIZE,BLOCK_SIZE);
    int payloadBytes=countBlockPayload(encrypted,i * BLOCK_SIZE);
    for (int j=0; j < payloadBytes; j++) {
      int c=encrypted[j + i * BLOCK_SIZE];
      if (c <= 0)       c+=256;
      _readyBuf.add(new Integer(c));
    }
    _cumulativePaddingStripped+=BLOCK_SIZE - payloadBytes;
    _cumulativePrepared+=payloadBytes;
    System.arraycopy(encrypted,i * BLOCK_SIZE,_lastBlock,0,BLOCK_SIZE);
  }
  int remaining=encrypted.length % BLOCK_SIZE;
  if (remaining != 0) {
    _encryptedBuf.write(encrypted,encrypted.length - remaining,remaining);
    _log.debug("After pushing " + remaining + " bytes back onto the buffer, lets delay 1s our action so we don't fast busy until the net transfers data");
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException ie) {
    }
  }
 else {
  }
}
