{
  long start=Clock.getInstance().now();
  SessionKey key=new SessionKey();
  BigInteger exchangedKey=publicPeerValue.modPow(myPrivateValue,CryptoConstants.elgp);
  byte buf[]=exchangedKey.toByteArray();
  byte val[]=new byte[32];
  if (buf.length < val.length) {
    System.arraycopy(buf,0,val,0,buf.length);
    byte remaining[]=SHA256Generator.getInstance().calculateHash(val).getData();
    _extraExchangedBytes.setData(remaining);
    if (_log.shouldLog(Log.DEBUG))     _log.debug("Storing " + remaining.length + " bytes from the DH exchange by SHA256 the session key");
  }
 else {
    System.arraycopy(buf,0,val,0,val.length);
    byte remaining[]=new byte[buf.length - val.length];
    System.arraycopy(buf,val.length,remaining,0,remaining.length);
    _extraExchangedBytes.setData(remaining);
    if (_log.shouldLog(Log.DEBUG))     _log.debug("Storing " + remaining.length + " bytes from the end of the DH exchange");
  }
  key.setData(val);
  long end=Clock.getInstance().now();
  long diff=end - start;
  if (diff > 1000) {
    if (_log.shouldLog(Log.WARN))     _log.warn("Generating session key took too long (" + diff + " ms");
  }
 else {
    if (_log.shouldLog(Log.DEBUG))     _log.debug("Generating session key " + diff + " ms");
  }
  return key;
}
