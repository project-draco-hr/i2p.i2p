{
  RandomSource.getInstance().nextBoolean();
  try {
    Thread.sleep(20 * 1000);
  }
 catch (  InterruptedException ie) {
  }
  I2PAppContext ctx=new I2PAppContext();
  _log.debug("\n\n\n\nBegin test\n");
  long negTime=0;
  for (int i=0; i < 5; i++) {
    long startNeg=Clock.getInstance().now();
    DHSessionKeyBuilder builder1=new DHSessionKeyBuilder();
    DHSessionKeyBuilder builder2=new DHSessionKeyBuilder();
    BigInteger pub1=builder1.getMyPublicValue();
    builder2.setPeerPublicValue(pub1);
    BigInteger pub2=builder2.getMyPublicValue();
    builder1.setPeerPublicValue(pub2);
    SessionKey key1=builder1.getSessionKey();
    SessionKey key2=builder2.getSessionKey();
    long endNeg=Clock.getInstance().now();
    negTime+=endNeg - startNeg;
    if (!key1.equals(key2))     _log.error("**ERROR: Keys do not match");
 else     _log.debug("**Success: Keys match");
    byte iv[]=new byte[16];
    RandomSource.getInstance().nextBytes(iv);
    String origVal="1234567890123456";
    byte enc[]=ctx.AESEngine().encrypt(origVal.getBytes(),key1,iv);
    byte dec[]=ctx.AESEngine().decrypt(enc,key2,iv);
    String tranVal=new String(dec);
    if (origVal.equals(tranVal))     _log.debug("**Success: D(E(val)) == val");
 else     _log.error("**ERROR: D(E(val)) != val [val=(" + tranVal + "), origVal=("+ origVal+ ")");
  }
  _log.debug("Negotiation time for 5 runs: " + negTime + " @ "+ negTime / 5l + "ms each");
  try {
    Thread.sleep(2000);
  }
 catch (  InterruptedException ie) {
  }
}
