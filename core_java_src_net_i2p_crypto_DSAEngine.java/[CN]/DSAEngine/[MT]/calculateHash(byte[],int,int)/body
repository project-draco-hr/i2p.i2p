{
  long length=len * 8;
  int k=448 - (int)((length + 1) % 512);
  if (k < 0) {
    k+=512;
  }
  int padbytes=k / 8;
  int wordlength=len / 4 + padbytes / 4 + 3;
  int[] M0=new int[wordlength];
  int wordcount=0;
  int x=0;
  for (x=0; x < (len / 4) * 4; x+=4) {
    M0[wordcount]=source[offset + x] << 24 >>> 24 << 24;
    M0[wordcount]|=source[offset + x + 1] << 24 >>> 24 << 16;
    M0[wordcount]|=source[offset + x + 2] << 24 >>> 24 << 8;
    M0[wordcount]|=source[offset + x + 3] << 24 >>> 24 << 0;
    wordcount++;
  }
switch (len - (wordcount + 1) * 4 + 4) {
case 0:
    M0[wordcount]|=0x80000000;
  break;
case 1:
M0[wordcount]=source[offset + x] << 24 >>> 24 << 24;
M0[wordcount]|=0x00800000;
break;
case 2:
M0[wordcount]=source[offset + x] << 24 >>> 24 << 24;
M0[wordcount]|=source[offset + x + 1] << 24 >>> 24 << 16;
M0[wordcount]|=0x00008000;
break;
case 3:
M0[wordcount]=source[offset + x] << 24 >>> 24 << 24;
M0[wordcount]|=source[offset + x + 1] << 24 >>> 24 << 16;
M0[wordcount]|=source[offset + x + 2] << 24 >>> 24 << 8;
M0[wordcount]|=0x00000080;
break;
}
M0[wordlength - 2]=(int)(length >>> 32);
M0[wordlength - 1]=(int)(length);
int[] H=new int[5];
for (x=0; x < 5; x++) {
H[x]=H0[x];
}
int blocks=M0.length / 16;
for (int bl=0; bl < blocks; bl++) {
int a=H[0];
int b=H[1];
int c=H[2];
int d=H[3];
int e=H[4];
int[] W=new int[80];
for (x=0; x < 80; x++) {
if (x < 16) {
W[x]=M0[bl * 16 + x];
}
 else {
W[x]=ROTL(1,W[x - 3] ^ W[x - 8] ^ W[x - 14]^ W[x - 16]);
}
}
for (x=0; x < 80; x++) {
int T=add(ROTL(5,a),add(f(x,b,c,d),add(e,add(k(x),W[x]))));
e=d;
d=c;
c=ROTL(30,b);
b=a;
a=T;
}
H[0]=add(a,H[0]);
H[1]=add(b,H[1]);
H[2]=add(c,H[2]);
H[3]=add(d,H[3]);
H[4]=add(e,H[4]);
}
byte[] hashbytes=new byte[20];
for (x=0; x < 5; x++) {
hashbytes[x * 4]=(byte)(H[x] << 0 >>> 24);
hashbytes[x * 4 + 1]=(byte)(H[x] << 8 >>> 24);
hashbytes[x * 4 + 2]=(byte)(H[x] << 16 >>> 24);
hashbytes[x * 4 + 3]=(byte)(H[x] << 24 >>> 24);
}
Hash hash=new Hash();
hash.setData(hashbytes);
return hash;
}
