{
  long start=Clock.getInstance().now();
  byte[] sigbytes=signature.getData();
  byte rbytes[]=new byte[20];
  byte sbytes[]=new byte[20];
  for (int x=0; x < 40; x++) {
    if (x < 20) {
      rbytes[x]=sigbytes[x];
    }
 else {
      sbytes[x - 20]=sigbytes[x];
    }
  }
  BigInteger s=new NativeBigInteger(1,sbytes);
  BigInteger r=new NativeBigInteger(1,rbytes);
  BigInteger y=new NativeBigInteger(1,verifyingKey.getData());
  BigInteger w=s.modInverse(CryptoConstants.dsaq);
  BigInteger u1=((new NativeBigInteger(1,calculateHash(signedData).getData())).multiply(w)).mod(CryptoConstants.dsaq);
  BigInteger u2=r.multiply(w).mod(CryptoConstants.dsaq);
  BigInteger v=((CryptoConstants.dsag.modPow(u1,CryptoConstants.dsap)).multiply(y.modPow(u2,CryptoConstants.dsap))).mod(CryptoConstants.dsap).mod(CryptoConstants.dsaq);
  boolean ok=v.compareTo(r) == 0;
  long diff=Clock.getInstance().now() - start;
  if (diff > 1000) {
    if (_log.shouldLog(Log.WARN))     _log.warn("Took too long to verify the signature (" + diff + "ms)");
  }
  return ok;
}
