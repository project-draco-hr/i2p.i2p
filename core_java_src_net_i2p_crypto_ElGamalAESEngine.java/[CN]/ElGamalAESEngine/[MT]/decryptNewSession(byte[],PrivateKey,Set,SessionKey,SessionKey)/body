{
  if (data == null) {
    if (_log.shouldLog(Log.WARN))     _log.warn("Data is null, unable to decrypt new session");
    return null;
  }
 else   if (data.length < 514) {
    if (_log.shouldLog(Log.WARN))     _log.warn("Data length is too small (" + data.length + ")");
    return null;
  }
  byte elgEncr[]=new byte[514];
  if (data.length > 514) {
    System.arraycopy(data,0,elgEncr,0,514);
  }
 else {
    System.arraycopy(data,0,elgEncr,514 - data.length,data.length);
  }
  byte elgDecr[]=_context.elGamalEngine().decrypt(elgEncr,targetPrivateKey);
  if (elgDecr == null) {
    if (_log.shouldLog(Log.WARN))     _log.warn("decrypt returned null",new Exception("decrypt failed"));
    return null;
  }
  byte preIV[]=null;
  int offset=0;
  byte key[]=new byte[SessionKey.KEYSIZE_BYTES];
  System.arraycopy(elgDecr,offset,key,0,SessionKey.KEYSIZE_BYTES);
  offset+=SessionKey.KEYSIZE_BYTES;
  usedKey.setData(key);
  preIV=new byte[32];
  System.arraycopy(elgDecr,offset,preIV,0,32);
  offset+=32;
  Hash ivHash=_context.sha().calculateHash(preIV);
  byte iv[]=new byte[16];
  System.arraycopy(ivHash.getData(),0,iv,0,16);
  _context.random().harvester().feedEntropy("ElG/AES",elgDecr,offset,elgDecr.length - offset);
  byte aesDecr[]=decryptAESBlock(data,514,data.length - 514,usedKey,iv,null,foundTags,foundKey);
  if (_log.shouldLog(Log.DEBUG))   _log.debug("Decrypt with a NEW session successfull: # tags read = " + foundTags.size(),new Exception("Decrypted by"));
  return aesDecr;
}
