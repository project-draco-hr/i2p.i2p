{
  if (data == null) {
    if (_log.shouldLog(Log.WARN))     _log.warn("Data is null, unable to decrypt new session");
    return null;
  }
 else   if (data.length < 514) {
    if (_log.shouldLog(Log.WARN))     _log.warn("Data length is too small (" + data.length + ")");
    return null;
  }
  byte elgEncr[]=new byte[514];
  if (data.length > 514) {
    System.arraycopy(data,0,elgEncr,0,514);
  }
 else {
    System.arraycopy(data,0,elgEncr,514 - data.length,data.length);
  }
  byte elgDecr[]=_context.elGamalEngine().decrypt(elgEncr,targetPrivateKey);
  if (elgDecr == null)   return null;
  ByteArrayInputStream bais=new ByteArrayInputStream(elgDecr);
  byte preIV[]=null;
  try {
    usedKey.readBytes(bais);
    preIV=new byte[32];
    int read=bais.read(preIV);
    if (read != preIV.length) {
      throw new DataFormatException("Somehow ElGamal broke and 256 bytes is less than 32 bytes...");
    }
  }
 catch (  IOException ioe) {
    if (_log.shouldLog(Log.ERROR))     _log.error("Error decrypting the new session",ioe);
    return null;
  }
  byte aesEncr[]=new byte[data.length - 514];
  System.arraycopy(data,514,aesEncr,0,aesEncr.length);
  Hash ivHash=_context.sha().calculateHash(preIV);
  byte iv[]=new byte[16];
  System.arraycopy(ivHash.getData(),0,iv,0,16);
  byte aesDecr[]=decryptAESBlock(aesEncr,usedKey,iv,null,foundTags,foundKey);
  if (_log.shouldLog(Log.DEBUG))   _log.debug("Decrypt with a NEW session successfull: # tags read = " + foundTags.size(),new Exception("Decrypted by"));
  return aesDecr;
}
