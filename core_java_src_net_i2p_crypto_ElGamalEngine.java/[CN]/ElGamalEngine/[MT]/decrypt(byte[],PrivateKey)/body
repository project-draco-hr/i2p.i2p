{
  if ((encrypted == null) || (encrypted.length > 514))   throw new IllegalArgumentException("Data to decrypt must be <= 514 bytes at the moment");
  long start=_context.clock().now();
  byte[] ybytes=new byte[257];
  byte[] dbytes=new byte[257];
  System.arraycopy(encrypted,0,ybytes,0,257);
  System.arraycopy(encrypted,257,dbytes,0,257);
  BigInteger y=new NativeBigInteger(1,ybytes);
  BigInteger d=new NativeBigInteger(1,dbytes);
  BigInteger a=new NativeBigInteger(1,privateKey.getData());
  BigInteger y1p=CryptoConstants.elgp.subtract(BigInteger.ONE).subtract(a);
  BigInteger ya=y.modPow(y1p,CryptoConstants.elgp);
  BigInteger m=ya.multiply(d);
  m=m.mod(CryptoConstants.elgp);
  byte val[]=m.toByteArray();
  int i=0;
  for (i=0; i < val.length; i++)   if (val[i] != (byte)0x00)   break;
  int payloadLen=val.length - i - 1- Hash.HASH_LENGTH;
  if (payloadLen < 0) {
    if (_log.shouldLog(Log.ERROR))     _log.error("Decrypted data is too small (" + (val.length - i) + ")");
    return null;
  }
  Hash hash=Hash.create(val,i + 1);
  byte rv[]=new byte[payloadLen];
  System.arraycopy(val,i + 1 + Hash.HASH_LENGTH,rv,0,rv.length);
  Hash calcHash=_context.sha().calculateHash(rv);
  boolean ok=calcHash.equals(hash);
  long end=_context.clock().now();
  long diff=end - start;
  if (diff > 1000) {
    if (_log.shouldLog(Log.WARN))     _log.warn("Took too long to decrypt and verify ElGamal block (" + diff + "ms)");
  }
  _context.statManager().addRateData("crypto.elGamal.decrypt",diff,diff);
  if (ok) {
    return rv;
  }
  if (_log.shouldLog(Log.DEBUG))   _log.debug("Doesn't match hash [sent hash=" + hash + "]\ndata = "+ Base64.encode(rv),new Exception("Doesn't match"));
  return null;
}
