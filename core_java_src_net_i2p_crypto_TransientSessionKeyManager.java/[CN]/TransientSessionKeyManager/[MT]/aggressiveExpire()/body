{
  int removed=0;
  int remaining=0;
  long now=_context.clock().now();
  StringBuilder buf=null;
  StringBuilder bufSummary=null;
  if (_log.shouldLog(Log.DEBUG)) {
    buf=new StringBuilder(128);
    buf.append("Expiring inbound: ");
    bufSummary=new StringBuilder(1024);
  }
synchronized (_inboundTagSets) {
    for (Iterator<SessionTag> iter=_inboundTagSets.keySet().iterator(); iter.hasNext(); ) {
      SessionTag tag=iter.next();
      TagSet ts=_inboundTagSets.get(tag);
      long age=now - ts.getDate();
      if (age > SESSION_LIFETIME_MAX_MS) {
        iter.remove();
        removed++;
        if (buf != null)         buf.append(tag.toString()).append(" @ age ").append(DataHelper.formatDuration(age));
      }
 else       if (false && (bufSummary != null)) {
        bufSummary.append("\nTagSet: " + ts.toString() + ", key: "+ ts.getAssociatedKey().toBase64()+ "/"+ ts.getAssociatedKey().toString()+ ": tag: "+ tag.toString());
      }
    }
    remaining=_inboundTagSets.size();
  }
  _context.statManager().addRateData("crypto.sessionTagsRemaining",remaining,0);
  if ((buf != null) && (removed > 0))   _log.debug(buf.toString());
  if (bufSummary != null)   _log.debug("Cleaning up with remaining: " + bufSummary.toString());
synchronized (_outboundSessions) {
    for (Iterator<PublicKey> iter=_outboundSessions.keySet().iterator(); iter.hasNext(); ) {
      PublicKey key=iter.next();
      OutboundSession sess=_outboundSessions.get(key);
      removed+=sess.expireTags();
      if (sess.availableTags() <= 0) {
        iter.remove();
        removed++;
      }
    }
  }
  return removed;
}
