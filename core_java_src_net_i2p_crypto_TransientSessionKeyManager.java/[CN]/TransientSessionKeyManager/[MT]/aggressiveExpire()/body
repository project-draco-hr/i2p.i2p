{
  int removed=0;
  int remaining=0;
  long now=_context.clock().now();
synchronized (_inboundTagSets) {
    for (Iterator iter=_inboundTagSets.keySet().iterator(); iter.hasNext(); ) {
      SessionTag tag=(SessionTag)iter.next();
      TagSet ts=(TagSet)_inboundTagSets.get(tag);
      if (ts.getDate() < now - SESSION_LIFETIME_MAX_MS) {
        iter.remove();
        removed++;
      }
    }
    remaining=_inboundTagSets.size();
  }
  _context.statManager().addRateData("crypto.sessionTagsRemaining",remaining,0);
synchronized (_outboundSessions) {
    for (Iterator iter=_outboundSessions.keySet().iterator(); iter.hasNext(); ) {
      PublicKey key=(PublicKey)iter.next();
      OutboundSession sess=(OutboundSession)_outboundSessions.get(key);
      removed+=sess.expireTags();
      if (sess.availableTags() <= 0) {
        iter.remove();
        removed++;
      }
    }
  }
  return removed;
}
