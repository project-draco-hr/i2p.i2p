{
  byte[] headerUpdateVersion={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
  byte[] updateVersionBytes=null;
  if (updateVersion.length() > VERSION_BYTES)   updateVersion=updateVersion.substring(0,VERSION_BYTES);
  try {
    updateVersionBytes=updateVersion.getBytes("UTF-8");
  }
 catch (  UnsupportedEncodingException e) {
    throw new RuntimeException("wtf, your JVM doesnt support utf-8? " + e.getMessage());
  }
  System.arraycopy(updateVersionBytes,0,headerUpdateVersion,0,updateVersionBytes.length);
  Signature signature=null;
  FileInputStream in=null;
  try {
    in=new FileInputStream(inputFile);
    signature=_context.dsa().sign(in,privKey);
  }
 catch (  Exception e) {
    if (_log.shouldLog(Log.ERROR))     _log.error("Error signing",e);
    return null;
  }
 finally {
    if (in != null)     try {
      in.close();
    }
 catch (    IOException ioe) {
    }
    in=null;
  }
  FileOutputStream fileOutputStream=null;
  try {
    fileOutputStream=new FileOutputStream(outputFile);
    fileOutputStream.write(headerUpdateVersion);
    fileOutputStream.write(signature.getData());
    in=new FileInputStream(inputFile);
    byte buf[]=new byte[1024];
    int read=0;
    while ((read=in.read(buf)) != -1)     fileOutputStream.write(buf,0,read);
    fileOutputStream.close();
    fileOutputStream=null;
  }
 catch (  IOException ioe) {
    if (_log.shouldLog(Log.WARN))     _log.log(Log.WARN,"Error writing signed I2P update file " + outputFile,ioe);
    return null;
  }
 finally {
    if (fileOutputStream != null)     try {
      fileOutputStream.close();
    }
 catch (    IOException ioe) {
    }
    if (in != null)     try {
      in.close();
    }
 catch (    IOException ioe) {
    }
  }
  return signature;
}
