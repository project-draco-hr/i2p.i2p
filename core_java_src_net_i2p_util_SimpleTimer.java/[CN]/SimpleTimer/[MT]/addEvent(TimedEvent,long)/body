{
  int totalEvents=0;
  long now=System.currentTimeMillis();
  long eventTime=now + timeoutMs;
  Long time=new Long(eventTime);
synchronized (_events) {
    if (_eventTimes.containsKey(event))     _events.remove(_eventTimes.get(event));
    while (_events.containsKey(time))     time=new Long(time.longValue() + 1);
    _events.put(time,event);
    _eventTimes.put(event,time);
    if ((_events.size() != _eventTimes.size())) {
      _log.error("Skewed events: " + _events.size() + " for "+ _eventTimes.size());
      for (Iterator iter=_eventTimes.keySet().iterator(); iter.hasNext(); ) {
        TimedEvent evt=(TimedEvent)iter.next();
        Long when=(Long)_eventTimes.get(evt);
        TimedEvent cur=(TimedEvent)_events.get(when);
        if (cur != evt) {
          _log.error("event " + evt + " @ "+ when+ ": "+ cur);
        }
      }
    }
    totalEvents=_events.size();
    _events.notifyAll();
  }
  if (time.longValue() > eventTime + 100) {
    if (_log.shouldLog(Log.ERROR))     _log.error("Lots of timer congestion, had to push " + event + " back "+ (time.longValue() - eventTime)+ "ms (# events: "+ totalEvents+ ")");
  }
  long timeToAdd=System.currentTimeMillis() - now;
  if (timeToAdd > 50) {
    if (_log.shouldLog(Log.WARN))     _log.warn("timer contention: took " + timeToAdd + "ms to add a job");
  }
}
