{
  this.levelPage=levelPage;
  this.bf=bf;
  BlockFile.pageSeek(bf.file,levelPage);
  long magic=bf.file.readLong();
  if (magic != MAGIC)   throw new IOException("Bad SkipLevels magic number 0x" + Long.toHexString(magic) + " on page "+ levelPage);
  bsl.levelHash.put(new Integer(this.levelPage),this);
  int maxLen=bf.file.readUnsignedShort();
  int nonNull=bf.file.readUnsignedShort();
  if (maxLen < 1 || maxLen > MAX_SIZE || nonNull > maxLen)   throw new IOException("Invalid Level Skip size " + nonNull + " / "+ maxLen);
  spanPage=bf.file.readUnsignedInt();
  bottom=(BSkipSpan)bsl.spanHash.get(new Integer(spanPage));
  this.levels=new BSkipLevels[maxLen];
  if (BlockFile.log.shouldLog(Log.DEBUG))   BlockFile.log.debug("Reading New BSkipLevels with " + nonNull + " / "+ maxLen+ " valid levels page "+ levelPage);
  int[] lps=new int[nonNull];
  for (int i=0; i < nonNull; i++) {
    lps[i]=bf.file.readUnsignedInt();
  }
  for (int i=0; i < nonNull; i++) {
    int lp=lps[i];
    if (lp != 0) {
      levels[i]=(BSkipLevels)bsl.levelHash.get(new Integer(lp));
      if (levels[i] == null) {
        levels[i]=new BSkipLevels(bf,lp,bsl);
        bsl.levelHash.put(new Integer(lp),levels[i]);
      }
 else {
      }
    }
 else {
      if (BlockFile.log.shouldLog(Log.WARN))       BlockFile.log.warn("WTF " + this + " i = "+ i+ " of "+ nonNull+ " / "+ maxLen+ " valid levels but page is zero");
      levels[i]=null;
    }
  }
}
