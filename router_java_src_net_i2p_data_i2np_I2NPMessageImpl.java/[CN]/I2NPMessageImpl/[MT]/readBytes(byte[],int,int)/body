{
  int cur=offset;
  if (type < 0) {
    type=(int)DataHelper.fromLong(data,cur,1);
    cur++;
  }
  _uniqueId=DataHelper.fromLong(data,cur,4);
  cur+=4;
  _expiration=DataHelper.fromLong(data,cur,DataHelper.DATE_LENGTH);
  cur+=DataHelper.DATE_LENGTH;
  int size=(int)DataHelper.fromLong(data,cur,2);
  cur+=2;
  byte hdata[]=new byte[CHECKSUM_LENGTH];
  System.arraycopy(data,cur,hdata,0,CHECKSUM_LENGTH);
  cur+=CHECKSUM_LENGTH;
  if (cur + size > data.length)   throw new I2NPMessageException("Payload is too short [" + "data.len=" + data.length + " offset="+ offset+ " cur="+ cur+ " wanted="+ size+ "]: "+ getClass().getName());
  SHA256EntryCache.CacheEntry cache=_context.sha().cache().acquire(size);
  Hash calc=_context.sha().calculateHash(data,cur,size,cache);
  boolean eq=DataHelper.eq(hdata,0,calc.getData(),0,CHECKSUM_LENGTH);
  _context.sha().cache().release(cache);
  if (!eq)   throw new I2NPMessageException("Hash does not match for " + getClass().getName());
  long start=_context.clock().now();
  if (_log.shouldLog(Log.DEBUG))   _log.debug("Reading bytes: type = " + type + " / uniqueId : "+ _uniqueId+ " / expiration : "+ _expiration);
  readMessage(data,cur,size,type);
  cur+=size;
  long time=_context.clock().now() - start;
  return cur - offset;
}
