{
  if (type < 0) {
    type=(int)DataHelper.fromLong(data,offset,1);
    offset++;
  }
  _uniqueId=DataHelper.fromLong(data,offset,4);
  offset+=4;
  _expiration=DataHelper.fromDate(data,offset);
  offset+=DataHelper.DATE_LENGTH;
  int size=(int)DataHelper.fromLong(data,offset,2);
  offset+=2;
  Hash h=new Hash();
  byte hdata[]=new byte[Hash.HASH_LENGTH];
  System.arraycopy(data,offset,hdata,0,Hash.HASH_LENGTH);
  offset+=Hash.HASH_LENGTH;
  h.setData(hdata);
  if (offset + size > data.length)   throw new I2NPMessageException("Payload is too short [" + "data.len=" + data.length + " offset="+ offset+ " wanted="+ size+ "]");
  SHA256EntryCache.CacheEntry cache=_context.sha().cache().acquire(size);
  Hash calc=_context.sha().calculateHash(data,offset,size,cache);
  boolean eq=calc.equals(h);
  _context.sha().cache().release(cache);
  if (!eq)   throw new I2NPMessageException("Hash does not match");
  long start=_context.clock().now();
  if (_log.shouldLog(Log.DEBUG))   _log.debug("Reading bytes: type = " + type + " / uniqueId : "+ _uniqueId+ " / expiration : "+ _expiration);
  readMessage(data,offset,size,type);
  long time=_context.clock().now() - start;
  if (time > 50)   _context.statManager().addRateData("i2np.readTime",time,time);
  return size + Hash.HASH_LENGTH + 1+ 4+ DataHelper.DATE_LENGTH;
}
