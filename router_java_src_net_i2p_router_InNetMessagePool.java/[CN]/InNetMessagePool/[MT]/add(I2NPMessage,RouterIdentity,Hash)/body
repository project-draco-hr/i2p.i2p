{
  long exp=messageBody.getMessageExpiration();
  if (_log.shouldLog(Log.INFO))   _log.info("Received inbound " + " with id " + messageBody.getUniqueId() + " expiring on "+ exp+ " of type "+ messageBody.getClass().getName());
  String invalidReason=null;
  if (messageBody instanceof TunnelDataMessage) {
    invalidReason=_context.messageValidator().validateMessage(exp);
  }
 else {
    invalidReason=_context.messageValidator().validateMessage(messageBody.getUniqueId(),exp);
  }
  if (invalidReason != null) {
    int level=Log.WARN;
    if (messageBody instanceof TunnelCreateMessage)     level=Log.INFO;
    if (_log.shouldLog(level))     _log.log(level,"Duplicate message received [" + messageBody.getUniqueId() + " expiring on "+ exp+ "]: "+ messageBody.getClass().getName()+ ": "+ invalidReason+ ": "+ messageBody);
    _context.statManager().addRateData("inNetPool.dropped",1,0);
    _context.statManager().addRateData("inNetPool.duplicate",1,0);
    _context.messageHistory().droppedOtherMessage(messageBody);
    _context.messageHistory().messageProcessingError(messageBody.getUniqueId(),messageBody.getClass().getName(),"Duplicate/expired");
    return -1;
  }
 else {
    if (_log.shouldLog(Log.DEBUG))     _log.debug("Message received [" + messageBody.getUniqueId() + " expiring on "+ exp+ "] is NOT a duplicate or exipired");
  }
  boolean jobFound=false;
  int type=messageBody.getType();
  boolean allowMatches=true;
  if (messageBody instanceof TunnelGatewayMessage) {
    shortCircuitTunnelGateway(messageBody);
    allowMatches=false;
  }
 else   if (messageBody instanceof TunnelDataMessage) {
    shortCircuitTunnelData(messageBody,fromRouterHash);
    allowMatches=false;
  }
 else {
    if ((type > 0) && (type < _handlerJobBuilders.length)) {
      HandlerJobBuilder builder=_handlerJobBuilders[type];
      if (_log.shouldLog(Log.DEBUG))       _log.debug("Add message to the inNetMessage pool - builder: " + builder + " message class: "+ messageBody.getClass().getName());
      if (builder != null) {
        Job job=builder.createJob(messageBody,fromRouter,fromRouterHash);
        if (job != null) {
          _context.jobQueue().addJob(job);
          jobFound=true;
        }
 else {
          jobFound=true;
        }
      }
    }
  }
  if (allowMatches) {
    int replies=handleReplies(messageBody);
    if (replies <= 0) {
      if (!jobFound) {
        _context.messageHistory().droppedOtherMessage(messageBody);
        if (type == DeliveryStatusMessage.MESSAGE_TYPE) {
          long timeSinceSent=_context.clock().now() - ((DeliveryStatusMessage)messageBody).getArrival();
          if (_log.shouldLog(Log.WARN))           _log.warn("Dropping unhandled delivery status message created " + timeSinceSent + "ms ago: "+ messageBody);
          _context.statManager().addRateData("inNetPool.droppedDeliveryStatusDelay",timeSinceSent,timeSinceSent);
        }
 else         if (type == TunnelCreateStatusMessage.MESSAGE_TYPE) {
          if (_log.shouldLog(Log.INFO))           _log.info("Dropping slow tunnel create request response: " + messageBody);
          _context.statManager().addRateData("inNetPool.droppedTunnelCreateStatusMessage",1,0);
        }
 else         if (type == DatabaseSearchReplyMessage.MESSAGE_TYPE) {
          if (_log.shouldLog(Log.INFO))           _log.info("Dropping slow db lookup response: " + messageBody);
          _context.statManager().addRateData("inNetPool.droppedDbLookupResponseMessage",1,0);
        }
 else         if (type == DatabaseLookupMessage.MESSAGE_TYPE) {
          if (_log.shouldLog(Log.DEBUG))           _log.debug("Dropping netDb lookup due to throttling");
        }
 else {
          if (_log.shouldLog(Log.WARN))           _log.warn("Message expiring on " + (messageBody != null ? (messageBody.getMessageExpiration() + "") : " [unknown]") + " was not handled by a HandlerJobBuilder - DROPPING: "+ messageBody,new Exception("f00!"));
          _context.statManager().addRateData("inNetPool.dropped",1,0);
        }
      }
 else {
        String mtype=messageBody.getClass().getName();
        _context.messageHistory().receiveMessage(mtype,messageBody.getUniqueId(),messageBody.getMessageExpiration(),fromRouterHash,true);
        return 0;
      }
    }
  }
  String mtype=messageBody.getClass().getName();
  _context.messageHistory().receiveMessage(mtype,messageBody.getUniqueId(),messageBody.getMessageExpiration(),fromRouterHash,true);
  return 0;
}
