{
  _state=2;
  long lastActive=_context.clock().now();
  long jobNum=0;
  while ((_keepRunning) && (_context.jobQueue().isAlive())) {
    _state=3;
    try {
      Job job=_context.jobQueue().getNext();
      _state=4;
      if (job == null) {
        _state=5;
        if (_context.router().isAlive())         if (_log.shouldLog(Log.ERROR))         _log.error("getNext returned null - dead?");
        continue;
      }
      long now=_context.clock().now();
      long enqueuedTime=0;
      if (job instanceof JobImpl) {
        _state=6;
        long when=((JobImpl)job).getMadeReadyOn();
        if (when <= 0) {
          _state=7;
          _log.error("Job was not made ready?! " + job,new Exception("Not made ready?!"));
        }
 else {
          _state=8;
          enqueuedTime=now - when;
        }
      }
      long betweenJobs=now - lastActive;
      _currentJob=job;
      _lastJob=null;
      _state=9;
      if (_log.shouldLog(Log.DEBUG))       _log.debug("Runner " + _id + " running job "+ job.getJobId()+ ": "+ job.getName());
      long origStartAfter=job.getTiming().getStartAfter();
      long doStart=_context.clock().now();
      _state=10;
      job.getTiming().start();
      runCurrentJob();
      job.getTiming().end();
      _state=11;
      long duration=job.getTiming().getActualEnd() - job.getTiming().getActualStart();
      long beforeUpdate=_context.clock().now();
      _state=12;
      _context.jobQueue().updateStats(job,doStart,origStartAfter,duration);
      _state=13;
      long diff=_context.clock().now() - beforeUpdate;
      long lag=doStart - origStartAfter;
      if (lag < 0)       lag=0;
      _context.statManager().addRateData("jobQueue.jobRunnerInactive",betweenJobs,betweenJobs);
      _context.statManager().addRateData("jobQueue.jobRun",duration,duration);
      _context.statManager().addRateData("jobQueue.jobLag",lag,0);
      _context.statManager().addRateData("jobQueue.jobWait",enqueuedTime,enqueuedTime);
      if (duration > 1000) {
        _context.statManager().addRateData("jobQueue.jobRunSlow",duration,duration);
        if (_log.shouldLog(Log.WARN))         _log.warn("Duration of " + duration + " (lag "+ (doStart - origStartAfter)+ ") on job "+ _currentJob);
      }
      _state=14;
      if (diff > 100) {
        if (_log.shouldLog(Log.WARN))         _log.warn("Updating statistics for the job took too long [" + diff + "ms]");
      }
      if (_log.shouldLog(Log.DEBUG))       _log.debug("Job duration " + duration + "ms for "+ job.getName()+ " with lag of "+ (doStart - origStartAfter)+ "ms");
      lastActive=_context.clock().now();
      _lastJob=_currentJob;
      _currentJob=null;
      _lastEnd=lastActive;
      jobNum++;
      _state=15;
    }
 catch (    Throwable t) {
      if (_log.shouldLog(Log.CRIT))       _log.log(Log.CRIT,"WTF, error running?",t);
    }
  }
  _state=16;
  if (_context.router().isAlive())   if (_log.shouldLog(Log.CRIT))   _log.log(Log.CRIT,"Queue runner " + _id + " exiting");
  _context.jobQueue().removeRunner(_id);
  _state=17;
}
