{
  if (_context.getProperty(Router.PROP_SHUTDOWN_IN_PROGRESS) != null) {
    if (_log.shouldLog(Log.WARN))     _log.warn("Refusing tunnel request since we are shutting down ASAP");
    return TunnelHistory.TUNNEL_REJECT_CRIT;
  }
  long lag=_context.jobQueue().getMaxLag();
  RateStat rs=_context.statManager().getRate("transport.sendProcessingTime");
  Rate r=null;
  if (rs != null)   r=rs.getRate(60 * 1000);
  double processTime=(r != null ? r.getAverageValue() : 0);
  if (processTime > 2000) {
    if (_log.shouldLog(Log.DEBUG))     _log.debug("Refusing tunnel request with the job lag of " + lag + "since the 1 minute message processing time is too slow ("+ processTime+ ")");
    _context.statManager().addRateData("router.throttleTunnelProcessingTime1m",(long)processTime,(long)processTime);
    return TunnelHistory.TUNNEL_REJECT_TRANSIENT_OVERLOAD;
  }
  int numTunnels=_context.tunnelManager().getParticipatingCount();
  if (numTunnels > getMinThrottleTunnels()) {
    double growthFactor=getTunnelGrowthFactor();
    Rate avgTunnels=_context.statManager().getRate("tunnel.participatingTunnels").getRate(60 * 60 * 1000);
    if (avgTunnels != null) {
      double avg=0;
      if (avgTunnels.getLastEventCount() > 0)       avg=avgTunnels.getAverageValue();
 else       avg=avgTunnels.getLifetimeAverageValue();
      int min=getMinThrottleTunnels();
      if (avg < min)       avg=min;
      if ((avg > 0) && (avg * growthFactor < numTunnels)) {
        double probAccept=(avg * growthFactor) / numTunnels;
        int v=_context.random().nextInt(100);
        if (v < probAccept * 100) {
          if (_log.shouldLog(Log.INFO))           _log.info("Probabalistically accept tunnel request (p=" + probAccept + " v="+ v+ " avg="+ avg+ " current="+ numTunnels+ ")");
        }
 else {
          if (_log.shouldLog(Log.WARN))           _log.warn("Probabalistically refusing tunnel request (avg=" + avg + " current="+ numTunnels+ ")");
          _context.statManager().addRateData("router.throttleTunnelProbTooFast",(long)(numTunnels - avg),0);
          return TunnelHistory.TUNNEL_REJECT_PROBABALISTIC_REJECT;
        }
      }
 else {
        if (_log.shouldLog(Log.INFO))         _log.info("Accepting tunnel request, since the average is " + avg + " and we only have "+ numTunnels+ ")");
      }
    }
    Rate tunnelTestTime10m=_context.statManager().getRate("tunnel.testSuccessTime").getRate(10 * 60 * 1000);
    Rate tunnelTestTime60m=_context.statManager().getRate("tunnel.testSuccessTime").getRate(60 * 60 * 1000);
    if ((tunnelTestTime10m != null) && (tunnelTestTime60m != null) && (tunnelTestTime10m.getLastEventCount() > 0)) {
      double avg10m=tunnelTestTime10m.getAverageValue();
      double avg60m=0;
      if (tunnelTestTime60m.getLastEventCount() > 0)       avg60m=tunnelTestTime60m.getAverageValue();
 else       avg60m=tunnelTestTime60m.getLifetimeAverageValue();
      if (avg60m < 2000)       avg60m=2000;
      if ((avg60m > 0) && (avg10m > avg60m * growthFactor)) {
        double probAccept=(avg60m * growthFactor) / avg10m;
        int v=_context.random().nextInt(100);
        if (v < probAccept * 100) {
          if (_log.shouldLog(Log.INFO))           _log.info("Probabalistically accept tunnel request (p=" + probAccept + " v="+ v+ " test time avg 10m="+ avg10m+ " 60m="+ avg60m+ ")");
        }
 else {
          if (_log.shouldLog(Log.WARN))           _log.warn("Probabalistically refusing tunnel request (test time avg 10m=" + avg10m + " 60m="+ avg60m+ ")");
          _context.statManager().addRateData("router.throttleTunnelProbTestSlow",(long)(avg10m - avg60m),0);
          return TunnelHistory.TUNNEL_REJECT_PROBABALISTIC_REJECT;
        }
      }
    }
  }
  String maxTunnels=_context.getProperty(PROP_MAX_TUNNELS);
  if (maxTunnels != null) {
    try {
      int max=Integer.parseInt(maxTunnels);
      if (numTunnels >= max) {
        if (_log.shouldLog(Log.WARN))         _log.warn("Refusing tunnel request since we are already participating in " + numTunnels + " (our max is "+ max+ ")");
        _context.statManager().addRateData("router.throttleTunnelMaxExceeded",numTunnels,0);
        return TunnelHistory.TUNNEL_REJECT_BANDWIDTH;
      }
    }
 catch (    NumberFormatException nfe) {
    }
  }
  rs=_context.statManager().getRate("tunnel.participatingMessageCount");
  r=null;
  if (rs != null)   r=rs.getRate(10 * 60 * 1000);
  double messagesPerTunnel=(r != null ? r.getAverageValue() : 0d);
  if (messagesPerTunnel < DEFAULT_MESSAGES_PER_TUNNEL_ESTIMATE)   messagesPerTunnel=DEFAULT_MESSAGES_PER_TUNNEL_ESTIMATE;
  int participatingTunnels=(r != null ? (int)(r.getLastEventCount() + r.getCurrentEventCount()) : 0);
  if (participatingTunnels <= 0)   participatingTunnels=_context.tunnelManager().getParticipatingCount();
  double bytesAllocated=messagesPerTunnel * participatingTunnels * 1024;
  if (!allowTunnel(bytesAllocated,numTunnels)) {
    _context.statManager().addRateData("router.throttleTunnelBandwidthExceeded",(long)bytesAllocated,0);
    return TunnelHistory.TUNNEL_REJECT_BANDWIDTH;
  }
  _context.statManager().addRateData("tunnel.bytesAllocatedAtAccept",(long)bytesAllocated,60 * 10 * 1000);
  if (_log.shouldLog(Log.DEBUG))   _log.debug("Accepting a new tunnel request (now allocating " + bytesAllocated + " bytes across "+ numTunnels+ " tunnels with lag of "+ lag+ ")");
  return TUNNEL_ACCEPT;
}
