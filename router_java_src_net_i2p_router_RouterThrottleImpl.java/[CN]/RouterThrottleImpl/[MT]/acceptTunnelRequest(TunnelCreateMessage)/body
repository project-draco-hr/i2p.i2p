{
  long lag=_context.jobQueue().getMaxLag();
  RateStat rs=_context.statManager().getRate("router.throttleNetworkCause");
  Rate r=null;
  if (rs != null)   r=rs.getRate(10 * 60 * 1000);
  long throttleEvents=(r != null ? r.getCurrentEventCount() + r.getLastEventCount() : 0);
  if (throttleEvents > THROTTLE_EVENT_LIMIT) {
    if (_log.shouldLog(Log.DEBUG))     _log.debug("Refusing tunnel request with the job lag of " + lag + " since there have been "+ throttleEvents+ " throttle events in the last 15 minutes or so");
    _context.statManager().addRateData("router.throttleTunnelCause",lag,lag);
    return false;
  }
  rs=_context.statManager().getRate("transport.sendProcessingTime");
  r=null;
  if (rs != null)   r=rs.getRate(10 * 60 * 1000);
  double processTime=(r != null ? r.getAverageValue() : 0);
  if (processTime > 1000) {
    if (_log.shouldLog(Log.DEBUG))     _log.debug("Refusing tunnel request with the job lag of " + lag + "since the 10 minute message processing time is too slow ("+ processTime+ ")");
    _context.statManager().addRateData("router.throttleTunnelProcessingTime10m",(long)processTime,(long)processTime);
    return false;
  }
  if (rs != null)   r=rs.getRate(60 * 1000);
  processTime=(r != null ? r.getAverageValue() : 0);
  if (processTime > 2000) {
    if (_log.shouldLog(Log.DEBUG))     _log.debug("Refusing tunnel request with the job lag of " + lag + "since the 1 minute message processing time is too slow ("+ processTime+ ")");
    _context.statManager().addRateData("router.throttleTunnelProcessingTime1m",(long)processTime,(long)processTime);
    return false;
  }
  rs=_context.statManager().getRate("tunnel.participatingMessagesProcessed");
  r=null;
  if (rs != null)   r=rs.getRate(10 * 60 * 1000);
  double msgsPerTunnel=(r != null ? r.getAverageValue() : 0);
  r=null;
  rs=_context.statManager().getRate("tunnel.relayMessageSize");
  if (rs != null)   r=rs.getRate(10 * 60 * 1000);
  double bytesPerMsg=(r != null ? r.getAverageValue() : 0);
  double bytesPerTunnel=msgsPerTunnel * bytesPerMsg;
  int numTunnels=_context.tunnelManager().getParticipatingCount();
  double bytesAllocated=(numTunnels + 1) * bytesPerTunnel;
  String maxTunnels=_context.getProperty(PROP_MAX_TUNNELS);
  if (maxTunnels != null) {
    try {
      int max=Integer.parseInt(maxTunnels);
      if (numTunnels >= max) {
        if (_log.shouldLog(Log.WARN))         _log.warn("Refusing tunnel request since we are already participating in " + numTunnels + " (our max is "+ max+ ")");
        _context.statManager().addRateData("router.throttleTunnelMaxExceeded",numTunnels,0);
        return false;
      }
    }
 catch (    NumberFormatException nfe) {
    }
  }
  _context.statManager().addRateData("tunnel.bytesAllocatedAtAccept",(long)bytesAllocated,msg.getTunnelDurationSeconds() * 1000);
  if (_log.shouldLog(Log.DEBUG))   _log.debug("Accepting a new tunnel request (now allocating " + bytesAllocated + " bytes across "+ numTunnels+ " tunnels with lag of "+ lag+ " and "+ throttleEvents+ " throttle events)");
  return true;
}
