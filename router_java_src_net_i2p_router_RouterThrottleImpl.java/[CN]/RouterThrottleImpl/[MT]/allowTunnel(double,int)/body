{
  int maxKBps=Math.min(_context.bandwidthLimiter().getOutboundKBytesPerSecond(),_context.bandwidthLimiter().getInboundKBytesPerSecond());
  int used1s=0;
  int used1m=get1mRate(_context);
  int used5m=0;
  int used=Math.max(Math.max(used1s,used1m),used5m);
  int availBps=(int)(((maxKBps * 1024) - used) * getSharePercentage());
  _context.statManager().addRateData("router.throttleTunnelBytesUsed",used,maxKBps);
  _context.statManager().addRateData("router.throttleTunnelBytesAllowed",availBps,(long)bytesAllocated);
  double growthFactor=((double)(numTunnels + 1)) / (double)numTunnels;
  double toAllocate=(numTunnels > 0 ? bytesAllocated * growthFactor : 0);
  double allocatedBps=toAllocate / (10 * 60);
  double pctFull=allocatedBps / availBps;
  if ((pctFull < 1.0) && (pctFull >= 0.0)) {
    if (_log.shouldLog(Log.DEBUG))     _log.debug("Allowing the tunnel w/ " + pctFull + " of our "+ availBps+ "Bps/"+ allocatedBps+ "KBps allocated through "+ numTunnels+ " tunnels");
    return true;
  }
 else {
    double probAllow=availBps / (allocatedBps + availBps);
    boolean allow=_context.random().nextDouble() <= probAllow;
    if (allow) {
      if (_log.shouldLog(Log.INFO))       _log.info("Probabalistically allowing the tunnel w/ " + (pctFull * 100d) + "% of our "+ availBps+ "Bps allowed ("+ toAllocate+ "bytes / "+ allocatedBps+ "Bps) through "+ numTunnels+ " tunnels");
      return true;
    }
 else {
      if (_log.shouldLog(Log.WARN))       _log.warn("Rejecting the tunnel w/ " + (pctFull * 100d) + "% of our "+ availBps+ "Bps allowed ("+ toAllocate+ "bytes / "+ allocatedBps+ "Bps) through "+ numTunnels+ " tunnels");
      return false;
    }
  }
}
