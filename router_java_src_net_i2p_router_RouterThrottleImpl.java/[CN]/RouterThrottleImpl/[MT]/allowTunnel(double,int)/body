{
  int maxKBps=Math.min(_context.bandwidthLimiter().getOutboundKBytesPerSecond(),_context.bandwidthLimiter().getInboundKBytesPerSecond());
  int used1s=0;
  int used1m=get1mRate(_context);
  int used5m=get5mRate(_context);
  int used=Math.max(Math.max(used1s,used1m),used5m);
  int availBps=(int)(((maxKBps * 1024) - used) * getSharePercentage());
  _context.statManager().addRateData("router.throttleTunnelBytesUsed",used,maxKBps);
  _context.statManager().addRateData("router.throttleTunnelBytesAllowed",availBps,(long)bytesAllocated);
  if (availBps <= 8 * 1024) {
    return ((numTunnels + 1) * 1024 < availBps);
  }
  double growthFactor=((double)(numTunnels + 1)) / (double)numTunnels;
  double toAllocate=(numTunnels > 0 ? bytesAllocated * growthFactor : 0);
  double allocatedKBps=toAllocate / (10 * 60 * 1024);
  double pctFull=allocatedKBps / availBps;
  if ((pctFull < 1.0) && (pctFull >= 0.0)) {
    if (_log.shouldLog(Log.DEBUG))     _log.debug("Probabalistically allowing the tunnel w/ " + pctFull + " of our "+ availBps+ "Bps/"+ allocatedKBps+ "KBps allocated through "+ numTunnels+ " tunnels");
    return true;
  }
 else {
    if (_log.shouldLog(Log.WARN))     _log.warn("Rejecting the tunnel w/ " + pctFull + " of our "+ availBps+ "Bps allowed ("+ toAllocate+ "bytes / "+ allocatedKBps+ "KBps) through "+ numTunnels+ " tunnels");
    return false;
  }
}
