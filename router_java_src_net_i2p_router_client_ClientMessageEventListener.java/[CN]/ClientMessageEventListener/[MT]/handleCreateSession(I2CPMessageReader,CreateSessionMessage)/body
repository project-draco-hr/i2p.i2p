{
  if (message.getSessionConfig().verifySignature()) {
    if (_log.shouldLog(Log.DEBUG))     _log.debug("Signature verified correctly on create session message");
  }
 else {
    if (_log.shouldLog(Log.ERROR))     _log.error("Signature verification *FAILED* on a create session message.  Hijack attempt?");
    _runner.disconnectClient("Invalid signature on CreateSessionMessage");
    return;
  }
  if (_enforceAuth && Boolean.valueOf(_context.getProperty("i2cp.auth")).booleanValue()) {
    String configUser=_context.getProperty("i2cp.username");
    String configPW=_context.getProperty("i2cp.password");
    if (configUser != null && configPW != null) {
      Properties props=message.getSessionConfig().getOptions();
      String user=props.getProperty("i2cp.username");
      String pw=props.getProperty("i2cp.password");
      if (user == null || pw == null) {
        _log.error("I2CP auth failed for client: " + props.getProperty("inbound.nickname"));
        _runner.disconnectClient("Authorization required to create session, specify i2cp.username and i2cp.password in session options");
        return;
      }
      if ((!user.equals(configUser)) || (!pw.equals(configPW))) {
        _log.error("I2CP auth failed for client: " + props.getProperty("inbound.nickname") + " user: "+ user);
        _runner.disconnectClient("Authorization failed for Create Session, user = " + user);
        return;
      }
      if (_log.shouldLog(Log.INFO))       _log.info("I2CP auth success for client: " + props.getProperty("inbound.nickname") + " user: "+ user);
    }
  }
  SessionId sessionId=new SessionId();
  sessionId.setSessionId(getNextSessionId());
  _runner.setSessionId(sessionId);
  sendStatusMessage(SessionStatusMessage.STATUS_CREATED);
  _runner.sessionEstablished(message.getSessionConfig());
  if (_log.shouldLog(Log.DEBUG))   _log.debug("after sessionEstablished for " + message.getSessionConfig().getDestination().calculateHash().toBase64());
  _context.jobQueue().addJob(new CreateSessionJob(_context,_runner));
}
