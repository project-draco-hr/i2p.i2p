{
  if (_runner.isDead())   return;
  LeaseRequestState oldReq=_runner.getLeaseRequest();
  if (oldReq != null) {
    if (oldReq.getExpiration() > getContext().clock().now()) {
      _log.error("Old *current* leaseRequest already exists!  Why are we trying to request too quickly?",getAddedBy());
      return;
    }
 else {
      _log.error("Old *expired* leaseRequest exists!  Why did the old request not get killed? (expiration = " + new Date(oldReq.getExpiration()) + ")",getAddedBy());
    }
  }
  LeaseRequestState state=new LeaseRequestState(_onCreate,_onFail,_expiration,_ls);
  RequestLeaseSetMessage msg=new RequestLeaseSetMessage();
  Date end=null;
  for (int i=0; i < state.getRequested().getLeaseCount(); i++) {
    if ((end == null) || (end.getTime() > state.getRequested().getLease(i).getEndDate().getTime()))     end=state.getRequested().getLease(i).getEndDate();
  }
  msg.setEndDate(end);
  msg.setSessionId(_runner.getSessionId());
  for (int i=0; i < state.getRequested().getLeaseCount(); i++) {
    msg.addEndpoint(state.getRequested().getLease(i).getRouterIdentity(),state.getRequested().getLease(i).getTunnelId());
  }
  try {
    _runner.setLeaseRequest(state);
    _runner.doSend(msg);
    getContext().jobQueue().addJob(new CheckLeaseRequestStatus(state));
    return;
  }
 catch (  I2CPMessageException ime) {
    _log.error("Error sending I2CP message requesting the lease set",ime);
    state.setIsSuccessful(false);
    _runner.setLeaseRequest(null);
    _runner.disconnectClient("I2CP error requesting leaseSet");
    return;
  }
}
