{
  long excessLag=getContext().clock().now() - _message.getMessageExpiration().getTime();
  if (excessLag > Router.CLOCK_FUDGE_FACTOR) {
    if (_log.shouldLog(Log.WARN))     _log.warn("Accepted message (" + _message.getUniqueId() + ") expired on the queue for tunnel "+ id.getTunnelId()+ " expiring "+ excessLag+ "ms ago");
    getContext().statManager().addRateData("tunnel.expiredAfterAcceptTime",excessLag,excessLag);
    getContext().messageHistory().messageProcessingError(_message.getUniqueId(),TunnelMessage.class.getName(),"tunnel message expired on the queue");
    return null;
  }
 else   if (excessLag > 0) {
    if (_log.shouldLog(Log.WARN))     _log.warn("Accepted message (" + _message.getUniqueId() + ") *almost* expired on the queue for tunnel "+ id.getTunnelId()+ " expiring "+ excessLag+ "ms ago");
  }
 else {
  }
  TunnelInfo info=getContext().tunnelManager().getTunnelInfo(id);
  if (info == null) {
    Hash from=_fromHash;
    if (_from != null)     from=_from.getHash();
    getContext().messageHistory().droppedTunnelMessage(id,_message.getUniqueId(),_message.getMessageExpiration(),from);
    if (_log.shouldLog(Log.ERROR))     _log.error("Received a message for an unknown tunnel [" + id.getTunnelId() + "], dropping it: "+ _message,getAddedBy());
    long timeRemaining=_message.getMessageExpiration().getTime() - getContext().clock().now();
    getContext().statManager().addRateData("tunnel.unknownTunnelTimeLeft",timeRemaining,0);
    long lag=getTiming().getActualStart() - getTiming().getStartAfter();
    if (_log.shouldLog(Log.ERROR))     _log.error("Lag processing a dropped tunnel message: " + lag);
    return null;
  }
  info=getUs(info);
  if (info == null) {
    if (_log.shouldLog(Log.ERROR))     _log.error("We are not part of a known tunnel?? wtf!  drop.",getAddedBy());
    long timeRemaining=_message.getMessageExpiration().getTime() - getContext().clock().now();
    getContext().statManager().addRateData("tunnel.unknownTunnelTimeLeft",timeRemaining,0);
    return null;
  }
  return info;
}
