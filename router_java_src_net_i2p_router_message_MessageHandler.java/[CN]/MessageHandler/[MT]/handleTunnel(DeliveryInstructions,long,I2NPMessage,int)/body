{
  Hash to=instructions.getRouter();
  long timeoutMs=expiration - _context.clock().now();
  TunnelId tunnelId=instructions.getTunnelId();
  if (!_context.routerHash().equals(to)) {
    boolean valid=_context.messageValidator().validateMessage(message.getUniqueId(),message.getMessageExpiration().getTime());
    if (!valid) {
      if (_log.shouldLog(Log.WARN))       _log.warn("Duplicate / expired tunnel message received [" + message.getUniqueId() + " expiring on "+ message.getMessageExpiration()+ "]");
      _context.messageHistory().droppedOtherMessage(message);
      _context.messageHistory().messageProcessingError(message.getUniqueId(),message.getClass().getName(),"Duplicate/expired");
      return;
    }
  }
  if (_log.shouldLog(Log.INFO))   _log.info("Handle " + message.getClass().getName() + " to send to remote tunnel "+ tunnelId.getTunnelId()+ " on router "+ to.toBase64());
  TunnelMessage msg=new TunnelMessage(_context);
  ByteArrayOutputStream baos=new ByteArrayOutputStream(1024);
  try {
    message.writeBytes(baos);
    msg.setData(baos.toByteArray());
    msg.setTunnelId(tunnelId);
    if (_log.shouldLog(Log.DEBUG))     _log.debug("Placing message of type " + message.getClass().getName() + " into the new tunnel message bound for "+ tunnelId.getTunnelId()+ " on "+ to.toBase64());
    _context.jobQueue().addJob(new SendMessageDirectJob(_context,msg,to,expiration,priority));
    String bodyType=message.getClass().getName();
    _context.messageHistory().wrap(bodyType,message.getUniqueId(),TunnelMessage.class.getName(),msg.getUniqueId());
  }
 catch (  Exception e) {
    _log.warn("Unable to forward on according to the instructions to the remote tunnel",e);
  }
}
