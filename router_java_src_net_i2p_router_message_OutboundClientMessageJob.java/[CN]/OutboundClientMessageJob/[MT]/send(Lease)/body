{
  long token=RandomSource.getInstance().nextInt(Integer.MAX_VALUE);
  PublicKey key=_status.getLeaseSet().getEncryptionKey();
  SessionKey sessKey=new SessionKey();
  Set tags=new HashSet();
  GarlicMessage msg=OutboundClientMessageJobHelper.createGarlicMessage(token,_overallExpiration,key,_status.getClove(),_status.getTo(),sessKey,tags,true);
  if (_log.shouldLog(Log.DEBUG))   _log.debug("send(lease) - token expected " + token);
  _status.sent(lease.getRouterIdentity().getHash(),lease.getTunnelId());
  SendSuccessJob onReply=new SendSuccessJob(lease,sessKey,tags);
  SendTimeoutJob onFail=new SendTimeoutJob(lease);
  ReplySelector selector=new ReplySelector(token);
  if (_log.shouldLog(Log.DEBUG))   _log.debug("Placing GarlicMessage into the new tunnel message bound for " + lease.getTunnelId() + " on "+ lease.getRouterIdentity().getHash().toBase64());
  TunnelId outTunnelId=selectOutboundTunnel();
  if (outTunnelId != null) {
    if (_log.shouldLog(Log.DEBUG))     _log.debug("Sending tunnel message out " + outTunnelId + " to "+ lease.getTunnelId()+ " on "+ lease.getRouterIdentity().getHash().toBase64());
    SendTunnelMessageJob j=new SendTunnelMessageJob(msg,outTunnelId,lease.getRouterIdentity().getHash(),lease.getTunnelId(),null,onReply,onFail,selector,SEND_TIMEOUT_MS,SEND_PRIORITY);
    JobQueue.getInstance().addJob(j);
  }
 else {
    if (_log.shouldLog(Log.ERROR))     _log.error("Could not find any outbound tunnels to send the payload through... wtf?");
    JobQueue.getInstance().addJob(onFail);
  }
}
