{
  Log log=ctx.logManager().getLog(OutboundClientMessageJobHelper.class);
  PayloadGarlicConfig ackClove=new PayloadGarlicConfig();
  if (replyToTunnel == null) {
    if (log.shouldLog(Log.WARN))     log.warn("Unable to send client message from " + from.toBase64() + ", as there are no inbound tunnels available");
    return null;
  }
  TunnelId replyToTunnelId=replyToTunnel.getReceiveTunnelId(0);
  Hash replyToTunnelRouter=replyToTunnel.getPeer(0);
  if (log.shouldLog(Log.DEBUG))   log.debug("Ack for the data message will come back along tunnel " + replyToTunnelId + ": "+ replyToTunnel);
  DeliveryInstructions ackInstructions=new DeliveryInstructions();
  ackInstructions.setDeliveryMode(DeliveryInstructions.DELIVERY_MODE_TUNNEL);
  ackInstructions.setRouter(replyToTunnelRouter);
  ackInstructions.setTunnelId(replyToTunnelId);
  DeliveryStatusMessage msg=new DeliveryStatusMessage(ctx);
  msg.setArrival(ctx.clock().now());
  msg.setMessageId(replyToken);
  ackClove.setCertificate(Certificate.NULL_CERT);
  ackClove.setDeliveryInstructions(ackInstructions);
  ackClove.setExpiration(expiration);
  ackClove.setId(ctx.random().nextLong(I2NPMessage.MAX_ID_VALUE));
  ackClove.setPayload(msg);
  ackClove.setRecipient(ctx.router().getRouterInfo());
  return ackClove;
}
