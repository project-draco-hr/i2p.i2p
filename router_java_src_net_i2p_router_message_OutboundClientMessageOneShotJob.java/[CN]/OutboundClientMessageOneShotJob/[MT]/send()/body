{
  if (_finished)   return;
  long now=getContext().clock().now();
  if (now >= _overallExpiration) {
    dieFatal();
    return;
  }
  int existingTags=GarlicMessageBuilder.estimateAvailableTags(getContext(),_leaseSet.getEncryptionKey(),_from.calculateHash());
  _outTunnel=selectOutboundTunnel(_to);
  boolean wantACK;
  Long lastSent=_cache.lastReplyRequestCache.get(_hashPair);
  wantACK=_wantACK || existingTags <= 30 || lastSent == null || lastSent.longValue() < now - REPLY_REQUEST_INTERVAL;
  if (wantACK)   _cache.lastReplyRequestCache.put(_hashPair,Long.valueOf(now));
  PublicKey key=_leaseSet.getEncryptionKey();
  SessionKey sessKey=new SessionKey();
  Set<SessionTag> tags=new HashSet();
  LeaseSet replyLeaseSet=getReplyLeaseSet(wantACK);
  if (replyLeaseSet != null)   wantACK=true;
  long token=(wantACK ? getContext().random().nextLong(I2NPMessage.MAX_ID_VALUE) : -1);
  if (wantACK)   _inTunnel=selectInboundTunnel();
  boolean ok=(_clientMessage != null) && buildClove();
  if (!ok) {
    dieFatal();
    return;
  }
  long msgExpiration=_overallExpiration;
  GarlicMessage msg=OutboundClientMessageJobHelper.createGarlicMessage(getContext(),token,msgExpiration,key,_clove,_from.calculateHash(),_to,_inTunnel,sessKey,tags,wantACK,replyLeaseSet);
  if (msg == null) {
    if (_log.shouldLog(Log.WARN))     _log.warn(getJobId() + ": Unable to create the garlic message (no tunnels left or too lagged) to " + _toString);
    getContext().statManager().addRateData("client.dispatchNoTunnels",now - _start,0);
    dieFatal();
    return;
  }
  SendSuccessJob onReply=null;
  SendTimeoutJob onFail=null;
  ReplySelector selector=null;
  if (wantACK) {
    TagSetHandle tsh=null;
    if ((sessKey != null) && (tags != null) && (!tags.isEmpty())) {
      if (_leaseSet != null) {
        SessionKeyManager skm=getContext().clientManager().getClientSessionKeyManager(_from.calculateHash());
        if (skm != null)         tsh=skm.tagsDelivered(_leaseSet.getEncryptionKey(),sessKey,tags);
      }
    }
    onReply=new SendSuccessJob(getContext(),sessKey,tsh);
    onFail=new SendTimeoutJob(getContext(),sessKey,tsh);
    selector=new ReplySelector(token);
  }
  if (_log.shouldLog(Log.DEBUG))   _log.debug(getJobId() + ": GarlicMessage in new tunnel msg for " + _toString+ " at "+ _lease.getTunnelId()+ " on "+ _lease.getGateway());
  if (_outTunnel != null) {
    if (_log.shouldLog(Log.DEBUG))     _log.debug(getJobId() + ": Sending msg out " + _outTunnel.getSendTunnelId(0)+ " to "+ _toString+ " at "+ _lease.getTunnelId()+ " on "+ _lease.getGateway());
    DispatchJob dispatchJob=new DispatchJob(getContext(),msg,selector,onReply,onFail,(int)(_overallExpiration - getContext().clock().now()));
    dispatchJob.runJob();
  }
 else {
    if (_log.shouldLog(Log.WARN))     _log.warn(getJobId() + ": Could not find any outbound tunnels to send the payload through... this might take a while");
    getContext().statManager().addRateData("client.dispatchNoTunnels",now - _start,0);
    dieFatal();
  }
  _clove=null;
  getContext().statManager().addRateData("client.dispatchPrepareTime",now - _start,0);
  if (!wantACK)   getContext().statManager().addRateData("client.dispatchNoACK",1,0);
}
