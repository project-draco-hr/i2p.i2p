{
  if (_finished)   return;
  if (getContext().clock().now() >= _overallExpiration) {
    dieFatal();
    return;
  }
  boolean wantACK=true;
  int existingTags=GarlicMessageBuilder.estimateAvailableTags(getContext(),_leaseSet.getEncryptionKey());
  if (existingTags > 30)   wantACK=false;
  long token=(wantACK ? getContext().random().nextLong(I2NPMessage.MAX_ID_VALUE) : -1);
  PublicKey key=_leaseSet.getEncryptionKey();
  SessionKey sessKey=new SessionKey();
  Set tags=new HashSet();
  LeaseSet replyLeaseSet=null;
  if (_shouldBundle) {
    replyLeaseSet=getContext().netDb().lookupLeaseSetLocally(_from.calculateHash());
  }
  if (wantACK)   _inTunnel=selectInboundTunnel();
  boolean ok=(_clientMessage != null) && buildClove();
  if (!ok) {
    dieFatal();
    return;
  }
  if (_log.shouldLog(Log.DEBUG))   _log.debug(getJobId() + ": Clove built to " + _toString);
  long msgExpiration=_overallExpiration;
  GarlicMessage msg=OutboundClientMessageJobHelper.createGarlicMessage(getContext(),token,msgExpiration,key,_clove,_from.calculateHash(),_to,_inTunnel,sessKey,tags,wantACK,replyLeaseSet);
  if (msg == null) {
    if (_log.shouldLog(Log.WARN))     _log.warn(getJobId() + ": Unable to create the garlic message (no tunnels left or too lagged) to " + _toString);
    getContext().statManager().addRateData("client.dispatchNoTunnels",getContext().clock().now() - _start,0);
    dieFatal();
    return;
  }
  if (_log.shouldLog(Log.DEBUG))   _log.debug(getJobId() + ": send() - token expected " + token+ " to "+ _toString);
  SendSuccessJob onReply=null;
  SendTimeoutJob onFail=null;
  ReplySelector selector=null;
  if (wantACK) {
    onReply=new SendSuccessJob(getContext(),sessKey,tags);
    onFail=new SendTimeoutJob(getContext());
    selector=new ReplySelector(token);
  }
  if (_log.shouldLog(Log.DEBUG))   _log.debug(getJobId() + ": Placing GarlicMessage into the new tunnel message bound for " + _toString+ " at "+ _lease.getTunnelId()+ " on "+ _lease.getGateway().toBase64());
  _outTunnel=selectOutboundTunnel();
  if (_outTunnel != null) {
    if (_log.shouldLog(Log.DEBUG))     _log.debug(getJobId() + ": Sending tunnel message out " + _outTunnel.getSendTunnelId(0)+ " to "+ _toString+ " at "+ _lease.getTunnelId()+ " on "+ _lease.getGateway().toBase64());
    DispatchJob dispatchJob=new DispatchJob(getContext(),msg,selector,onReply,onFail,(int)(_overallExpiration - getContext().clock().now()));
    if (false)     getContext().jobQueue().addJob(dispatchJob);
 else     dispatchJob.runJob();
  }
 else {
    if (_log.shouldLog(Log.WARN))     _log.warn(getJobId() + ": Could not find any outbound tunnels to send the payload through... this might take a while");
    getContext().statManager().addRateData("client.dispatchNoTunnels",getContext().clock().now() - _start,0);
    dieFatal();
  }
  _clientMessage=null;
  _clove=null;
  getContext().statManager().addRateData("client.dispatchPrepareTime",getContext().clock().now() - _start,0);
  if (!wantACK)   getContext().statManager().addRateData("client.dispatchNoACK",1,0);
}
