{
  List floodfillPeers=_facade.getFloodfillPeers();
  if (floodfillPeers.size() <= 3)   _shouldProcessDSRM=true;
  if (floodfillPeers.size() <= 0) {
    if (_log.shouldLog(Log.WARN))     _log.warn("Running netDb searches against the floodfill peers, but we don't know any");
    floodfillPeers=new ArrayList(_facade.getAllRouters());
    if (floodfillPeers.size() <= 0) {
      if (_log.shouldLog(Log.ERROR))       _log.error("We don't know any peers at all");
      failed();
      return;
    }
  }
  OutNetMessage out=getContext().messageRegistry().registerPending(_replySelector,_onReply,_onTimeout,_timeoutMs);
synchronized (_out) {
    _out.add(out);
  }
  if (floodfillPeers.size() > CONCURRENT_SEARCHES) {
    Collections.shuffle(floodfillPeers,getContext().random());
    List ffp=new ArrayList(floodfillPeers.size());
    int failcount=0;
    long before=getContext().clock().now() - 30 * 60 * 1000;
    for (int i=0; i < floodfillPeers.size(); i++) {
      Hash peer=(Hash)floodfillPeers.get(i);
      PeerProfile profile=getContext().profileOrganizer().getProfile(peer);
      if (profile == null || profile.getLastHeardFrom() < before || profile.getIsFailing() || getContext().shitlist().isShitlisted(peer) || getContext().commSystem().wasUnreachable(peer)) {
        failcount++;
        ffp.add(peer);
      }
 else       ffp.add(0,peer);
    }
    if (floodfillPeers.size() - failcount <= 2)     _shouldProcessDSRM=true;
    if (_log.shouldLog(Log.INFO) && failcount > 0)     _log.info(getJobId() + ": " + failcount+ " of "+ floodfillPeers.size()+ " floodfills are not heard from, unprofiled, failing, unreachable or shitlisted");
    floodfillPeers=ffp;
  }
 else {
    _shouldProcessDSRM=true;
  }
  int count=0;
  for (int i=0; _lookupsRemaining < CONCURRENT_SEARCHES && i < floodfillPeers.size(); i++) {
    Hash peer=(Hash)floodfillPeers.get(i);
    if (peer.equals(getContext().routerHash()))     continue;
    DatabaseLookupMessage dlm=new DatabaseLookupMessage(getContext(),true);
    TunnelInfo replyTunnel=getContext().tunnelManager().selectInboundTunnel();
    TunnelInfo outTunnel=getContext().tunnelManager().selectOutboundTunnel();
    if ((replyTunnel == null) || (outTunnel == null)) {
      failed();
      return;
    }
synchronized (_unheardFrom) {
      _unheardFrom.add(peer);
    }
    dlm.setFrom(replyTunnel.getPeer(0));
    dlm.setMessageExpiration(getContext().clock().now() + 10 * 1000);
    dlm.setReplyTunnel(replyTunnel.getReceiveTunnelId(0));
    dlm.setSearchKey(_key);
    if (_log.shouldLog(Log.INFO))     _log.info(getJobId() + ": Floodfill search for " + _key.toBase64()+ " to "+ peer.toBase64());
    getContext().tunnelDispatcher().dispatchOutbound(dlm,outTunnel.getSendTunnelId(0),peer);
    count++;
    _lookupsRemaining++;
  }
  if (count <= 0) {
    if (_log.shouldLog(Log.INFO))     _log.info(getJobId() + ": Floodfill search for " + _key.toBase64()+ " had no peers to send to");
    failed();
  }
}
