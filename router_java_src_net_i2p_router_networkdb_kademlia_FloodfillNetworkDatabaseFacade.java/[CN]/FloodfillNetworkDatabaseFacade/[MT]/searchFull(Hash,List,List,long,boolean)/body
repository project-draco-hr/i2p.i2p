{
synchronized (_activeFloodQueries) {
    _activeFloodQueries.remove(key);
  }
  Job find=null;
  Job fail=null;
  if (onFind != null) {
synchronized (onFind) {
      if (onFind.size() > 0)       find=(Job)onFind.remove(0);
    }
  }
  if (onFailed != null) {
synchronized (onFailed) {
      if (onFailed.size() > 0)       fail=(Job)onFailed.remove(0);
    }
  }
  SearchJob job=super.search(key,find,fail,timeoutMs,isLease);
  if (job != null) {
    if (_log.shouldLog(Log.INFO))     _log.info("Floodfill search timed out for " + key.toBase64() + ", falling back on normal search (#"+ job.getJobId()+ ") with "+ timeoutMs+ " remaining");
    long expiration=timeoutMs + _context.clock().now();
    List removed=null;
    if (onFind != null) {
synchronized (onFind) {
        removed=new ArrayList(onFind);
        onFind.clear();
      }
      for (int i=0; i < removed.size(); i++)       job.addDeferred((Job)removed.get(i),null,expiration,isLease);
      removed=null;
    }
    if (onFailed != null) {
synchronized (onFailed) {
        removed=new ArrayList(onFailed);
        onFailed.clear();
      }
      for (int i=0; i < removed.size(); i++)       job.addDeferred(null,(Job)removed.get(i),expiration,isLease);
      removed=null;
    }
  }
}
