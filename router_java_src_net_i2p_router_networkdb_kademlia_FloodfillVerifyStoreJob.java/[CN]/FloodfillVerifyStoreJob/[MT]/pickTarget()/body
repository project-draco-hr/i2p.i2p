{
  Hash rkey=getContext().routingKeyGenerator().getRoutingKey(_key);
  FloodfillPeerSelector sel=(FloodfillPeerSelector)_facade.getPeerSelector();
  boolean isKeyCert=false;
  if (!_isRouterInfo) {
    LeaseSet ls=_facade.lookupLeaseSetLocally(_key);
    if (ls != null && ls.getDestination().getCertificate().getCertificateType() == Certificate.CERTIFICATE_TYPE_KEY)     isKeyCert=true;
  }
  if (isKeyCert) {
    while (true) {
      List<Hash> peers=sel.selectFloodfillParticipants(rkey,1,_ignore,_facade.getKBuckets());
      if (peers.isEmpty())       break;
      Hash peer=peers.get(0);
      RouterInfo ri=_facade.lookupRouterInfoLocally(peer);
      if (ri != null && StoreJob.supportsKeyCerts(ri))       return peer;
      if (_log.shouldLog(Log.INFO))       _log.info(getJobId() + ": Skipping verify w/ router that doesn't support key certs " + peer);
      _ignore.add(peer);
    }
  }
 else {
    List<Hash> peers=sel.selectFloodfillParticipants(rkey,1,_ignore,_facade.getKBuckets());
    if (!peers.isEmpty())     return peers.get(0);
  }
  if (_log.shouldLog(Log.WARN))   _log.warn("No other peers to verify floodfill with, using the one we sent to");
  return _sentTo;
}
