{
  DatabaseLookupMessage dlm=new DatabaseLookupMessage(getContext(),true);
  TunnelManagerFacade tm=getContext().tunnelManager();
  TunnelInfo outTunnel;
  TunnelInfo replyTunnel;
  boolean isClientReplyTunnel;
  if (_fromLocalDest != null) {
    outTunnel=tm.selectOutboundTunnel(_fromLocalDest,peer);
    if (outTunnel == null)     outTunnel=tm.selectOutboundExploratoryTunnel(peer);
    replyTunnel=tm.selectInboundTunnel(_fromLocalDest,peer);
    isClientReplyTunnel=replyTunnel != null;
    if (!isClientReplyTunnel)     replyTunnel=tm.selectInboundExploratoryTunnel(peer);
  }
 else {
    outTunnel=tm.selectOutboundExploratoryTunnel(peer);
    replyTunnel=tm.selectInboundExploratoryTunnel(peer);
    isClientReplyTunnel=false;
  }
  if ((replyTunnel == null) || (outTunnel == null)) {
    failed();
    return;
  }
  if (outTunnel.getLength() <= 1 && peer.equals(_key)) {
    failed(peer,false);
    return;
  }
  dlm.setFrom(replyTunnel.getPeer(0));
  dlm.setMessageExpiration(getContext().clock().now() + SINGLE_SEARCH_MSG_TIME);
  dlm.setReplyTunnel(replyTunnel.getReceiveTunnelId(0));
  dlm.setSearchKey(_key);
  if (_log.shouldLog(Log.INFO)) {
    int tries;
synchronized (this) {
      tries=_unheardFrom.size() + _failedPeers.size();
    }
    _log.info(getJobId() + ": ISJ try " + tries+ " for "+ _key+ " to "+ peer+ " reply via client tunnel? "+ isClientReplyTunnel);
  }
  long now=getContext().clock().now();
  _sentTime.put(peer,Long.valueOf(now));
  I2NPMessage outMsg=null;
  if (_isLease || getContext().getBooleanProperty(PROP_ENCRYPT_RI)) {
    RouterInfo ri=getContext().netDb().lookupRouterInfoLocally(peer);
    if (ri != null) {
      if (DatabaseLookupMessage.supportsEncryptedReplies(ri)) {
        MessageWrapper.OneTimeSession sess;
        if (isClientReplyTunnel)         sess=MessageWrapper.generateSession(getContext(),_fromLocalDest);
 else         sess=MessageWrapper.generateSession(getContext());
        if (_log.shouldLog(Log.INFO))         _log.info(getJobId() + ": Requesting encrypted reply from " + peer+ ' '+ sess.key+ ' '+ sess.tag);
        dlm.setReplySession(sess.key,sess.tag);
      }
      outMsg=MessageWrapper.wrap(getContext(),dlm,ri);
      if (_dead) {
        if (_log.shouldLog(Log.DEBUG))         _log.debug(getJobId() + ": aborting send, finished while wrapping msg to " + peer);
        return;
      }
      if (_log.shouldLog(Log.DEBUG))       _log.debug(getJobId() + ": Encrypted DLM for " + _key+ " to "+ peer);
    }
  }
  if (outMsg == null)   outMsg=dlm;
  getContext().tunnelDispatcher().dispatchOutbound(outMsg,outTunnel.getSendTunnelId(0),peer);
  Job j=new IterativeTimeoutJob(getContext(),peer,this);
  long expire=Math.min(_expiration,now + SINGLE_SEARCH_TIME);
  j.getTiming().setStartAfter(expire);
  getContext().jobQueue().addJob(j);
}
