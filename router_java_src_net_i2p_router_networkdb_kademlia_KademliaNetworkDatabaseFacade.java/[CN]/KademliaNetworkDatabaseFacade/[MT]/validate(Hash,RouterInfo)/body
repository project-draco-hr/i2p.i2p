{
  long now=_context.clock().now();
  if (!key.equals(routerInfo.getIdentity().getHash())) {
    _log.error("Invalid store attempt! key does not match routerInfo.identity!  key = " + key + ", router = "+ routerInfo);
    return false;
  }
 else   if (!routerInfo.isValid()) {
    _log.error("Invalid routerInfo signature!  forged router structure!  router = " + routerInfo);
    return false;
  }
 else   if (!routerInfo.isCurrent(ExpireRoutersJob.EXPIRE_DELAY)) {
    int existing=_kb.size();
    if (existing >= MIN_REMAINING_ROUTERS) {
      if (_log.shouldLog(Log.INFO))       _log.info("Not storing expired router for " + key.toBase64(),new Exception("Rejecting store"));
      return false;
    }
 else {
      if (_log.shouldLog(Log.WARN))       _log.warn("Even though the peer is old, we have only " + existing + " peers left (curPeer: "+ key.toBase64()+ " published on "+ new Date(routerInfo.getPublished()));
    }
  }
 else   if (routerInfo.getPublished() > now + Router.CLOCK_FUDGE_FACTOR) {
    if (_log.shouldLog(Log.WARN))     _log.warn("Peer " + key.toBase64() + " published their routerInfo in the future?! ["+ new Date(routerInfo.getPublished())+ "]",new Exception("Rejecting store"));
    return false;
  }
  return true;
}
