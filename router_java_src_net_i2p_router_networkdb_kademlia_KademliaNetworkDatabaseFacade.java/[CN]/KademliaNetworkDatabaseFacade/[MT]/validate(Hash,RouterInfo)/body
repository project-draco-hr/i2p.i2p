{
  long now=_context.clock().now();
  if (!key.equals(routerInfo.getIdentity().getHash())) {
    if (_log.shouldLog(Log.WARN))     _log.warn("Invalid store attempt! key does not match routerInfo.identity!  key = " + key + ", router = "+ routerInfo);
    return "Key does not match routerInfo.identity - " + key.toBase64();
  }
 else   if (!routerInfo.isValid()) {
    if (_log.shouldLog(Log.WARN))     _log.warn("Invalid routerInfo signature!  forged router structure!  router = " + routerInfo);
    return "Invalid routerInfo signature on " + key.toBase64();
  }
 else   if (!routerInfo.isCurrent(Router.CLOCK_FUDGE_FACTOR + ExpireRoutersJob.EXPIRE_DELAY)) {
    long age=_context.clock().now() - routerInfo.getPublished();
    int existing=_kb.size();
    if (existing >= MIN_REMAINING_ROUTERS) {
      if (_log.shouldLog(Log.INFO))       _log.info("Not storing expired router for " + key.toBase64(),new Exception("Rejecting store"));
      return "Peer " + key.toBase64() + " expired "+ DataHelper.formatDuration(age)+ "ms ago";
    }
 else {
      if (_log.shouldLog(Log.WARN))       _log.warn("Even though the peer is old, we have only " + existing + " peers left (curPeer: "+ key.toBase64()+ " published on "+ new Date(routerInfo.getPublished()));
    }
  }
 else   if (routerInfo.getPublished() > now + Router.CLOCK_FUDGE_FACTOR) {
    long age=routerInfo.getPublished() - _context.clock().now();
    if (_log.shouldLog(Log.WARN))     _log.warn("Peer " + key.toBase64() + " published their routerInfo in the future?! ["+ new Date(routerInfo.getPublished())+ "]",new Exception("Rejecting store"));
    return "Peer " + key.toBase64() + " published "+ DataHelper.formatDuration(age)+ " in the future?!";
  }
  return null;
}
