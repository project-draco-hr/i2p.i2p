{
  if (_state.completed()) {
    if (_log.shouldLog(Log.DEBUG))     _log.debug(getJobId() + ": Search already completed",new Exception("already completed"));
    return;
  }
  int toCheck=getBredth() - _state.getPending().size();
  if (toCheck <= 0) {
    if (_log.shouldLog(Log.INFO))     _log.info(getJobId() + ": Too many searches already pending (pending: " + _state.getPending().size()+ " max: "+ getBredth()+ ")");
    requeuePending();
    return;
  }
  List closestHashes=getClosestRouters(_state.getTarget(),toCheck,_state.getAttempted());
  if ((closestHashes == null) || (closestHashes.size() <= 0)) {
    if (_state.getPending().size() <= 0) {
      if (_log.shouldLog(Log.INFO))       _log.info(getJobId() + ": No peers left, and none pending!  Already searched: " + _state.getAttempted().size()+ " failed: "+ _state.getFailed().size());
      fail();
    }
 else {
      if (_log.shouldLog(Log.INFO))       _log.info(getJobId() + ": No peers left, but some are pending!  Pending: " + _state.getPending().size()+ " attempted: "+ _state.getAttempted().size()+ " failed: "+ _state.getFailed().size());
      requeuePending();
      return;
    }
  }
 else {
    _state.addPending(closestHashes);
    for (Iterator iter=closestHashes.iterator(); iter.hasNext(); ) {
      Hash peer=(Hash)iter.next();
      DataStructure ds=_facade.getDataStore().get(peer);
      if ((ds == null) || !(ds instanceof RouterInfo)) {
        if (_log.shouldLog(Log.WARN))         _log.warn(getJobId() + ": Error selecting closest hash that wasnt a router! " + peer+ " : "+ (ds == null ? "null" : ds.getClass().getName()));
      }
 else {
        sendSearch((RouterInfo)ds);
      }
    }
  }
}
