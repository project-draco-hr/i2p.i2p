{
  DeliveryStatusMessage ackMsg=new DeliveryStatusMessage();
  ackMsg.setArrival(new Date(Clock.getInstance().now()));
  ackMsg.setMessageId(ackId);
  ackMsg.setMessageExpiration(new Date(expiration));
  ackMsg.setUniqueId(RandomSource.getInstance().nextInt(Integer.MAX_VALUE));
  PayloadGarlicConfig ackClove=new PayloadGarlicConfig();
  TunnelSelectionCriteria criteria=new TunnelSelectionCriteria();
  criteria.setAnonymityPriority(80);
  criteria.setLatencyPriority(20);
  criteria.setReliabilityPriority(50);
  criteria.setMaximumTunnelsRequired(1);
  criteria.setMinimumTunnelsRequired(1);
  List tunnelIds=TunnelManagerFacade.getInstance().selectInboundTunnelIds(criteria);
  if (tunnelIds.size() <= 0) {
    _log.error("No inbound tunnels exist for a db store ack to come through!");
    return null;
  }
  TunnelId replyToTunnelId=(TunnelId)tunnelIds.get(0);
  TunnelInfo info=TunnelManagerFacade.getInstance().getTunnelInfo(replyToTunnelId);
  RouterInfo replyPeer=NetworkDatabaseFacade.getInstance().lookupRouterInfoLocally(info.getThisHop());
  if (replyPeer == null) {
    _log.error("We don't know how to reach the gateway of our own inbound tunnel?! " + info);
    return null;
  }
  Hash replyToTunnelRouter=replyPeer.getIdentity().getHash();
  DeliveryInstructions ackInstructions=new DeliveryInstructions();
  ackInstructions.setDeliveryMode(DeliveryInstructions.DELIVERY_MODE_TUNNEL);
  ackInstructions.setRouter(replyToTunnelRouter);
  ackInstructions.setTunnelId(replyToTunnelId);
  ackInstructions.setDelayRequested(false);
  ackInstructions.setDelaySeconds(0);
  ackInstructions.setEncrypted(false);
  ackClove.setCertificate(new Certificate(Certificate.CERTIFICATE_TYPE_NULL,null));
  ackClove.setDeliveryInstructions(ackInstructions);
  ackClove.setExpiration(_expiration);
  ackClove.setId(RandomSource.getInstance().nextInt(Integer.MAX_VALUE));
  ackClove.setPayload(ackMsg);
  ackClove.setRecipient(replyPeer);
  ackClove.setRequestAck(false);
  return ackClove;
}
