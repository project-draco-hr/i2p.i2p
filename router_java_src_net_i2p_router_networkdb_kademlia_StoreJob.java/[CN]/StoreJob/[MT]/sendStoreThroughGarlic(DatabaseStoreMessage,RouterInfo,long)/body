{
  long token=getContext().random().nextLong(I2NPMessage.MAX_ID_VALUE);
  TunnelInfo replyTunnel=selectInboundTunnel();
  if (replyTunnel == null) {
    _log.warn("No reply inbound tunnels available!");
    return;
  }
  TunnelId replyTunnelId=replyTunnel.getReceiveTunnelId(0);
  if (replyTunnel == null) {
    _log.warn("No reply inbound tunnels available!");
    return;
  }
  msg.setReplyToken(token);
  msg.setReplyTunnel(replyTunnelId);
  msg.setReplyGateway(replyTunnel.getPeer(0));
  if (_log.shouldLog(Log.DEBUG))   _log.debug(getJobId() + ": send(dbStore) w/ token expected " + token);
  _state.addPending(peer.getIdentity().getHash());
  TunnelInfo outTunnel=selectOutboundTunnel();
  if (outTunnel != null) {
    TunnelId targetTunnelId=null;
    Job onSend=null;
    SendSuccessJob onReply=new SendSuccessJob(getContext(),peer,outTunnel,msg.getMessageSize());
    FailedJob onFail=new FailedJob(getContext(),peer,getContext().clock().now());
    StoreMessageSelector selector=new StoreMessageSelector(getContext(),getJobId(),peer,token,expiration);
    if (_log.shouldLog(Log.DEBUG))     _log.debug("sending store to " + peer.getIdentity().getHash() + " through "+ outTunnel+ ": "+ msg);
    getContext().messageRegistry().registerPending(selector,onReply,onFail,(int)(expiration - getContext().clock().now()));
    getContext().tunnelDispatcher().dispatchOutbound(msg,outTunnel.getSendTunnelId(0),null,peer.getIdentity().getHash());
  }
 else {
    if (_log.shouldLog(Log.WARN))     _log.warn("No outbound tunnels to send a dbStore out!");
    fail();
  }
}
