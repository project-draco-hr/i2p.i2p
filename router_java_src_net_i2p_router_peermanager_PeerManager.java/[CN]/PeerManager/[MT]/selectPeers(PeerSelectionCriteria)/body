{
  Set peers=new HashSet(criteria.getMinimumRequired());
  Set exclude=new HashSet(1);
  exclude.add(_context.routerHash());
switch (criteria.getPurpose()) {
case PeerSelectionCriteria.PURPOSE_TEST:
    _organizer.selectActiveNotFailingPeers(criteria.getMinimumRequired(),exclude,peers);
  break;
case PeerSelectionCriteria.PURPOSE_TUNNEL:
_organizer.selectFastPeers(criteria.getMaximumRequired(),exclude,peers);
break;
case PeerSelectionCriteria.PURPOSE_SOURCE_ROUTE:
_organizer.selectHighCapacityPeers(criteria.getMinimumRequired(),exclude,peers);
break;
case PeerSelectionCriteria.PURPOSE_GARLIC:
_organizer.selectHighCapacityPeers(criteria.getMinimumRequired(),exclude,peers);
break;
default :
break;
}
if (peers.size() <= 0) {
if (_log.shouldLog(Log.WARN)) _log.warn("We ran out of peers when looking for reachable ones after finding " + peers.size() + " with "+ _organizer.countWellIntegratedPeers()+ "/"+ _organizer.countHighCapacityPeers()+ "/"+ _organizer.countFastPeers()+ " integrated/high capacity/fast peers");
}
if (_log.shouldLog(Log.INFO)) _log.info("Peers selected: " + peers);
return new ArrayList(peers);
}
