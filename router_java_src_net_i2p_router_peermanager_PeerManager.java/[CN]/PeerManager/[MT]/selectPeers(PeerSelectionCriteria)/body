{
  int numPasses=0;
  Set rv=new HashSet(criteria.getMinimumRequired());
  Set exclude=new HashSet(1);
  exclude.add(_context.routerHash());
  while (rv.size() < criteria.getMinimumRequired()) {
    Set curVals=new HashSet(criteria.getMinimumRequired());
switch (criteria.getPurpose()) {
case PeerSelectionCriteria.PURPOSE_TEST:
      _organizer.selectReliablePeers(criteria.getMinimumRequired(),exclude,curVals);
    break;
case PeerSelectionCriteria.PURPOSE_TUNNEL:
  _organizer.selectFastAndReliablePeers(criteria.getMinimumRequired(),exclude,curVals);
break;
case PeerSelectionCriteria.PURPOSE_SOURCE_ROUTE:
_organizer.selectReliablePeers(criteria.getMinimumRequired(),exclude,curVals);
break;
case PeerSelectionCriteria.PURPOSE_GARLIC:
_organizer.selectReliablePeers(criteria.getMinimumRequired(),exclude,curVals);
break;
default :
break;
}
if (curVals.size() <= 0) {
if (_log.shouldLog(Log.WARN)) _log.warn("We ran out of peers when looking for reachable ones after finding " + rv.size() + " with "+ _organizer.countWellIntegratedPeers()+ "/"+ _organizer.countReliablePeers()+ "/"+ _organizer.countFastAndReliablePeers()+ " integrated/reliable/fast peers");
break;
}
 else {
for (Iterator iter=curVals.iterator(); iter.hasNext(); ) {
Hash peer=(Hash)iter.next();
if (null != _context.netDb().lookupRouterInfoLocally(peer)) {
if (_log.shouldLog(Log.DEBUG)) _log.debug("Peer " + peer.toBase64() + " is locally known, so we'll allow its selection");
rv.add(peer);
}
 else {
if (_log.shouldLog(Log.DEBUG)) _log.debug("Peer " + peer.toBase64() + " is NOT locally known, disallowing its selection");
}
}
exclude.addAll(curVals);
}
numPasses++;
}
if (_log.shouldLog(Log.INFO)) _log.info("Peers selected after " + numPasses + ": "+ rv);
return rv;
}
