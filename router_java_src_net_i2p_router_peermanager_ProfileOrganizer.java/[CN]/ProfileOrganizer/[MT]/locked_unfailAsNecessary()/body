{
  int notFailingActive=0;
  for (Iterator<Hash> iter=_notFailingPeers.keySet().iterator(); iter.hasNext(); ) {
    Hash key=iter.next();
    PeerProfile peer=_notFailingPeers.get(key);
    if (peer.getIsActive())     notFailingActive++;
    if (notFailingActive >= MIN_NOT_FAILING_ACTIVE) {
      return;
    }
  }
  int needToUnfail=MIN_NOT_FAILING_ACTIVE - notFailingActive;
  if (needToUnfail > 0) {
    int unfailed=0;
    for (Iterator<PeerProfile> iter=_strictCapacityOrder.iterator(); iter.hasNext(); ) {
      PeerProfile best=iter.next();
      if ((best.getIsActive()) && (best.getIsFailing())) {
        if (_log.shouldLog(Log.WARN))         _log.warn("All peers were failing, so we have overridden the failing flag for one of the most reliable active peers (" + best.getPeer().toBase64() + ")");
        best.setIsFailing(false);
        locked_placeProfile(best);
        unfailed++;
      }
      if (unfailed >= needToUnfail)       break;
    }
  }
}
