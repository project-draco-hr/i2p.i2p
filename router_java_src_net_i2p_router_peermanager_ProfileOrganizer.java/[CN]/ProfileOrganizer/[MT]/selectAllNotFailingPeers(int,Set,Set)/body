{
  if (matches.size() < howMany) {
    int orig=matches.size();
    int needed=howMany - orig;
    List selected=new ArrayList(needed);
synchronized (_reorganizeLock) {
      for (Iterator iter=_strictCapacityOrder.iterator(); selected.size() < needed && iter.hasNext(); ) {
        PeerProfile prof=(PeerProfile)iter.next();
        if (matches.contains(prof.getPeer()) || (exclude != null && exclude.contains(prof.getPeer())) || _failingPeers.containsKey(prof.getPeer())) {
          continue;
        }
 else {
          if (isOk(prof.getPeer()))           selected.add(prof.getPeer());
        }
      }
    }
    if (_log.shouldLog(Log.INFO))     _log.info("Selecting all not failing found " + (matches.size() - orig) + " new peers: "+ selected);
    matches.addAll(selected);
  }
  if (matches.size() < howMany) {
    if (_log.shouldLog(Log.INFO))     _log.info("selectAllNotFailing(" + howMany + "), not enough ("+ matches.size()+ ") going on to failing");
    selectFailingPeers(howMany,exclude,matches);
  }
 else {
    if (_log.shouldLog(Log.INFO))     _log.info("selectAllNotFailing(" + howMany + "), enough ("+ matches.size()+ ")");
  }
  return;
}
