{
  long numMs=(now - _lastRefillTime);
  if (_log.shouldLog(Log.INFO))   _log.info("Updating bandwidth after " + numMs + " (status: "+ _limiter.getStatus().toString()+ " rate in="+ _inboundKBytesPerSecond+ ", out="+ _outboundKBytesPerSecond+ ")");
  if (numMs >= REPLENISH_FREQUENCY) {
    long inboundToAdd=(1024 * _inboundKBytesPerSecond * numMs) / 1000;
    long outboundToAdd=(1024 * _outboundKBytesPerSecond * numMs) / 1000;
    if (inboundToAdd < 0)     inboundToAdd=0;
    if (outboundToAdd < 0)     outboundToAdd=0;
    if (_inboundKBytesPerSecond <= 0) {
      _limiter.setInboundUnlimited(true);
      inboundToAdd=0;
    }
 else {
      _limiter.setInboundUnlimited(false);
    }
    if (_outboundKBytesPerSecond <= 0) {
      _limiter.setOutboundUnlimited(true);
      outboundToAdd=0;
    }
 else {
      _limiter.setOutboundUnlimited(false);
    }
    long maxBurstIn=((_inboundBurstKBytesPerSecond - _inboundKBytesPerSecond) * 1024 * numMs) / 1000;
    long maxBurstOut=((_outboundBurstKBytesPerSecond - _outboundKBytesPerSecond) * 1024 * numMs) / 1000;
    _limiter.refillBandwidthQueues(inboundToAdd,outboundToAdd,maxBurstIn,maxBurstOut);
    if (_log.shouldLog(Log.DEBUG)) {
      _log.debug("Adding " + inboundToAdd + " bytes to inboundAvailable");
      _log.debug("Adding " + outboundToAdd + " bytes to outboundAvailable");
    }
    return true;
  }
 else {
    if (_log.shouldLog(Log.WARN))     _log.warn("Refresh delay too fast (" + numMs + ")");
    return false;
  }
}
