{
  HashSet matches=new HashSet(4);
  long beforeSync=_context.clock().now();
  Map messages=null;
synchronized (_pendingMessages) {
    messages=(Map)_pendingMessages.clone();
  }
  long matchTime=0;
  long continueTime=0;
  int numMessages=messages.size();
  long afterSync1=_context.clock().now();
  ArrayList matchedRemove=new ArrayList(32);
  for (Iterator iter=messages.keySet().iterator(); iter.hasNext(); ) {
    Long exp=(Long)iter.next();
    OutNetMessage msg=(OutNetMessage)messages.get(exp);
    MessageSelector selector=msg.getReplySelector();
    if (selector != null) {
      long before=_context.clock().now();
      boolean isMatch=selector.isMatch(message);
      long after=_context.clock().now();
      long diff=after - before;
      if (diff > 100) {
        if (_log.shouldLog(Log.WARN))         _log.warn("Matching with selector took too long (" + diff + "ms) : "+ selector.getClass().getName());
      }
      matchTime+=diff;
      if (isMatch) {
        if (_log.shouldLog(Log.DEBUG))         _log.debug("Selector matches [" + selector);
        matches.add(msg);
        long beforeCon=_context.clock().now();
        boolean continueMatching=selector.continueMatching();
        long afterCon=_context.clock().now();
        long diffCon=afterCon - beforeCon;
        if (diffCon > 100) {
          if (_log.shouldLog(Log.WARN))           _log.warn("Error continueMatching on a match took too long (" + diffCon + "ms) : "+ selector.getClass().getName());
        }
        continueTime+=diffCon;
        if (continueMatching) {
          if (_log.shouldLog(Log.DEBUG))           _log.debug("Continue matching");
        }
 else {
          if (_log.shouldLog(Log.DEBUG))           _log.debug("Stop matching selector " + selector + " for message "+ msg.getMessageType());
          matchedRemove.add(exp);
        }
      }
 else {
      }
    }
  }
  long afterSearch=_context.clock().now();
  for (Iterator iter=matchedRemove.iterator(); iter.hasNext(); ) {
    Long expiration=(Long)iter.next();
    OutNetMessage m=null;
    long before=_context.clock().now();
synchronized (_pendingMessages) {
      m=(OutNetMessage)_pendingMessages.remove(expiration);
    }
    long diff=_context.clock().now() - before;
    if ((diff > 500) && (_log.shouldLog(Log.WARN)))     _log.warn("Took too long syncing on remove (" + diff + "ms");
    if (m != null) {
      if (_log.shouldLog(Log.DEBUG))       _log.debug("Removing message with selector " + m.getReplySelector().getClass().getName() + " :"+ m.getReplySelector().toString());
    }
  }
  long delay=_context.clock().now() - beforeSync;
  long search=afterSearch - afterSync1;
  long sync=afterSync1 - beforeSync;
  int level=Log.DEBUG;
  if (delay > 1000)   level=Log.ERROR;
  if (_log.shouldLog(level)) {
    _log.log(level,"getMessages took " + delay + "ms with search time of "+ search+ "ms (match: "+ matchTime+ "ms, continue: "+ continueTime+ "ms, #: "+ numMessages+ ") and sync time of "+ sync+ "ms for "+ matchedRemove.size()+ " removed, "+ matches.size()+ " matches");
  }
  return new ArrayList(matches);
}
