{
  if (args.length == 3) {
    checkHost(args);
    return;
  }
  I2PAppContext ctx=I2PAppContext.getGlobalContext();
  try {
    java.net.Socket s=new java.net.Socket("localhost",9094);
    OutputStream out=s.getOutputStream();
    DHSessionKeyBuilder dh=new DHSessionKeyBuilder();
    byte X[]=dh.getMyPublicValueBytes();
    out.write(X);
    System.out.println("sent X =" + Base64.encode(X));
    byte bih[]=Base64.decode("HuRdDx9t-RaZfYkYvacRwP~6s9mvbdkYzIMrpUCsZIo=");
    System.out.println("bih = " + Base64.encode(bih));
    Hash hx=ctx.sha().calculateHash(X);
    System.out.println("hx  = " + Base64.encode(hx.getData()));
    byte hx_xor_bih[]=DataHelper.xor(bih,hx.getData());
    System.out.println("xor = " + Base64.encode(hx_xor_bih));
    out.write(hx_xor_bih);
    out.flush();
    InputStream in=s.getInputStream();
    byte toRead[]=new byte[256 + (32 + 4 + 12)];
    int read=0;
    while (read < toRead.length) {
      int r=in.read(toRead,read,toRead.length - read);
      if (r == -1)       throw new EOFException("eof at read=" + read);
      read+=r;
    }
    byte Y[]=new byte[256];
    System.arraycopy(toRead,0,Y,0,Y.length);
    dh.setPeerPublicValue(Y);
    byte decrypted[]=new byte[(32 + 4 + 12)];
    ctx.aes().decrypt(toRead,Y.length,decrypted,0,dh.getSessionKey(),Y,Y.length - 16,decrypted.length);
    System.out.println("dh session key: " + dh.getSessionKey().toBase64());
    System.out.println("decryption iv: " + Base64.encode(Y,Y.length - 16,16));
    System.out.println("Y = " + Base64.encode(Y));
    byte xy[]=new byte[512];
    System.arraycopy(X,0,xy,0,X.length);
    System.arraycopy(Y,0,xy,X.length,Y.length);
    System.out.println("h(x+y): " + ctx.sha().calculateHash(xy).toBase64());
    System.out.println("encrypted H(X+Y)+tsB+padding: " + Base64.encode(toRead,Y.length,toRead.length - Y.length));
    System.out.println("unencrypted H(X+Y)+tsB+padding: " + Base64.encode(decrypted));
    long tsB=DataHelper.fromLong(decrypted,32,4);
    RouterIdentity alice=new RouterIdentity();
    Object k[]=ctx.keyGenerator().generatePKIKeypair();
    PublicKey pub=(PublicKey)k[0];
    PrivateKey priv=(PrivateKey)k[1];
    k=ctx.keyGenerator().generateSigningKeypair();
    SigningPublicKey spub=(SigningPublicKey)k[0];
    SigningPrivateKey spriv=(SigningPrivateKey)k[1];
    alice.setCertificate(new Certificate(Certificate.CERTIFICATE_TYPE_NULL,null));
    alice.setPublicKey(pub);
    alice.setSigningPublicKey(spub);
    ByteArrayOutputStream baos=new ByteArrayOutputStream(512);
    byte aliceb[]=alice.toByteArray();
    long tsA=ctx.clock().now() / 1000l;
    baos.write(DataHelper.toLong(2,aliceb.length));
    baos.write(aliceb);
    baos.write(DataHelper.toLong(4,tsA));
    int base=baos.size() + Signature.SIGNATURE_BYTES;
    int rem=base % 16;
    int padding=0;
    if (rem > 0)     padding=16 - rem;
    byte pad[]=new byte[padding];
    ctx.random().nextBytes(pad);
    baos.write(pad);
    base+=padding;
    ByteArrayOutputStream sbaos=new ByteArrayOutputStream(512);
    sbaos.write(X);
    sbaos.write(Y);
    sbaos.write(bih);
    sbaos.write(DataHelper.toLong(4,tsA));
    sbaos.write(DataHelper.toLong(4,tsB));
    Signature sig=ctx.dsa().sign(sbaos.toByteArray(),spriv);
    baos.write(sig.toByteArray());
    byte unencrypted[]=baos.toByteArray();
    byte toWrite[]=new byte[unencrypted.length];
    System.out.println("unencrypted.length = " + unencrypted.length + " alice.size = "+ aliceb.length+ " padding = "+ padding+ " base = "+ base);
    ctx.aes().encrypt(unencrypted,0,toWrite,0,dh.getSessionKey(),hx_xor_bih,16,unencrypted.length);
    out.write(toWrite);
    out.flush();
    System.out.println("unencrypted: " + Base64.encode(unencrypted));
    System.out.println("encrypted: " + Base64.encode(toWrite));
    System.out.println("Local peer: " + alice.calculateHash().toBase64());
    SigningPublicKey bobPubKey=null;
    try {
      RouterInfo info=new RouterInfo();
      info.readBytes(new FileInputStream("/home/jrandom/routers/router1/netDb/routerInfo-HuRdDx9t-RaZfYkYvacRwP~6s9mvbdkYzIMrpUCsZIo=.dat"));
      bobPubKey=info.getIdentity().getSigningPublicKey();
    }
 catch (    Exception e) {
      e.printStackTrace();
      return;
    }
    System.out.println("Reading in bob's sig");
    byte bobRead[]=new byte[48];
    read=0;
    while (read < bobRead.length) {
      int r=in.read(bobRead,read,bobRead.length - read);
      if (r == -1)       throw new EOFException("eof at read=" + read);
      read+=r;
    }
    byte preSig[]=new byte[Signature.SIGNATURE_BYTES + 8];
    ctx.aes().decrypt(bobRead,0,preSig,0,dh.getSessionKey(),toRead,toRead.length - 16,preSig.length);
    byte bobSigData[]=new byte[Signature.SIGNATURE_BYTES];
    System.arraycopy(preSig,0,bobSigData,0,Signature.SIGNATURE_BYTES);
    System.out.println("Bob's sig: " + Base64.encode(bobSigData));
    byte signed[]=new byte[256 + 256 + 32+ 4+ 4];
    int off=0;
    System.arraycopy(X,0,signed,off,256);
    off+=256;
    System.arraycopy(Y,0,signed,off,256);
    off+=256;
    Hash h=alice.calculateHash();
    System.arraycopy(h.getData(),0,signed,off,32);
    off+=32;
    DataHelper.toLong(signed,off,4,tsA);
    off+=4;
    DataHelper.toLong(signed,off,4,tsB);
    off+=4;
    Signature bobSig=new Signature(bobSigData);
    boolean ok=ctx.dsa().verifySignature(bobSig,signed,bobPubKey);
    System.out.println("bob's sig matches? " + ok);
    try {
      Thread.sleep(5 * 1000);
    }
 catch (    InterruptedException ie) {
    }
    byte fakeI2NPbuf[]=new byte[128];
    ctx.random().nextBytes(fakeI2NPbuf);
    out.write(fakeI2NPbuf);
    out.flush();
    try {
      Thread.sleep(30 * 1000);
    }
 catch (    InterruptedException ie) {
    }
    s.close();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}
