{
  if (_corrupt)   return;
  byte b[]=_sz_aliceIdent_tsA_padding_aliceSig.toByteArray();
  try {
    RouterIdentity alice=new RouterIdentity();
    int sz=(int)DataHelper.fromLong(b,0,2);
    if ((sz <= 0) || (sz > b.length - 2 - 4- Signature.SIGNATURE_BYTES)) {
      _context.statManager().addRateData("ntcp.invalidInboundSize",sz,0);
      fail("size is invalid",new Exception("size is " + sz));
      return;
    }
    byte aliceData[]=new byte[sz];
    System.arraycopy(b,2,aliceData,0,sz);
    alice.fromByteArray(aliceData);
    long tsA=DataHelper.fromLong(b,2 + sz,4);
    ByteArrayOutputStream baos=new ByteArrayOutputStream(768);
    baos.write(_X);
    baos.write(_Y);
    baos.write(_context.routerHash().getData());
    baos.write(DataHelper.toLong(4,tsA));
    baos.write(DataHelper.toLong(4,_tsB));
    byte toVerify[]=baos.toByteArray();
    if (_log.shouldLog(Log.DEBUG)) {
      _log.debug(prefix() + "checking " + Base64.encode(toVerify,0,16));
    }
    byte s[]=new byte[Signature.SIGNATURE_BYTES];
    System.arraycopy(b,b.length - s.length,s,0,s.length);
    Signature sig=new Signature(s);
    _verified=_context.dsa().verifySignature(sig,toVerify,alice.getSigningPublicKey());
    if (_verified) {
      InetAddress addr=this._con.getChannel().socket().getInetAddress();
      byte[] ip=(addr == null) ? null : addr.getAddress();
      if (_context.shitlist().isShitlistedForever(alice.calculateHash())) {
        if (_log.shouldLog(Log.WARN))         _log.warn("Dropping inbound connection from permanently shitlisted peer: " + alice.calculateHash().toBase64());
        if (ip != null)         _context.blocklist().add(ip);
        fail("Peer is shitlisted forever: " + alice.calculateHash().toBase64());
        return;
      }
      if (ip != null)       _transport.setIP(alice.calculateHash(),ip);
      if (_log.shouldLog(Log.DEBUG))       _log.debug(prefix() + "verification successful for " + _con);
      long diff=1000 * Math.abs(tsA - _tsB);
      if (!_context.clock().getUpdatedSuccessfully()) {
        _context.clock().setOffset(1000 * (_tsB - tsA),true);
        tsA=_tsB;
        if (diff != 0)         _log.error("NTP failure, NTCP adjusting clock by " + DataHelper.formatDuration(diff));
      }
 else       if (diff >= Router.CLOCK_FUDGE_FACTOR) {
        _context.statManager().addRateData("ntcp.invalidInboundSkew",diff,0);
        _transport.markReachable(alice.calculateHash(),true);
        _context.shitlist().shitlistRouter(DataHelper.formatDuration(diff),alice.calculateHash(),_x("Excessive clock skew: {0}"));
        _transport.setLastBadSkew(tsA - _tsB);
        fail("Clocks too skewed (" + diff + " ms)",null,true);
        return;
      }
 else       if (_log.shouldLog(Log.DEBUG)) {
        _log.debug(prefix() + "Clock skew: " + diff+ " ms");
      }
      sendInboundConfirm(alice,tsA);
      _con.setRemotePeer(alice);
      if (_log.shouldLog(Log.DEBUG))       _log.debug(prefix() + "e_bobSig is " + _e_bobSig.length+ " bytes long");
      byte iv[]=new byte[16];
      System.arraycopy(_e_bobSig,_e_bobSig.length - 16,iv,0,16);
      _con.finishInboundEstablishment(_dh.getSessionKey(),(tsA - _tsB),iv,_prevEncrypted);
      if (_log.shouldLog(Log.INFO))       _log.info(prefix() + "Verified remote peer as " + alice.calculateHash().toBase64());
    }
 else {
      _context.statManager().addRateData("ntcp.invalidInboundSignature",1,0);
      fail("Peer verification failed - spoof of " + alice.calculateHash().toBase64() + "?");
    }
  }
 catch (  IOException ioe) {
    _context.statManager().addRateData("ntcp.invalidInboundIOE",1,0);
    fail("Error verifying peer",ioe);
  }
catch (  DataFormatException dfe) {
    _context.statManager().addRateData("ntcp.invalidInboundDFE",1,0);
    fail("Error verifying peer",dfe);
  }
catch (  NullPointerException npe) {
    fail("Error verifying peer",npe);
  }
}
