{
  long lastFailsafeIteration=System.currentTimeMillis();
  while (_alive && _selector.isOpen()) {
    try {
      runDelayedEvents();
      int count=0;
      try {
        count=_selector.select(200);
      }
 catch (      IOException ioe) {
        if (_log.shouldLog(Log.WARN))         _log.warn("Error selecting",ioe);
      }
      if (count <= 0)       continue;
      if (_log.shouldLog(Log.DEBUG))       _log.debug("select returned " + count);
      Set<SelectionKey> selected=null;
      try {
        selected=_selector.selectedKeys();
      }
 catch (      ClosedSelectorException cse) {
        continue;
      }
      processKeys(selected);
      selected.clear();
      if (lastFailsafeIteration + FAILSAFE_ITERATION_FREQ < System.currentTimeMillis()) {
        lastFailsafeIteration=System.currentTimeMillis();
        try {
          Set<SelectionKey> all=_selector.keys();
          int failsafeWrites=0;
          int failsafeCloses=0;
          int failsafeInvalid=0;
          if (_transport.haveCapacity())           _expireIdleWriteTime=Math.min(_expireIdleWriteTime + 1000,MAX_EXPIRE_IDLE_TIME);
 else           _expireIdleWriteTime=Math.max(_expireIdleWriteTime - 3000,MIN_EXPIRE_IDLE_TIME);
          for (          SelectionKey key : all) {
            try {
              Object att=key.attachment();
              if (!(att instanceof NTCPConnection))               continue;
              NTCPConnection con=(NTCPConnection)att;
              if ((!key.isValid()) && (!((SocketChannel)key.channel()).isConnectionPending()) && con.getTimeSinceCreated() > 2 * NTCPTransport.ESTABLISH_TIMEOUT) {
                if (_log.shouldLog(Log.WARN))                 _log.warn("Invalid key " + con);
                con.close();
                failsafeInvalid++;
                continue;
              }
              if ((con.getWriteBufCount() > 0) && ((key.interestOps() & SelectionKey.OP_WRITE) == 0)) {
                key.interestOps(SelectionKey.OP_WRITE | key.interestOps());
                failsafeWrites++;
              }
              if (con.getTimeSinceSend() > _expireIdleWriteTime && con.getTimeSinceReceive() > _expireIdleWriteTime) {
                con.close();
                failsafeCloses++;
              }
            }
 catch (            CancelledKeyException cke) {
            }
          }
          if (failsafeWrites > 0)           _context.statManager().addRateData("ntcp.failsafeWrites",failsafeWrites,0);
          if (failsafeCloses > 0)           _context.statManager().addRateData("ntcp.failsafeCloses",failsafeCloses,0);
          if (failsafeInvalid > 0)           _context.statManager().addRateData("ntcp.failsafeInvalid",failsafeInvalid,0);
        }
 catch (        ClosedSelectorException cse) {
          continue;
        }
      }
    }
 catch (    RuntimeException re) {
      _log.error("Error in the event pumper",re);
    }
  }
  try {
    if (_selector.isOpen()) {
      if (_log.shouldLog(Log.DEBUG))       _log.debug("Closing down the event pumper with selection keys remaining");
      Set<SelectionKey> keys=_selector.keys();
      for (      SelectionKey key : keys) {
        try {
          Object att=key.attachment();
          if (att instanceof ServerSocketChannel) {
            ServerSocketChannel chan=(ServerSocketChannel)att;
            chan.close();
            key.cancel();
          }
 else           if (att instanceof NTCPConnection) {
            NTCPConnection con=(NTCPConnection)att;
            con.close();
            key.cancel();
          }
        }
 catch (        Exception ke) {
          _log.error("Error closing key " + key + " on pumper shutdown",ke);
        }
      }
      _selector.close();
    }
 else {
      if (_log.shouldLog(Log.DEBUG))       _log.debug("Closing down the event pumper with no selection keys remaining");
    }
  }
 catch (  Exception e) {
    _log.error("Error closing keys on pumper shutdown",e);
  }
  _wantsConRegister.clear();
  _wantsRead.clear();
  _wantsRegister.clear();
  _wantsWrite.clear();
}
