{
  if (!_isInbound && !_established) {
    if (_establishState == null) {
      _establishState=new EstablishState(_context,_transport,this);
      _establishState.prepareOutbound();
    }
 else {
      if (_log.shouldLog(Log.DEBUG))       _log.debug("prepare next write, but we have already prepared the first outbound and we are not yet established..." + toString());
    }
    return;
  }
  if (_nextMetaTime <= System.currentTimeMillis()) {
    sendMeta();
    _nextMetaTime=System.currentTimeMillis() + (META_FREQUENCY / 2) + _context.random().nextInt(META_FREQUENCY);
  }
  OutNetMessage msg=null;
synchronized (_outbound) {
    if (_currentOutbound != null) {
      if (_log.shouldLog(Log.INFO))       _log.info("attempt for multiple outbound messages with " + System.identityHashCode(_currentOutbound) + " already waiting and "+ _outbound.size()+ " queued");
      return;
    }
    msg=_outbound.poll();
    if (msg == null)     return;
    _currentOutbound=msg;
  }
  PrepBuffer buf=(PrepBuffer)msg.releasePreparationBuffer();
  if (buf == null) {
    if (_log.shouldLog(Log.WARN))     _log.warn("Null prep buf for " + msg);
    return;
  }
  _context.aes().encrypt(buf.unencrypted,0,buf.encrypted,0,_sessionKey,_prevWriteEnd,0,buf.unencryptedLength);
  System.arraycopy(buf.encrypted,buf.encrypted.length - 16,_prevWriteEnd,0,_prevWriteEnd.length);
  _transport.getPumper().wantsWrite(this,buf.encrypted);
  releaseBuf(buf);
  if (_nextInfoTime <= System.currentTimeMillis()) {
    enqueueInfoMessage();
    _nextInfoTime=System.currentTimeMillis() + (INFO_FREQUENCY / 2) + _context.random().nextInt(INFO_FREQUENCY);
  }
}
