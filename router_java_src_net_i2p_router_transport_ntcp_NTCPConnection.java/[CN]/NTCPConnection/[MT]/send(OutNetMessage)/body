{
  if (tooBacklogged()) {
    boolean allowRequeue=false;
    boolean successful=false;
    _consecutiveBacklog++;
    _transport.afterSend(msg,successful,allowRequeue,msg.getLifetime());
    if (_consecutiveBacklog > 10) {
      boolean wantsWrite=false;
      try {
        wantsWrite=((_conKey.interestOps() & SelectionKey.OP_WRITE) != 0);
      }
 catch (      Exception e) {
      }
      if (_log.shouldLog(Log.WARN)) {
        int blocks=_writeBufs.size();
        _log.warn("Too backlogged for too long (" + _consecutiveBacklog + " messages for "+ DataHelper.formatDuration(queueTime())+ ", sched? "+ wantsWrite+ ", blocks: "+ blocks+ ") sending to "+ _remotePeer.calculateHash().toBase64());
      }
      _context.statManager().addRateData("ntcp.closeOnBacklog",getUptime(),getUptime());
      close();
    }
    _context.statManager().addRateData("ntcp.dontSendOnBacklog",_consecutiveBacklog,msg.getLifetime());
    return;
  }
  _consecutiveBacklog=0;
  int enqueued=0;
  bufferedPrepare(msg);
  boolean noOutbound=false;
  _outbound.offer(msg);
  enqueued=_outbound.size();
  _context.statManager().addRateData("ntcp.sendQueueSize",enqueued);
  noOutbound=(_currentOutbound == null);
  if (_log.shouldLog(Log.DEBUG))   _log.debug("messages enqueued on " + toString() + ": "+ enqueued+ " new one: "+ msg.getMessageId()+ " of "+ msg.getMessageType());
  if (_established && noOutbound)   _transport.getWriter().wantsWrite(this,"enqueued");
}
