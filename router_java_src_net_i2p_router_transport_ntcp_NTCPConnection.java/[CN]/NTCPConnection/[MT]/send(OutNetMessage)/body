{
  if (tooBacklogged()) {
    boolean allowRequeue=false;
    boolean successful=false;
    _consecutiveBacklog++;
    _transport.afterSend(msg,successful,allowRequeue,msg.getLifetime());
    if (_consecutiveBacklog > 10) {
      boolean wantsWrite=false;
      try {
        wantsWrite=((_conKey.interestOps() & SelectionKey.OP_WRITE) != 0);
      }
 catch (      Exception e) {
      }
      int blocks=0;
synchronized (_writeBufs) {
        blocks=_writeBufs.size();
      }
      if (_log.shouldLog(Log.ERROR))       _log.error("Too backlogged for too long (" + _consecutiveBacklog + " messages for "+ DataHelper.formatDuration(queueTime())+ ", sched? "+ wantsWrite+ ", blocks: "+ blocks+ ") sending to "+ _remotePeer.calculateHash().toBase64());
      close();
    }
    return;
  }
  _consecutiveBacklog=0;
  int enqueued=0;
  if (FAST_LARGE)   bufferedPrepare(msg);
synchronized (_outbound) {
    _outbound.add(msg);
    enqueued=_outbound.size();
    msg.setQueueSize(enqueued);
  }
  if (_log.shouldLog(Log.DEBUG))   _log.debug("messages enqueued on " + toString() + ": "+ enqueued+ " new one: "+ msg.getMessageId()+ " of "+ msg.getMessageType());
  if (_established && _currentOutbound == null)   _transport.getWriter().wantsWrite(this);
}
