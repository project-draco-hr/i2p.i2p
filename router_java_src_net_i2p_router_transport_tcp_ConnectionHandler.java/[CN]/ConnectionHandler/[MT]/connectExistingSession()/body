{
  byte data[]=new byte[36];
  System.arraycopy(_connectionTag.getData(),0,data,0,32);
  System.arraycopy(_nonce.getData(),0,data,32,4);
  Hash h=_context.sha().calculateHash(data);
  _iv=new byte[16];
  System.arraycopy(h.getData(),0,_iv,0,16);
  updateNextTagExisting();
  _rawOut=new BufferedOutputStream(_rawOut,ConnectionBuilder.WRITE_BUFFER_SIZE);
  _rawOut=new AESOutputStream(_context,_rawOut,_key,_iv);
  _rawIn=new AESInputStream(_context,_rawIn,_key,_iv);
  try {
    Hash readHash=new Hash();
    readHash.readBytes(_rawIn);
    Hash expected=_context.sha().calculateHash(_nonce.getData());
    if (!expected.equals(readHash)) {
      fail("Verification hash failed from " + _from);
      return false;
    }
  }
 catch (  IOException ioe) {
    fail("Error reading the encrypted nonce from " + _from + ": "+ ioe.getMessage(),ioe);
    return false;
  }
catch (  DataFormatException dfe) {
    fail("Error reading the encrypted nonce from " + _from + ": "+ dfe.getMessage(),dfe);
    return false;
  }
  try {
    Hash tagHash=_context.sha().calculateHash(_connectionTag.getData());
    tagHash.writeBytes(_rawOut);
    _rawOut.flush();
  }
 catch (  IOException ioe) {
    fail("Error writing the encrypted tag to " + _from + ": "+ ioe.getMessage(),ioe);
    return false;
  }
catch (  DataFormatException dfe) {
    fail("Error writing the encrypted tag to " + _from + ": "+ dfe.getMessage(),dfe);
    return false;
  }
  long clockSkew=0;
  try {
    RouterInfo peer=new RouterInfo();
    peer.readBytes(_rawIn);
    Date now=DataHelper.readDate(_rawIn);
    Hash readHash=new Hash();
    readHash.readBytes(_rawIn);
    ByteArrayOutputStream baos=new ByteArrayOutputStream(512);
    peer.writeBytes(baos);
    DataHelper.writeDate(baos,now);
    baos.write(_nonce.getData());
    baos.write(_connectionTag.getData());
    Hash expectedHash=_context.sha().calculateHash(baos.toByteArray());
    if (!expectedHash.equals(readHash)) {
      fail("Invalid hash read for the info from " + _from);
      return false;
    }
    _actualPeer=peer;
    clockSkew=_context.clock().now() - now.getTime();
  }
 catch (  IOException ioe) {
    fail("Error reading the peer info from " + _from + ": "+ ioe.getMessage(),ioe);
    return false;
  }
catch (  DataFormatException dfe) {
    fail("Error reading the peer info from " + _from + ": "+ dfe.getMessage(),dfe);
    return false;
  }
  boolean reachable=verifyReachability();
  try {
    ByteArrayOutputStream baos=new ByteArrayOutputStream(512);
    _context.router().getRouterInfo().writeBytes(baos);
    Properties props=new Properties();
    int status=STATUS_UNKNOWN;
    if (!reachable) {
      status=STATUS_UNREACHABLE;
    }
 else     if ((clockSkew > Router.CLOCK_FUDGE_FACTOR) || (clockSkew < 0 - Router.CLOCK_FUDGE_FACTOR)) {
      status=STATUS_SKEWED;
      SimpleDateFormat fmt=new SimpleDateFormat("yyyyMMddhhmmssSSS");
      props.setProperty("SKEW",fmt.format(new Date(_context.clock().now())));
    }
 else {
      status=STATUS_OK;
    }
    baos.write(status);
    DataHelper.writeProperties(baos,props);
    byte beginning[]=baos.toByteArray();
    baos.write(_nonce.getData());
    baos.write(_connectionTag.getData());
    Hash verification=_context.sha().calculateHash(baos.toByteArray());
    _rawOut.write(beginning);
    verification.writeBytes(_rawOut);
    _rawOut.flush();
    return handleStatus(status,clockSkew);
  }
 catch (  IOException ioe) {
    fail("Error writing the peer info to " + _from + ": "+ ioe.getMessage(),ioe);
    return false;
  }
catch (  DataFormatException dfe) {
    fail("Error writing the peer info to " + _from + ": "+ dfe.getMessage(),dfe);
    return false;
  }
}
