{
  long start=_context.clock().now();
  long success=0;
  if (_log.shouldLog(Log.DEBUG))   _log.debug("Establishing connection...");
  BigInteger myPub=_builder.getMyPublicValue();
  try {
    _socket.setSoTimeout(ESTABLISHMENT_TIMEOUT);
    if (_log.shouldLog(Log.DEBUG))     _log.debug("Before key exchange...");
    exchangeKey();
    if (_log.shouldLog(Log.DEBUG))     _log.debug("Key exchanged...");
    boolean ok=identifyStationToStation();
    if (_log.shouldLog(Log.DEBUG))     _log.debug("After station to station [" + ok + "]...");
    if (!ok) {
      throw new DataFormatException("Station to station identification failed!  MITM?");
    }
    if (_log.shouldLog(Log.DEBUG))     _log.debug("before validateVersion...");
    boolean versionOk=validateVersion();
    if (_log.shouldLog(Log.DEBUG))     _log.debug("after validateVersion [" + versionOk + "]...");
    if (!versionOk) {
      _context.netDb().fail(_remoteIdentity.getHash());
      _context.shitlist().shitlistRouter(_remoteIdentity.getHash(),"Invalid protocol version");
      throw new DataFormatException("Peer uses an invalid version!  dropping");
    }
    if (_log.shouldLog(Log.DEBUG))     _log.debug("before validateTime...");
    boolean timeOk=validateTime();
    if (_log.shouldLog(Log.DEBUG))     _log.debug("after validateTime [" + timeOk + "]...");
    if (!timeOk) {
      _context.shitlist().shitlistRouter(_remoteIdentity.getHash(),"Time too far out of sync");
      throw new DataFormatException("Peer is too far out of sync with the current router's clock!  dropping");
    }
    try {
      _context.netDb().store(_remoteIdentity.getHash(),_remoteInfo);
    }
 catch (    IllegalArgumentException iae) {
      if (_log.shouldLog(Log.ERROR))       _log.error("Peer gave us invalid router info",iae);
      _context.netDb().fail(_remoteIdentity.getHash());
      _context.shitlist().shitlistRouter(_remoteIdentity.getHash(),"Invalid peer info");
      throw new DataFormatException("Invalid peer info provided");
    }
    if (_log.shouldLog(Log.DEBUG))     _log.debug("before validate peer address...");
    boolean peerReachable=validatePeerAddress();
    if (_log.shouldLog(Log.DEBUG))     _log.debug("after validatePeerAddress [" + peerReachable + "]...");
    if (!peerReachable) {
      _context.shitlist().shitlistRouter(_remoteIdentity.getHash(),"Unreachable address");
      throw new DataFormatException("Peer provided us with an unreachable router address, and we can't handle restricted routes yet!  dropping");
    }
    if (_log.shouldLog(Log.INFO))     _log.info("TCP connection " + _id + " established with "+ _remoteIdentity.getHash().toBase64());
    _in=new BandwidthLimitedInputStream(_context,new AESInputStream(_context,_in,_key,_iv),_remoteIdentity);
    _out=new AESOutputStream(_context,new BufferedOutputStream(new BandwidthLimitedOutputStream(_context,_out,_remoteIdentity),BUF_SIZE),_key,_iv);
    _socket.setSoTimeout(0);
    success=_context.clock().now();
    for (Iterator iter=_remoteInfo.getAddresses().iterator(); iter.hasNext(); ) {
      RouterAddress curAddr=(RouterAddress)iter.next();
      if (TCPTransport.STYLE.equals(curAddr.getTransportStyle())) {
        _remoteAddress=new TCPAddress(curAddr);
        break;
      }
    }
    if (_remoteAddress == null) {
      throw new DataFormatException("wtf, no TCP addresses?  we already verified!");
    }
    established();
    return _remoteIdentity;
  }
 catch (  IOException ioe) {
    if (_log.shouldLog(Log.WARN))     _log.warn("Error establishing connection with " + _remoteHost + ":"+ _remotePort,ioe);
    closeConnection();
    return null;
  }
catch (  DataFormatException dfe) {
    if (_log.shouldLog(Log.WARN))     _log.warn("Error establishing connection with " + _remoteHost + ":"+ _remotePort,dfe);
    closeConnection();
    return null;
  }
catch (  Throwable t) {
    if (_log.shouldLog(Log.ERROR))     _log.error("jrandom is paranoid so we're catching it all during establishConnection " + _remoteHost + ":"+ _remotePort,t);
    closeConnection();
    return null;
  }
 finally {
    if (success > 0)     _context.statManager().addRateData("tcp.establishConnectionTime",success - start,success - start);
  }
}
