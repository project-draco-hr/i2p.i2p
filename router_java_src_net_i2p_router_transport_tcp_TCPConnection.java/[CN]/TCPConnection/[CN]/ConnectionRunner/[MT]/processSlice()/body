{
  long start=_context.clock().now();
  OutNetMessage msg=null;
  int remaining=0;
  List timedOut=null;
synchronized (_toBeSent) {
    while (msg == null) {
      if (_toBeSent.size() <= 0) {
        try {
          _toBeSent.wait(30 * 1000);
        }
 catch (        InterruptedException ie) {
        }
      }
      remaining=_toBeSent.size();
      if (remaining <= 0)       return true;
      msg=(OutNetMessage)_toBeSent.remove(0);
      remaining--;
      if ((msg.getExpiration() > 0) && (msg.getExpiration() < start)) {
        if (timedOut == null)         timedOut=new ArrayList(4);
        timedOut.add(msg);
        msg=null;
      }
    }
  }
  if (timedOut != null) {
    for (int i=0; i < timedOut.size(); i++) {
      OutNetMessage failed=(OutNetMessage)timedOut.get(i);
      if (_log.shouldLog(Log.WARN))       _log.warn("Message timed out while sitting on the TCP Connection's queue!  was too slow by: " + (start - msg.getExpiration()) + "ms to "+ _remoteIdentity.getHash().toBase64()+ ": "+ msg);
      msg.timestamp("TCPConnection.runner.processSlice expired");
      _transport.afterSend(msg,false);
      return true;
    }
  }
  if (remaining > 0) {
    if (_log.shouldLog(Log.INFO))     _log.info("After pulling off a pending message, there are still " + remaining + " messages queued up for sending to "+ _remoteIdentity.getHash().toBase64());
  }
  long afterExpire=_context.clock().now();
  if (msg != null) {
    msg.timestamp("TCPConnection.runner.processSlice fetched");
    byte data[]=msg.getMessageData();
    if (data == null) {
      if (_log.shouldLog(Log.ERROR))       _log.error("wtf, for some reason, an I2NPMessage couldn't be serialized...");
      return true;
    }
    msg.timestamp("TCPConnection.runner.processSlice before sending " + data.length + " bytes");
    if (_log.shouldLog(Log.DEBUG))     _log.debug("Sending " + data.length + " bytes in the slice... to "+ _remoteIdentity.getHash().toBase64());
    try {
synchronized (_out) {
        _out.write(data);
        _out.flush();
      }
    }
 catch (    IOException ioe) {
      if (_log.shouldLog(Log.ERROR))       _log.error("IO error writing out a " + data.length + " byte message to "+ _remoteIdentity.getHash().toBase64());
      return false;
    }
    msg.timestamp("TCPConnection.runner.processSlice sent and flushed");
    long end=_context.clock().now();
    long timeLeft=msg.getMessage().getMessageExpiration().getTime() - end;
    if (_log.shouldLog(Log.INFO))     _log.info("Message " + msg.getMessage().getClass().getName() + " (expiring in "+ timeLeft+ "ms) sent to "+ _remoteIdentity.getHash().toBase64()+ " from "+ _context.routerHash().toBase64()+ " over connection "+ _id+ " with "+ data.length+ " bytes in "+ (end - start)+ "ms");
    if (timeLeft < 10 * 1000) {
      if (_log.shouldLog(Log.DEBUG))       _log.warn("Very little time left... time to send [" + (end - start) + "] time left ["+ timeLeft+ "] to "+ _remoteIdentity.getHash().toBase64()+ "\n"+ msg.toString(),msg.getCreatedBy());
    }
    long lifetime=msg.getLifetime();
    if (lifetime > 10 * 1000) {
      if (_log.shouldLog(Log.WARN))       _log.warn("The processing of the message took way too long (" + lifetime + "ms) - time to send ("+ (end - start)+ "), time left ("+ timeLeft+ ") to "+ _remoteIdentity.getHash().toBase64()+ "\n"+ msg.toString());
    }
    _transport.afterSend(msg,true);
    if (_log.shouldLog(Log.DEBUG))     _log.debug("Processing slice - message sent completely: " + msg.getMessage().getClass().getName() + " to "+ _remoteIdentity.getHash().toBase64());
    if (end - afterExpire > 1000) {
      if (_log.shouldLog(Log.WARN))       _log.warn("Actual sending took too long ( " + (end - afterExpire) + "ms) sending "+ data.length+ " bytes to "+ _remoteIdentity.getHash().toBase64());
    }
  }
  return true;
}
