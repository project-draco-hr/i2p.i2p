{
  ByteArrayOutputStream baos=new ByteArrayOutputStream(10 * 1024);
  _context.router().getRouterInfo().writeBytes(baos);
  Hash keyHash=_context.sha().calculateHash(_key.getData());
  keyHash.writeBytes(baos);
  Signature sig=_context.dsa().sign(baos.toByteArray(),_context.keyManager().getSigningPrivateKey());
  sig.writeBytes(baos);
  byte encr[]=_context.AESEngine().safeEncrypt(baos.toByteArray(),_key,_iv,10 * 1024);
  DataHelper.writeLong(_out,2,encr.length);
  _out.write(encr);
  int rlen=(int)DataHelper.readLong(_in,2);
  byte pencr[]=new byte[rlen];
  int read=DataHelper.read(_in,pencr);
  if (read != rlen)   throw new DataFormatException("Not enough data in peer ident");
  byte decr[]=_context.AESEngine().safeDecrypt(pencr,_key,_iv);
  if (decr == null)   throw new DataFormatException("Unable to decrypt - failed exchange?");
  ByteArrayInputStream bais=new ByteArrayInputStream(decr);
  RouterInfo peer=new RouterInfo();
  peer.readBytes(bais);
  _remoteIdentity=peer.getIdentity();
  Hash peerKeyHash=new Hash();
  peerKeyHash.readBytes(bais);
  if (!peerKeyHash.equals(keyHash)) {
    if (_log.shouldLog(Log.ERROR))     _log.error("Peer tried to spoof!");
    return false;
  }
  Signature rsig=new Signature();
  rsig.readBytes(bais);
  byte signedData[]=new byte[decr.length - rsig.getData().length];
  System.arraycopy(decr,0,signedData,0,signedData.length);
  boolean valid=_context.dsa().verifySignature(rsig,signedData,_remoteIdentity.getSigningPublicKey());
  if (valid)   _context.netDb().store(_remoteIdentity.getHash(),peer);
  return valid;
}
