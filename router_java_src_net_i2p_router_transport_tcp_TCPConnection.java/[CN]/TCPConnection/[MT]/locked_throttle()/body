{
  if (!shouldDropProbabalistically())   return;
  int bytesQueued=0;
  long earliestExpiration=-1;
  for (int i=0; i < _pendingMessages.size(); i++) {
    OutNetMessage msg=(OutNetMessage)_pendingMessages.get(i);
    bytesQueued+=(int)msg.getMessageSize();
    if ((earliestExpiration < 0) || (msg.getExpiration() < earliestExpiration))     earliestExpiration=msg.getExpiration();
  }
  if (bytesQueued > 0)   _context.statManager().addRateData("tcp.queueSize",bytesQueued,_pendingMessages.size());
  long sendRate=getSendRate();
  long bytesSendableUntilFirstExpire=sendRate * (earliestExpiration - _context.clock().now()) / 1000;
  long excessQueued=(long)(bytesQueued - ((double)bytesSendableUntilFirstExpire * (1.0 - getQueueFreeFactor())));
  if ((excessQueued > 0) && (_pendingMessages.size() > 1) && (_transport != null))   locked_probabalisticDrop(excessQueued);
}
