{
  while (_alive) {
    PeerState peer=null;
    long now=_context.clock().now();
    long remaining=-1;
    try {
synchronized (_peersToACK) {
        for (int i=0; i < _peersToACK.size(); i++) {
          PeerState cur=(PeerState)_peersToACK.get(i);
          long delta=cur.getWantedACKSendSince() + ACK_FREQUENCY - now;
          if ((delta < 0) || (cur.unsentACKThresholdReached())) {
            _peersToACK.remove(i);
            peer=cur;
            break;
          }
        }
        if (peer == null) {
          if (_peersToACK.size() <= 0)           _peersToACK.wait();
 else           _peersToACK.wait(50);
        }
 else {
          remaining=_peersToACK.size();
        }
      }
    }
 catch (    InterruptedException ie) {
    }
    if (peer != null) {
      long lastSend=peer.getLastACKSend();
      long wanted=peer.getWantedACKSendSince();
      List acks=peer.retrieveACKs();
      if ((acks != null) && (acks.size() > 0)) {
        _context.statManager().addRateData("udp.sendACKCount",acks.size(),0);
        _context.statManager().addRateData("udp.sendACKRemaining",remaining,0);
        now=_context.clock().now();
        _context.statManager().addRateData("udp.ackFrequency",now - lastSend,now - wanted);
        _context.statManager().getStatLog().addData(peer.getRemoteHostString(),"udp.peer.sendACKCount",acks.size(),0);
        UDPPacket ack=_builder.buildACK(peer,acks);
        ack.markType(1);
        if (_log.shouldLog(Log.INFO))         _log.info("Sending ACK for " + acks);
        _transport.send(ack);
        if (wanted == peer.getWantedACKSendSince()) {
          ackPeer(peer);
        }
      }
    }
  }
}
