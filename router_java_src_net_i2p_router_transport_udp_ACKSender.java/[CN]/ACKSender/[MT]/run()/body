{
  while (_alive) {
    PeerState peer=null;
    long now=_context.clock().now();
    long remaining=-1;
    try {
synchronized (_peersToACK) {
        for (int i=0; i < _peersToACK.size(); i++) {
          PeerState cur=(PeerState)_peersToACK.get(i);
          long wanted=cur.getWantedACKSendSince();
          long delta=wanted + ACK_FREQUENCY - now;
          if (((wanted > 0) && (delta < 0)) || (cur.unsentACKThresholdReached())) {
            _peersToACK.remove(i);
            peer=cur;
            break;
          }
        }
        if (peer == null) {
          if (_peersToACK.size() <= 0)           _peersToACK.wait();
 else           _peersToACK.wait(50);
        }
 else {
          remaining=_peersToACK.size();
        }
      }
    }
 catch (    InterruptedException ie) {
    }
    if (peer != null) {
      long lastSend=peer.getLastACKSend();
      long wanted=peer.getWantedACKSendSince();
      List ackBitfields=peer.retrieveACKBitfields();
      if (wanted < 0)       _log.error("wtf, why are we acking something they dont want?  remaining=" + remaining + ", peer="+ peer+ ", bitfields="+ ackBitfields);
      if ((ackBitfields != null) && (ackBitfields.size() > 0)) {
        _context.statManager().addRateData("udp.sendACKCount",ackBitfields.size(),0);
        _context.statManager().addRateData("udp.sendACKRemaining",remaining,0);
        now=_context.clock().now();
        _context.statManager().addRateData("udp.ackFrequency",now - lastSend,now - wanted);
        UDPPacket ack=_builder.buildACK(peer,ackBitfields);
        ack.markType(1);
        if (_log.shouldLog(Log.INFO))         _log.info("Sending ACK for " + ackBitfields);
        _transport.send(ack);
        if ((wanted > 0) && (wanted <= peer.getWantedACKSendSince())) {
          if (_log.shouldLog(Log.WARN))           _log.warn("Rerequesting ACK for peer " + peer);
          ackPeer(peer);
        }
      }
    }
  }
}
