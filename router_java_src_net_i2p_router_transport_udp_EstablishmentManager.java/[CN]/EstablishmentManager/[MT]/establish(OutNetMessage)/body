{
  RouterAddress ra=msg.getTarget().getTargetAddress(_transport.getStyle());
  if (ra == null) {
    _transport.failed(msg,"Remote peer has no address, cannot establish");
    return;
  }
  if (msg.getTarget().getNetworkId() != Router.NETWORK_ID) {
    _context.shitlist().shitlistRouter(msg.getTarget().getIdentity().calculateHash());
    _transport.markUnreachable(msg.getTarget().getIdentity().calculateHash());
    _transport.failed(msg,"Remote peer is on the wrong network, cannot establish");
    return;
  }
  UDPAddress addr=new UDPAddress(ra);
  RemoteHostId to=null;
  InetAddress remAddr=addr.getHostAddress();
  int port=addr.getPort();
  if ((remAddr != null) && (port > 0)) {
    to=new RemoteHostId(remAddr.getAddress(),port);
    if (!_transport.isValid(to.getIP())) {
      _transport.failed(msg,"Remote peer's IP isn't valid");
      _transport.markUnreachable(msg.getTarget().getIdentity().calculateHash());
      return;
    }
    if (_log.shouldLog(Log.DEBUG))     _log.debug("Add outbound establish state to: " + to);
  }
 else {
    if (_log.shouldLog(Log.DEBUG))     _log.debug("Add indirect outbound establish state to: " + addr);
    to=new RemoteHostId(msg.getTarget().getIdentity().calculateHash().getData());
  }
  OutboundEstablishState state=null;
  int deferred=0;
  boolean rejected=false;
  int queueCount=0;
  state=_outboundStates.get(to);
  if (state == null) {
    if (_outboundStates.size() >= getMaxConcurrentEstablish()) {
      if (_queuedOutbound.size() > MAX_QUEUED_OUTBOUND) {
        rejected=true;
      }
 else {
        List<OutNetMessage> newQueued=new ArrayList(MAX_QUEUED_PER_PEER);
        List<OutNetMessage> queued=_queuedOutbound.putIfAbsent(to,newQueued);
        if (queued == null)         queued=newQueued;
synchronized (queued) {
          queueCount=queued.size();
          if (queueCount < MAX_QUEUED_PER_PEER) {
            queued.add(msg);
            queueCount++;
          }
          deferred=_queuedOutbound.size();
        }
      }
    }
 else {
      byte[] keyBytes=addr.getIntroKey();
      if (keyBytes == null) {
        _transport.markUnreachable(msg.getTarget().getIdentity().calculateHash());
        _transport.failed(msg,"Peer has no key, cannot establish");
        return;
      }
      SessionKey sessionKey;
      try {
        sessionKey=new SessionKey(keyBytes);
      }
 catch (      IllegalArgumentException iae) {
        _transport.markUnreachable(msg.getTarget().getIdentity().calculateHash());
        _transport.failed(msg,"Peer has bad key, cannot establish");
        return;
      }
      state=new OutboundEstablishState(_context,remAddr,port,msg.getTarget().getIdentity(),sessionKey,addr,_transport.getDHBuilder());
      OutboundEstablishState oldState=_outboundStates.putIfAbsent(to,state);
      boolean isNew=oldState == null;
      if (!isNew)       state=oldState;
 else       _context.simpleScheduler().addEvent(new Expire(to,state),10 * 1000);
    }
  }
  if (state != null) {
    state.addMessage(msg);
    List<OutNetMessage> queued=_queuedOutbound.remove(to);
    if (queued != null) {
synchronized (queued) {
        for (        OutNetMessage m : queued) {
          state.addMessage(m);
        }
      }
    }
  }
  if (rejected) {
    _transport.failed(msg,"Too many pending outbound connections");
    _context.statManager().addRateData("udp.establishRejected",deferred,0);
    return;
  }
  if (queueCount >= MAX_QUEUED_PER_PEER) {
    _transport.failed(msg,"Too many pending messages for the given peer");
    _context.statManager().addRateData("udp.establishOverflow",queueCount,deferred);
    return;
  }
  if (deferred > 0)   msg.timestamp("too many deferred establishers: " + deferred);
 else   if (state != null)   msg.timestamp("establish state already waiting " + state.getLifetime());
  notifyActivity();
}
