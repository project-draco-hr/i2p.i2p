{
  RouterAddress ra=msg.getTarget().getTargetAddress(_transport.getStyle());
  if (ra == null) {
    _transport.failed(msg,"Remote peer has no address, cannot establish");
    return;
  }
  if (msg.getTarget().getNetworkId() != Router.NETWORK_ID) {
    _context.shitlist().shitlistRouter(msg.getTarget().getIdentity().calculateHash());
    _transport.markUnreachable(msg.getTarget().getIdentity().calculateHash());
    _transport.failed(msg,"Remote peer is on the wrong network, cannot establish");
    return;
  }
  UDPAddress addr=new UDPAddress(ra);
  RemoteHostId to=null;
  InetAddress remAddr=addr.getHostAddress();
  int port=addr.getPort();
  if ((remAddr != null) && (port > 0)) {
    to=new RemoteHostId(remAddr.getAddress(),port);
    if (!_transport.isValid(to.getIP())) {
      _transport.failed(msg,"Remote peer's IP isn't valid");
      _transport.markUnreachable(msg.getTarget().getIdentity().calculateHash());
      return;
    }
    if (_log.shouldLog(Log.DEBUG))     _log.debug("Add outbound establish state to: " + to);
  }
 else {
    if (_log.shouldLog(Log.DEBUG))     _log.debug("Add indirect outbound establish state to: " + addr);
    to=new RemoteHostId(msg.getTarget().getIdentity().calculateHash().getData());
  }
  OutboundEstablishState state=null;
  int deferred=0;
  boolean rejected=false;
  int queueCount=0;
synchronized (_outboundStates) {
    state=(OutboundEstablishState)_outboundStates.get(to);
    if (state == null) {
      if (_outboundStates.size() >= getMaxConcurrentEstablish()) {
        List queued=(List)_queuedOutbound.get(to);
        if (queued == null) {
          if (_queuedOutbound.size() > MAX_QUEUED_OUTBOUND) {
            rejected=true;
          }
 else {
            queued=new ArrayList(1);
            _queuedOutbound.put(to,queued);
          }
        }
        queueCount=queued.size();
        if ((queueCount < MAX_QUEUED_PER_PEER) && (!rejected))         queued.add(msg);
        deferred=_queuedOutbound.size();
      }
 else {
        state=new OutboundEstablishState(_context,remAddr,port,msg.getTarget().getIdentity(),new SessionKey(addr.getIntroKey()),addr);
        _outboundStates.put(to,state);
        SimpleTimer.getInstance().addEvent(new Expire(to,state),10 * 1000);
      }
    }
    if (state != null) {
      state.addMessage(msg);
      List queued=(List)_queuedOutbound.remove(to);
      if (queued != null)       for (int i=0; i < queued.size(); i++)       state.addMessage((OutNetMessage)queued.get(i));
    }
  }
  if (rejected) {
    _transport.failed(msg,"Too many pending outbound connections");
    _context.statManager().addRateData("udp.establishRejected",deferred,0);
    return;
  }
  if (queueCount >= MAX_QUEUED_PER_PEER) {
    _transport.failed(msg,"Too many pending messages for the given peer");
    _context.statManager().addRateData("udp.establishOverflow",queueCount,deferred);
    return;
  }
  if (deferred > 0)   msg.timestamp("too many deferred establishers: " + deferred);
 else   if (state != null)   msg.timestamp("establish state already waiting " + state.getLifetime());
  notifyActivity();
}
