{
  long now=_context.clock().now();
  long nextSendTime=-1;
  OutboundEstablishState outboundState=null;
  int admitted=0;
  int remaining=0;
  int active=0;
synchronized (_outboundStates) {
    active=_outboundStates.size();
    for (Iterator iter=_outboundStates.values().iterator(); iter.hasNext(); ) {
      OutboundEstablishState cur=(OutboundEstablishState)iter.next();
      if (cur.getState() == OutboundEstablishState.STATE_CONFIRMED_COMPLETELY) {
        iter.remove();
        outboundState=cur;
        if (_log.shouldLog(Log.DEBUG))         _log.debug("Removing confirmed outbound: " + cur);
        break;
      }
 else       if (cur.getLifetime() > MAX_ESTABLISH_TIME) {
        iter.remove();
        outboundState=cur;
        _context.statManager().addRateData("udp.outboundEstablishFailedState",cur.getState(),cur.getLifetime());
        if (_log.shouldLog(Log.DEBUG))         _log.debug("Removing expired outbound: " + cur);
        break;
      }
 else {
        if (cur.getNextSendTime() <= now) {
          outboundState=cur;
          if (_log.shouldLog(Log.DEBUG))           _log.debug("Outbound wants activity: " + cur);
          break;
        }
 else {
          long when=-1;
          if (cur.getNextSendTime() <= 0) {
            when=cur.getEstablishBeginTime() + MAX_ESTABLISH_TIME;
          }
 else {
            when=cur.getNextSendTime();
          }
          if ((nextSendTime <= 0) || (when < nextSendTime))           nextSendTime=when;
          if (_log.shouldLog(Log.DEBUG))           _log.debug("Outbound doesn't want activity: " + cur + " (next="+ (when - now)+ ")");
        }
      }
    }
    admitted=locked_admitQueued();
    remaining=_queuedOutbound.size();
  }
  if (outboundState != null) {
    if (outboundState.getLifetime() > MAX_ESTABLISH_TIME) {
      if (outboundState.getState() != OutboundEstablishState.STATE_CONFIRMED_COMPLETELY) {
        if (_log.shouldLog(Log.WARN))         _log.warn("Lifetime of expired outbound establish: " + outboundState.getLifetime());
        while (true) {
          OutNetMessage msg=outboundState.getNextQueuedMessage();
          if (msg == null)           break;
          _transport.failed(msg,"Expired during failed establish");
        }
        String err=null;
switch (outboundState.getState()) {
case OutboundEstablishState.STATE_CONFIRMED_PARTIALLY:
          err="Took too long to establish remote connection (confirmed partially)";
        break;
case OutboundEstablishState.STATE_CREATED_RECEIVED:
      err="Took too long to establish remote connection (created received)";
    break;
case OutboundEstablishState.STATE_REQUEST_SENT:
  err="Took too long to establish remote connection (request sent)";
break;
case OutboundEstablishState.STATE_PENDING_INTRO:
err="Took too long to establish remote connection (intro failed)";
break;
case OutboundEstablishState.STATE_UNKNOWN:
default :
err="Took too long to establish remote connection (unknown state)";
}
Hash peer=outboundState.getRemoteIdentity().calculateHash();
_context.shitlist().shitlistRouter(peer,err);
_transport.dropPeer(peer);
}
 else {
while (true) {
OutNetMessage msg=outboundState.getNextQueuedMessage();
if (msg == null) break;
_transport.send(msg);
}
}
}
 else {
switch (outboundState.getState()) {
case OutboundEstablishState.STATE_UNKNOWN:
sendRequest(outboundState);
break;
case OutboundEstablishState.STATE_REQUEST_SENT:
if (outboundState.getNextSendTime() <= now) sendRequest(outboundState);
break;
case OutboundEstablishState.STATE_CREATED_RECEIVED:
case OutboundEstablishState.STATE_CONFIRMED_PARTIALLY:
if (outboundState.getNextSendTime() <= now) sendConfirmation(outboundState);
break;
case OutboundEstablishState.STATE_CONFIRMED_COMPLETELY:
handleCompletelyEstablished(outboundState);
break;
case OutboundEstablishState.STATE_PENDING_INTRO:
handlePendingIntro(outboundState);
break;
default :
}
}
nextSendTime=now;
}
 else {
}
return nextSendTime;
}
