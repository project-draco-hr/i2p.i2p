{
  int fragments=data.readFragmentCount();
  if (fragments <= 0)   return;
synchronized (_stateLock) {
    Map messages=(Map)_inboundMessages.get(from.getRemotePeer());
    if (messages == null) {
      messages=new HashMap(fragments);
      _inboundMessages.put(from.getRemotePeer(),messages);
    }
    for (int i=0; i < fragments; i++) {
      Long messageId=new Long(data.readMessageId(i));
      if (_recentlyCompletedMessages.contains(messageId)) {
        _context.statManager().addRateData("udp.ignoreRecentDuplicate",1,0);
        continue;
      }
      int size=data.readMessageFragmentSize(i);
      InboundMessageState state=null;
      boolean messageComplete=false;
      boolean messageExpired=false;
      boolean fragmentOK=false;
      state=(InboundMessageState)messages.get(messageId);
      if (state == null) {
        state=new InboundMessageState(_context,messageId.longValue(),from.getRemotePeer());
        messages.put(messageId,state);
      }
      fragmentOK=state.receiveFragment(data,i);
      if (state.isComplete()) {
        messageComplete=true;
        messages.remove(messageId);
        while (_recentlyCompletedMessages.size() >= RECENTLY_COMPLETED_SIZE)         _recentlyCompletedMessages.remove(0);
        _recentlyCompletedMessages.add(messageId);
        _completeMessages.add(state);
        from.messageFullyReceived(messageId);
        if (!_unsentACKs.contains(from))         _unsentACKs.add(from);
        if (_log.shouldLog(Log.INFO))         _log.info("Message received completely!  " + state);
        _context.statManager().addRateData("udp.receivedCompleteTime",state.getLifetime(),state.getLifetime());
        _context.statManager().addRateData("udp.receivedCompleteFragments",state.getFragmentCount(),state.getLifetime());
      }
 else       if (state.isExpired()) {
        messageExpired=true;
        messages.remove(messageId);
        if (_log.shouldLog(Log.WARN))         _log.warn("Message expired while only being partially read: " + state);
        state.releaseResources();
      }
      if (!fragmentOK)       break;
    }
    _stateLock.notifyAll();
  }
}
