{
  int fragments=data.readFragmentCount();
  if (fragments <= 0)   return fragments;
  Hash fromPeer=from.getRemotePeer();
  Map messages=from.getInboundMessages();
  for (int i=0; i < fragments; i++) {
    long mid=data.readMessageId(i);
    Long messageId=new Long(mid);
    if (_recentlyCompletedMessages.isKnown(mid)) {
      _context.statManager().addRateData("udp.ignoreRecentDuplicate",1,0);
      from.messageFullyReceived(messageId,-1);
      _ackSender.ackPeer(from);
      if (_log.shouldLog(Log.WARN))       _log.warn("Message received is a dup: " + mid + " dups: "+ _recentlyCompletedMessages.getCurrentDuplicateCount()+ " out of "+ _recentlyCompletedMessages.getInsertedCount());
      continue;
    }
    int size=data.readMessageFragmentSize(i);
    InboundMessageState state=null;
    boolean messageComplete=false;
    boolean messageExpired=false;
    boolean fragmentOK=false;
    boolean partialACK=false;
synchronized (messages) {
      state=(InboundMessageState)messages.get(messageId);
      if (state == null) {
        state=new InboundMessageState(_context,mid,fromPeer);
        messages.put(messageId,state);
      }
      fragmentOK=state.receiveFragment(data,i);
      if (state.isComplete()) {
        messageComplete=true;
        messages.remove(messageId);
      }
 else       if (state.isExpired()) {
        messageExpired=true;
        messages.remove(messageId);
      }
 else {
        partialACK=true;
      }
      if (messageComplete) {
        _recentlyCompletedMessages.add(mid);
        _messageReceiver.receiveMessage(state);
        from.messageFullyReceived(messageId,state.getCompleteSize());
        _ackSender.ackPeer(from);
        if (_log.shouldLog(Log.INFO))         _log.info("Message received completely!  " + state);
        _context.statManager().addRateData("udp.receivedCompleteTime",state.getLifetime(),state.getLifetime());
        if (state.getFragmentCount() > 0)         _context.statManager().addRateData("udp.receivedCompleteFragments",state.getFragmentCount(),state.getLifetime());
      }
 else       if (messageExpired) {
        state.releaseResources();
        if (_log.shouldLog(Log.WARN))         _log.warn("Message expired while only being partially read: " + state);
      }
 else       if (partialACK) {
        if (_log.shouldLog(Log.DEBUG))         _log.debug("Queueing up a partial ACK for peer: " + from + " for "+ state);
        from.messagePartiallyReceived();
        _ackSender.ackPeer(from);
      }
      if (!fragmentOK)       break;
    }
  }
  return fragments;
}
