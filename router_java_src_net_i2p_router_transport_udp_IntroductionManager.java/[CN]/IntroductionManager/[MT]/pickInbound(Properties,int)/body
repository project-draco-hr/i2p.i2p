{
  int start=_context.random().nextInt(Integer.MAX_VALUE);
  if (_log.shouldLog(Log.DEBUG))   _log.debug("Picking inbound out of " + _inbound.size());
  if (_inbound.isEmpty())   return 0;
  List<PeerState> peers=new ArrayList(_inbound);
  int sz=peers.size();
  start=start % sz;
  int found=0;
  long inactivityCutoff=_context.clock().now() - (UDPTransport.EXPIRE_TIMEOUT / 2);
  for (int i=0; i < sz && found < howMany; i++) {
    PeerState cur=peers.get((start + i) % sz);
    RouterInfo ri=_context.netDb().lookupRouterInfoLocally(cur.getRemotePeer());
    if (ri == null) {
      if (_log.shouldLog(Log.INFO))       _log.info("Picked peer has no local routerInfo: " + cur);
      continue;
    }
    RouterAddress ra=ri.getTargetAddress(UDPTransport.STYLE);
    if (ra == null) {
      if (_log.shouldLog(Log.INFO))       _log.info("Picked peer has no SSU address: " + ri);
      continue;
    }
    if (_context.profileOrganizer().isFailing(cur.getRemotePeer()) || _context.shitlist().isShitlisted(cur.getRemotePeer()) || _transport.wasUnreachable(cur.getRemotePeer())) {
      if (_log.shouldLog(Log.INFO))       _log.info("Peer is failing, shistlisted or was unreachable: " + cur);
      continue;
    }
    if (cur.getLastReceiveTime() < inactivityCutoff || cur.getLastSendTime() < inactivityCutoff) {
      if (_log.shouldLog(Log.INFO))       _log.info("Peer is idle too long: " + cur);
      continue;
    }
    if (_log.shouldLog(Log.INFO))     _log.info("Picking introducer: " + cur);
    cur.setIntroducerTime();
    UDPAddress ura=new UDPAddress(ra);
    ssuOptions.setProperty(UDPAddress.PROP_INTRO_HOST_PREFIX + found,cur.getRemoteHostId().toHostString());
    ssuOptions.setProperty(UDPAddress.PROP_INTRO_PORT_PREFIX + found,String.valueOf(cur.getRemotePort()));
    ssuOptions.setProperty(UDPAddress.PROP_INTRO_KEY_PREFIX + found,Base64.encode(ura.getIntroKey()));
    ssuOptions.setProperty(UDPAddress.PROP_INTRO_TAG_PREFIX + found,String.valueOf(cur.getTheyRelayToUsAs()));
    found++;
  }
  long pingCutoff=_context.clock().now() - (2 * 60 * 60* 1000);
  inactivityCutoff=_context.clock().now() - (UDPTransport.EXPIRE_TIMEOUT / 4);
  for (int i=0; i < sz; i++) {
    PeerState cur=peers.get(i);
    if (cur.getIntroducerTime() > pingCutoff && cur.getLastSendTime() < inactivityCutoff) {
      if (_log.shouldLog(Log.INFO))       _log.info("Pinging introducer: " + cur);
      cur.setLastSendTime(_context.clock().now());
      _transport.send(_builder.buildPing(cur));
    }
  }
  return found;
}
