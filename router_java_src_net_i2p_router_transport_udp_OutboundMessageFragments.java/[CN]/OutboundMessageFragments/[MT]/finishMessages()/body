{
synchronized (_activeMessages) {
    for (int i=0; i < _activeMessages.size(); i++) {
      OutboundMessageState state=(OutboundMessageState)_activeMessages.get(i);
      PeerState peer=state.getPeer();
      if (state.isComplete()) {
        _activeMessages.remove(i);
        locked_removeRetransmitter(state);
        _transport.succeeded(state);
        if ((peer != null) && (peer.getSendWindowBytesRemaining() > 0))         _throttle.unchoke(peer.getRemotePeer());
        state.releaseResources();
        if (i < _nextPacketMessage) {
          _nextPacketMessage--;
          if (_nextPacketMessage < 0)           _nextPacketMessage=0;
        }
        if (state.getMessage() != null)         state.getMessage().timestamp("sending complete");
        i--;
      }
 else       if (state.isExpired()) {
        _activeMessages.remove(i);
        locked_removeRetransmitter(state);
        _context.statManager().addRateData("udp.sendFailed",state.getPushCount(),state.getLifetime());
        if (state.getMessage() != null) {
          state.getMessage().timestamp("expired in the active pool");
          _transport.failed(state);
        }
 else {
          if (_log.shouldLog(Log.WARN))           _log.warn("Unable to send an expired direct message: " + state);
        }
        if ((peer != null) && (peer.getSendWindowBytesRemaining() > 0))         _throttle.unchoke(peer.getRemotePeer());
        state.releaseResources();
        if (i < _nextPacketMessage) {
          _nextPacketMessage--;
          if (_nextPacketMessage < 0)           _nextPacketMessage=0;
        }
        i--;
      }
 else       if (state.getPushCount() > MAX_VOLLEYS) {
        _activeMessages.remove(i);
        locked_removeRetransmitter(state);
        _context.statManager().addRateData("udp.sendAggressiveFailed",state.getPushCount(),state.getLifetime());
        if (state.getMessage() != null) {
          state.getMessage().timestamp("too many sends");
          _transport.failed(state);
        }
 else {
          if (_log.shouldLog(Log.WARN))           _log.warn("Unable to send a direct message after too many volleys: " + state);
        }
        if ((peer != null) && (peer.getSendWindowBytesRemaining() > 0))         _throttle.unchoke(peer.getRemotePeer());
        state.releaseResources();
        if (i < _nextPacketMessage) {
          _nextPacketMessage--;
          if (_nextPacketMessage < 0)           _nextPacketMessage=0;
        }
        i--;
      }
    }
    _activeMessages.notifyAll();
  }
}
