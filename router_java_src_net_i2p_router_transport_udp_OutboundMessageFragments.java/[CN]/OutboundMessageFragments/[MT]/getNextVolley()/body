{
  PeerState peer=null;
  OutboundMessageState state=null;
  while (_alive && (state == null)) {
    long now=_context.clock().now();
    long nextSend=-1;
    finishMessages();
    try {
synchronized (_activeMessages) {
        for (int i=0; i < _activeMessages.size(); i++) {
          int cur=(i + _nextPacketMessage) % _activeMessages.size();
          state=(OutboundMessageState)_activeMessages.get(cur);
          peer=state.getPeer();
          if (peer == null)           peer=_transport.getPeerState(state.getMessage().getTarget().getIdentity().calculateHash());
          if ((peer != null) && locked_shouldSend(state,peer)) {
            _nextPacketMessage=i + 1;
            break;
          }
 else {
            if (peer == null) {
              _activeMessages.remove(cur);
              _transport.failed(state);
              if (_log.shouldLog(Log.WARN))               _log.warn("Peer disconnected for " + state);
              if ((peer != null) && (peer.getSendWindowBytesRemaining() > 0))               _throttle.unchoke(peer.getRemotePeer());
              state.releaseResources();
              i--;
            }
            long time=state.getNextSendTime();
            if ((nextSend < 0) || (time < nextSend))             nextSend=time;
            state=null;
            peer=null;
          }
        }
        if (state == null) {
          if (nextSend <= 0) {
            _activeMessages.notifyAll();
            _activeMessages.wait(1000);
          }
 else {
            long delay=nextSend - now;
            if (delay <= 0)             delay=10;
            if (delay > 1000)             delay=1000;
            _allowExcess=true;
            _activeMessages.notifyAll();
            _activeMessages.wait(delay);
          }
        }
 else {
          _activeMessages.notifyAll();
        }
        _allowExcess=false;
      }
    }
 catch (    InterruptedException ie) {
    }
  }
  return preparePackets(state,peer);
}
