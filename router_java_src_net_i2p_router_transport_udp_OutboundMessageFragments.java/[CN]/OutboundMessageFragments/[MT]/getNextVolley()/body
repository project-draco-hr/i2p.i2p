{
  PeerState peer=null;
  OutboundMessageState state=null;
  int peersProcessed=0;
  while (_alive && (state == null)) {
    int nextSendDelay=Integer.MAX_VALUE;
    if (_iterator == null || ((!_activePeers.isEmpty()) && (!_iterator.hasNext()))) {
      _iterator=_activePeers.iterator();
    }
    while (_iterator.hasNext()) {
      peer=_iterator.next();
      int remaining=peer.finishMessages();
      if (remaining <= 0) {
        _iterator.remove();
        if (_log.shouldLog(Log.DEBUG))         _log.debug("No more pending messages for " + peer.getRemotePeer());
        continue;
      }
      peersProcessed++;
      state=peer.allocateSend();
      if (state != null) {
        break;
      }
 else       if (peersProcessed >= _activePeers.size()) {
        break;
      }
 else {
        int delay=peer.getNextDelay();
        if (delay < nextSendDelay)         nextSendDelay=delay;
        peer=null;
      }
    }
    if (peer != null && _log.shouldLog(Log.DEBUG))     _log.debug("Done looping, next peer we are sending for: " + peer.getRemotePeer());
    if (state == null && peersProcessed >= _activePeers.size() && nextSendDelay > 0) {
      _isWaiting=true;
      peersProcessed=0;
      int toWait=Math.min(Math.max(nextSendDelay,10),MAX_WAIT);
      if (_log.shouldLog(Log.DEBUG))       _log.debug("wait for " + toWait);
synchronized (_activePeers) {
        try {
          _activePeers.wait(toWait);
        }
 catch (        InterruptedException ie) {
          if (_log.shouldLog(Log.DEBUG))           _log.debug("Woken up while waiting");
        }
      }
      _isWaiting=false;
    }
  }
  if (_log.shouldLog(Log.DEBUG))   _log.debug("Sending " + state);
  UDPPacket packets[]=preparePackets(state,peer);
  return packets;
}
