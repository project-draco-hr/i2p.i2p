{
  long now=_context.clock().now();
  if (state.getNextSendTime() <= now) {
    if (!state.isFragmented()) {
      state.fragment(fragmentSize(peer.getMTU()));
      if (_log.shouldLog(Log.INFO))       _log.info("Fragmenting " + state);
    }
    int size=state.getUnackedSize();
    if (peer.allocateSendingBytes(size)) {
      if (_log.shouldLog(Log.INFO))       _log.info("Allocation of " + size + " allowed with "+ peer.getSendWindowBytesRemaining()+ "/"+ peer.getSendWindowBytes()+ " remaining"+ " for message "+ state.getMessageId()+ ": "+ state);
      if (state.getPushCount() > 0) {
        int fragments=state.getFragmentCount();
        int toSend=0;
        for (int i=0; i < fragments; i++) {
          if (state.needsSending(i))           toSend++;
        }
        peer.messageRetransmitted(toSend);
        if (_log.shouldLog(Log.WARN))         _log.warn("Retransmitting " + state + " to "+ peer);
        _context.statManager().addRateData("udp.sendVolleyTime",state.getLifetime(),toSend);
      }
      state.push();
      int rto=peer.getRTO();
      state.setNextSendTime(now + rto);
      if (peer.getSendWindowBytesRemaining() > 0)       _throttle.unchoke(peer.getRemotePeer());
      return true;
    }
 else {
      _context.statManager().addRateData("udp.sendRejected",state.getPushCount(),state.getLifetime());
      if (_log.shouldLog(Log.WARN))       _log.warn("Allocation of " + size + " rejected w/ wsize="+ peer.getSendWindowBytes()+ " available="+ peer.getSendWindowBytesRemaining()+ " for message "+ state.getMessageId()+ ": "+ state);
      state.setNextSendTime(now + (_context.random().nextInt(2 * ACKSender.ACK_FREQUENCY)));
      if (_log.shouldLog(Log.WARN))       _log.warn("Retransmit after choke for next send time in " + (state.getNextSendTime() - now) + "ms");
      _throttle.choke(peer.getRemotePeer());
    }
  }
  return false;
}
