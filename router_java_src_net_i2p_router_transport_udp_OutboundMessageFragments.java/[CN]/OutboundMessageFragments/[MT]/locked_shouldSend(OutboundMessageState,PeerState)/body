{
  long now=_context.clock().now();
  if (state.getNextSendTime() <= now) {
    if (!state.isFragmented()) {
      state.fragment(fragmentSize(peer.getMTU()));
      if (state.getMessage() != null)       state.getMessage().timestamp("fragment into " + state.getFragmentCount());
      if (_log.shouldLog(Log.INFO))       _log.info("Fragmenting " + state);
    }
    OutboundMessageState curRetransMsg=(OutboundMessageState)_retransmitters.get(peer);
    if ((curRetransMsg != null) && ((curRetransMsg.isExpired() || curRetransMsg.isComplete()))) {
      _retransmitters.remove(peer);
      curRetransMsg=null;
    }
    if ((curRetransMsg != null) && (curRetransMsg != state)) {
      _context.statManager().addRateData("udp.blockedRetransmissions",peer.getPacketsRetransmitted(),peer.getPacketsTransmitted());
      if ((state.getMaxSends() <= 0) && (!THROTTLE_INITIAL_SEND)) {
        if (state.getMessage() != null)         state.getMessage().timestamp("another message is retransmitting, but we want to send our first volley...");
      }
 else       if ((state.getMaxSends() <= 0) || (THROTTLE_RESENDS)) {
        if (state.getMessage() != null)         state.getMessage().timestamp("choked, with another message retransmitting");
        return false;
      }
 else {
        if (state.getMessage() != null)         state.getMessage().timestamp("another message is retransmitting, but since we've already begun sending...");
      }
    }
    int size=state.getUnackedSize();
    if (peer.allocateSendingBytes(size)) {
      if (_log.shouldLog(Log.INFO))       _log.info("Allocation of " + size + " allowed with "+ peer.getSendWindowBytesRemaining()+ "/"+ peer.getSendWindowBytes()+ " remaining"+ " for message "+ state.getMessageId()+ ": "+ state);
      if (state.getPushCount() > 0) {
        _retransmitters.put(peer,state);
        int fragments=state.getFragmentCount();
        int toSend=0;
        for (int i=0; i < fragments; i++) {
          if (state.needsSending(i))           toSend++;
        }
        peer.messageRetransmitted(toSend);
        _packetsRetransmitted+=toSend;
        _context.statManager().addRateData("udp.peerPacketsRetransmitted",peer.getPacketsRetransmitted(),peer.getPacketsTransmitted());
        _context.statManager().addRateData("udp.packetsRetransmitted",_packetsRetransmitted,peer.getPacketsTransmitted());
        if (_log.shouldLog(Log.WARN))         _log.warn("Retransmitting " + state + " to "+ peer);
        _context.statManager().addRateData("udp.sendVolleyTime",state.getLifetime(),toSend);
      }
      state.push();
      int rto=peer.getRTO();
      state.setNextSendTime(now + rto);
      if (peer.getSendWindowBytesRemaining() > 0)       _throttle.unchoke(peer.getRemotePeer());
      return true;
    }
 else {
      _context.statManager().addRateData("udp.sendRejected",state.getPushCount(),state.getLifetime());
      if (state.getMessage() != null)       state.getMessage().timestamp("send rejected, available=" + peer.getSendWindowBytesRemaining());
      if (_log.shouldLog(Log.WARN))       _log.warn("Allocation of " + size + " rejected w/ wsize="+ peer.getSendWindowBytes()+ " available="+ peer.getSendWindowBytesRemaining()+ " for message "+ state.getMessageId()+ ": "+ state);
      state.setNextSendTime(now + (_context.random().nextInt(2 * ACKSender.ACK_FREQUENCY)));
      if (_log.shouldLog(Log.WARN))       _log.warn("Retransmit after choke for next send time in " + (state.getNextSendTime() - now) + "ms");
      _throttle.choke(peer.getRemotePeer());
      if (state.getMessage() != null)       state.getMessage().timestamp("choked, not enough available, wsize=" + peer.getSendWindowBytes() + " available="+ peer.getSendWindowBytesRemaining());
      return false;
    }
  }
  return false;
}
