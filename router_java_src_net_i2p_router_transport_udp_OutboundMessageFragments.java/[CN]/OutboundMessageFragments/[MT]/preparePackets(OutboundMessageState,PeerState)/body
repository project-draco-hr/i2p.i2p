{
  if ((state != null) && (peer != null)) {
    int fragments=state.getFragmentCount();
    if (fragments < 0)     return null;
    List<Long> msgIds=peer.getCurrentFullACKs();
    List<ACKBitfield> partialACKBitfields=new ArrayList();
    peer.fetchPartialACKs(partialACKBitfields);
    int piggybackedPartialACK=partialACKBitfields.size();
    List<Long> remaining=new ArrayList(msgIds);
    int sparseCount=0;
    UDPPacket rv[]=new UDPPacket[fragments];
    for (int i=0; i < fragments; i++) {
      if (state.needsSending(i)) {
        try {
          rv[i]=_builder.buildPacket(state,i,peer,remaining,partialACKBitfields);
        }
 catch (        ArrayIndexOutOfBoundsException aioobe) {
          _log.log(Log.CRIT,"Corrupt trying to build a packet - please tell jrandom: " + partialACKBitfields + " / "+ remaining+ " / "+ msgIds);
          sparseCount++;
          continue;
        }
        if (rv[i] == null) {
          sparseCount++;
          continue;
        }
        rv[i].setFragmentCount(fragments);
        OutNetMessage msg=state.getMessage();
        if (msg != null)         rv[i].setMessageType(msg.getMessageTypeId());
 else         rv[i].setMessageType(-1);
      }
 else {
        sparseCount++;
      }
    }
    if (sparseCount > 0)     remaining.clear();
    int piggybackedAck=0;
    if (msgIds.size() != remaining.size()) {
      for (int i=0; i < msgIds.size(); i++) {
        Long id=msgIds.get(i);
        if (!remaining.contains(id)) {
          peer.removeACKMessage(id);
          piggybackedAck++;
        }
      }
    }
    if (sparseCount > 0)     _context.statManager().addRateData("udp.sendSparse",sparseCount,state.getLifetime());
    if (piggybackedAck > 0)     _context.statManager().addRateData("udp.sendPiggyback",piggybackedAck,state.getLifetime());
    if (piggybackedPartialACK - partialACKBitfields.size() > 0)     _context.statManager().addRateData("udp.sendPiggybackPartial",piggybackedPartialACK - partialACKBitfields.size(),state.getLifetime());
    if (_log.shouldLog(Log.INFO))     _log.info("Building packet for " + state + " to "+ peer+ " with sparse count: "+ sparseCount);
    peer.packetsTransmitted(fragments - sparseCount);
    if (state.getPushCount() > 1) {
      int toSend=fragments - sparseCount;
      peer.messageRetransmitted(toSend);
      _context.statManager().addRateData("udp.peerPacketsRetransmitted",peer.getPacketsRetransmitted(),peer.getPacketsTransmitted());
      _context.statManager().addRateData("udp.packetsRetransmitted",state.getLifetime(),peer.getPacketsTransmitted());
      if (_log.shouldLog(Log.INFO))       _log.info("Retransmitting " + state + " to "+ peer);
      _context.statManager().addRateData("udp.sendVolleyTime",state.getLifetime(),toSend);
    }
    return rv;
  }
 else {
    return null;
  }
}
