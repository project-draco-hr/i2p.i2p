{
  UDPPacket packet=UDPPacket.acquire(_context);
  StringBuffer msg=null;
  boolean acksIncluded=false;
  if (_log.shouldLog(Log.INFO)) {
    msg=new StringBuffer(128);
    msg.append("Send to ").append(peer.getRemotePeer().toBase64());
    msg.append(" msg ").append(state.getMessageId()).append(":").append(fragment);
    if (fragment == state.getFragmentCount() - 1)     msg.append("*");
  }
  byte data[]=packet.getPacket().getData();
  Arrays.fill(data,0,data.length,(byte)0x0);
  int start=UDPPacket.MAC_SIZE + UDPPacket.IV_SIZE;
  int off=start;
  data[off]|=(UDPPacket.PAYLOAD_TYPE_DATA << 4);
  off++;
  long now=_context.clock().now() / 1000;
  DataHelper.toLong(data,off,4,now);
  off+=4;
  data[off]|=UDPPacket.DATA_FLAG_WANT_REPLY;
  if ((ackIdsRemaining != null) && (ackIdsRemaining.size() > 0))   data[off]|=UDPPacket.DATA_FLAG_EXPLICIT_ACK;
  if ((partialACKsRemaining != null) && (partialACKsRemaining.size() > 0))   data[off]|=UDPPacket.DATA_FLAG_ACK_BITFIELDS;
  off++;
  if ((ackIdsRemaining != null) && (ackIdsRemaining.size() > 0)) {
    DataHelper.toLong(data,off,1,ackIdsRemaining.size());
    off++;
    for (int i=0; i < ackIdsRemaining.size(); i++) {
      Long ackId=(Long)ackIdsRemaining.get(i);
      DataHelper.toLong(data,off,4,ackId.longValue());
      off+=4;
      if (msg != null)       msg.append(" full ack: ").append(ackId.longValue());
      acksIncluded=true;
    }
  }
  if ((partialACKsRemaining != null) && (partialACKsRemaining.size() > 0)) {
    int origNumRemaining=partialACKsRemaining.size();
    int numPartialOffset=off;
    off++;
    for (int i=0; i < partialACKsRemaining.size(); i++) {
      ACKBitfield bitfield=(ACKBitfield)partialACKsRemaining.get(i);
      if (bitfield.receivedComplete())       continue;
      DataHelper.toLong(data,off,4,bitfield.getMessageId());
      off+=4;
      int bits=bitfield.fragmentCount();
      int size=(bits / 7) + 1;
      for (int curByte=0; curByte < size; curByte++) {
        if (curByte + 1 < size)         data[off]|=(byte)(1 << 7);
        for (int curBit=0; curBit < 7; curBit++) {
          if (bitfield.received(curBit + 7 * curByte))           data[off]|=(byte)(1 << curBit);
        }
        off++;
      }
      partialACKsRemaining.remove(i);
      if (msg != null)       msg.append(" partial ack: ").append(bitfield);
      acksIncluded=true;
      i--;
    }
    DataHelper.toLong(data,numPartialOffset,1,origNumRemaining - partialACKsRemaining.size());
  }
  if ((msg != null) && (acksIncluded))   _log.debug(msg.toString());
  DataHelper.toLong(data,off,1,1);
  off++;
  DataHelper.toLong(data,off,4,state.getMessageId());
  off+=4;
  data[off]|=fragment << 1;
  if (fragment == state.getFragmentCount() - 1)   data[off]|=1;
  off++;
  int size=state.fragmentSize(fragment);
  if (size < 0)   return null;
  DataHelper.toLong(data,off,2,size);
  data[off]&=(byte)0x3F;
  off+=2;
  int sizeWritten=state.writeFragment(data,off,fragment);
  if (sizeWritten != size)   _log.error("Size written: " + sizeWritten + " but size: "+ size+ " for fragment "+ fragment+ " of "+ state.getMessageId());
 else   if (_log.shouldLog(Log.DEBUG))   _log.debug("Size written: " + sizeWritten + " for fragment "+ fragment+ " of "+ state.getMessageId());
  size=sizeWritten;
  if (size < 0)   return null;
  off+=size;
  int padSize=16 - (off % 16);
  if (padSize > 0) {
    ByteArray block=_blockCache.acquire();
    _context.random().nextBytes(block.getData());
    System.arraycopy(block.getData(),0,data,off,padSize);
    _blockCache.release(block);
    off+=padSize;
  }
  packet.getPacket().setLength(off);
  authenticate(packet,peer.getCurrentCipherKey(),peer.getCurrentMACKey());
  setTo(packet,peer.getRemoteIPAddress(),peer.getRemotePort());
  if (_log.shouldLog(Log.INFO)) {
    _log.info(msg.toString());
  }
  return packet;
}
