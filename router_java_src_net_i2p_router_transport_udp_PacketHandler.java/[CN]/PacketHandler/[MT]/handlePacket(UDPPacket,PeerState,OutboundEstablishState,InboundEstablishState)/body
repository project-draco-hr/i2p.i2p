{
  _reader.initialize(packet);
  long now=_context.clock().now();
  long when=_reader.readTimestamp() * 1000;
  long skew=now - when;
  if (skew > GRACE_PERIOD) {
    if (_log.shouldLog(Log.WARN))     _log.warn("Packet too far in the future: " + new Date(when) + ": "+ packet);
    return;
  }
 else   if (skew < 0 - GRACE_PERIOD) {
    if (_log.shouldLog(Log.WARN))     _log.warn("Packet too far in the past: " + new Date(when) + ": "+ packet);
    return;
  }
  _context.statManager().addRateData("udp.receivePacketSkew",skew,packet.getLifetime());
  InetAddress fromHost=packet.getPacket().getAddress();
  int fromPort=packet.getPacket().getPort();
  String from=PeerState.calculateRemoteHostString(fromHost.getAddress(),fromPort);
switch (_reader.readPayloadType()) {
case UDPPacket.PAYLOAD_TYPE_SESSION_REQUEST:
    _establisher.receiveSessionRequest(from,fromHost,fromPort,_reader);
  break;
case UDPPacket.PAYLOAD_TYPE_SESSION_CONFIRMED:
_establisher.receiveSessionConfirmed(from,_reader);
break;
case UDPPacket.PAYLOAD_TYPE_SESSION_CREATED:
_establisher.receiveSessionCreated(from,_reader);
break;
case UDPPacket.PAYLOAD_TYPE_DATA:
if (outState != null) state=_establisher.receiveData(outState);
handleData(packet,state);
break;
default :
if (_log.shouldLog(Log.WARN)) _log.warn("Unknown payload type: " + _reader.readPayloadType());
return;
}
}
