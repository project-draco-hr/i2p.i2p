{
  reader.initialize(packet);
  long recvOn=packet.getBegin();
  long sendOn=reader.readTimestamp() * 1000;
  long skew=recvOn - sendOn;
  if (skew > GRACE_PERIOD) {
    if (_log.shouldLog(Log.WARN))     _log.warn("Packet too far in the future: " + new Date(sendOn / 1000) + ": "+ packet);
    _context.statManager().addRateData("udp.droppedInvalidSkew",skew,packet.getExpiration());
    return;
  }
 else   if (skew < 0 - GRACE_PERIOD) {
    if (_log.shouldLog(Log.WARN))     _log.warn("Packet too far in the past: " + new Date(sendOn / 1000) + ": "+ packet);
    _context.statManager().addRateData("udp.droppedInvalidSkew",0 - skew,packet.getExpiration());
    return;
  }
  if (state != null) {
    if (_log.shouldLog(Log.DEBUG))     _log.debug("Received packet from " + state.getRemoteHostId().toString() + " with skew "+ skew);
    state.adjustClockSkew((short)skew);
  }
  _context.statManager().addRateData("udp.receivePacketSkew",skew,packet.getLifetime());
  RemoteHostId from=packet.getRemoteHost();
switch (reader.readPayloadType()) {
case UDPPacket.PAYLOAD_TYPE_SESSION_REQUEST:
    _establisher.receiveSessionRequest(from,reader);
  break;
case UDPPacket.PAYLOAD_TYPE_SESSION_CONFIRMED:
_establisher.receiveSessionConfirmed(from,reader);
break;
case UDPPacket.PAYLOAD_TYPE_SESSION_CREATED:
_establisher.receiveSessionCreated(from,reader);
break;
case UDPPacket.PAYLOAD_TYPE_DATA:
if (outState != null) state=_establisher.receiveData(outState);
if (_log.shouldLog(Log.INFO)) _log.info("Received new DATA packet from " + state + ": "+ packet);
_inbound.receiveData(state,reader.getDataReader());
break;
case UDPPacket.PAYLOAD_TYPE_TEST:
_testManager.receiveTest(from,reader);
break;
default :
if (_log.shouldLog(Log.WARN)) _log.warn("Unknown payload type: " + reader.readPayloadType());
_context.statManager().addRateData("udp.droppedInvalidUnknown",packet.getLifetime(),packet.getExpiration());
return;
}
}
