{
  boolean isValid=packet.validate(state.getCurrentMACKey());
  if (!isValid) {
    if (state.getNextMACKey() != null)     isValid=packet.validate(state.getNextMACKey());
    if (!isValid) {
      if (_log.shouldLog(Log.WARN))       _log.warn("Failed validation with existing con, trying as new con: " + packet);
      isValid=packet.validate(_transport.getIntroKey());
      if (isValid) {
        if (_log.shouldLog(Log.INFO))         _log.info("Validation with existing con failed, but validation as reestablish/stray passed");
        packet.decrypt(_transport.getIntroKey());
      }
 else {
        InetAddress remAddr=packet.getPacket().getAddress();
        int remPort=packet.getPacket().getPort();
        InboundEstablishState est=_establisher.getInboundState(remAddr,remPort);
        if (est != null) {
          if (_log.shouldLog(Log.DEBUG))           _log.debug("Packet from an existing peer IS for an inbound establishment");
          receivePacket(reader,packet,est,false);
        }
 else {
          if (_log.shouldLog(Log.WARN))           _log.warn("Validation with existing con failed, and validation as reestablish failed too.  DROP");
          _context.statManager().addRateData("udp.droppedInvalidReestablish",packet.getLifetime(),packet.getExpiration());
        }
        return;
      }
    }
 else {
      packet.decrypt(state.getNextCipherKey());
    }
  }
 else {
    packet.decrypt(state.getCurrentCipherKey());
  }
  handlePacket(reader,packet,state,null,null);
}
