{
  _context=ctx;
  _log=ctx.logManager().getLog(PeerState.class);
  _transport=transport;
  _remotePeer=null;
  _currentMACKey=null;
  _currentCipherKey=null;
  _nextMACKey=null;
  _nextCipherKey=null;
  _nextKeyingMaterial=null;
  _rekeyBeganLocally=false;
  _keyEstablishedTime=-1;
  _clockSkew=0;
  _currentReceiveSecond=-1;
  _lastSendTime=-1;
  _lastReceiveTime=-1;
  _currentACKs=new ArrayList(8);
  _currentACKsResend=new ArrayList(8);
  _currentSecondECNReceived=false;
  _remoteWantsPreviousACKs=false;
  _sendWindowBytes=DEFAULT_SEND_WINDOW_BYTES;
  _sendWindowBytesRemaining=DEFAULT_SEND_WINDOW_BYTES;
  _slowStartThreshold=MAX_SEND_WINDOW_BYTES / 2;
  _lastSendRefill=_context.clock().now();
  _receivePeriodBegin=_lastSendRefill;
  _sendBps=0;
  _sendBytes=0;
  _receiveBps=0;
  _lastCongestionOccurred=-1;
  _remoteIP=null;
  _remotePort=-1;
  _remoteRequiresIntroduction=false;
  _weRelayToThemAs=0;
  _theyRelayToUsAs=0;
  _mtu=getDefaultMTU();
  _mtuReceive=_mtu;
  _mtuLastChecked=-1;
  _lastACKSend=-1;
  _rto=MIN_RTO;
  _rtt=_rto / 2;
  _rttDeviation=_rtt;
  _messagesReceived=0;
  _messagesSent=0;
  _packetsTransmitted=0;
  _packetsRetransmitted=0;
  _packetRetransmissionRate=0;
  _retransmissionPeriodStart=0;
  _packetsReceived=0;
  _packetsReceivedDuplicate=0;
  _inboundMessages=new HashMap(8);
  _outboundMessages=new ArrayList(32);
  _dead=false;
  _isInbound=false;
  _lastIntroducerTime=0;
  _context.statManager().createRateStat("udp.congestionOccurred","How large the cwin was when congestion occurred (duration == sendBps)","udp",UDPTransport.RATES);
  _context.statManager().createRateStat("udp.congestedRTO","retransmission timeout after congestion (duration == rtt dev)","udp",UDPTransport.RATES);
  _context.statManager().createRateStat("udp.sendACKPartial","Number of partial ACKs sent (duration == number of full ACKs in that ack packet)","udp",UDPTransport.RATES);
  _context.statManager().createRateStat("udp.sendBps","How fast we are transmitting when a packet is acked","udp",UDPTransport.RATES);
  _context.statManager().createRateStat("udp.receiveBps","How fast we are receiving when a packet is fully received (at most one per second)","udp",UDPTransport.RATES);
  _context.statManager().createRateStat("udp.mtuIncrease","How many retransmissions have there been to the peer when the MTU was increased (period is total packets transmitted)","udp",UDPTransport.RATES);
  _context.statManager().createRateStat("udp.mtuDecrease","How many retransmissions have there been to the peer when the MTU was decreased (period is total packets transmitted)","udp",UDPTransport.RATES);
  _context.statManager().createRateStat("udp.rejectConcurrentActive","How many messages are currently being sent to the peer when we reject it (period is how many concurrent packets we allow)","udp",UDPTransport.RATES);
  _context.statManager().createRateStat("udp.allowConcurrentActive","How many messages are currently being sent to the peer when we accept it (period is how many concurrent packets we allow)","udp",UDPTransport.RATES);
  _context.statManager().createRateStat("udp.rejectConcurrentSequence","How many consecutive concurrency rejections have we had when we stop rejecting (period is how many concurrent packets we are on)","udp",UDPTransport.RATES);
  _context.statManager().createRateStat("udp.queueDropSize","How many messages were queued up when it was considered full, causing a tail drop?","udp",UDPTransport.RATES);
  _context.statManager().createRateStat("udp.queueAllowTotalLifetime","When a peer is retransmitting and we probabalistically allow a new message, what is the sum of the pending message lifetimes? (period is the new message's lifetime)?","udp",UDPTransport.RATES);
}
