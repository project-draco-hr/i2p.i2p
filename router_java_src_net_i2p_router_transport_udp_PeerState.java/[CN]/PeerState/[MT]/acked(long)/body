{
  OutboundMessageState state=null;
  List msgs=_outboundMessages;
  if (_dead)   return 0;
synchronized (msgs) {
    int sz=msgs.size();
    for (int i=0; i < sz; i++) {
      state=(OutboundMessageState)msgs.get(i);
      if (state.getMessageId() == messageId) {
        msgs.remove(i);
        break;
      }
 else {
        state=null;
      }
    }
    if ((state != null) && (state == _retransmitter))     _retransmitter=null;
  }
  if (state != null) {
    int numSends=state.getMaxSends();
    if (_log.shouldLog(Log.INFO))     _log.info("Received ack of " + messageId + " by "+ _remotePeer.toBase64()+ " after "+ state.getLifetime()+ " and "+ numSends+ " sends");
    _context.statManager().addRateData("udp.sendConfirmTime",state.getLifetime(),state.getLifetime());
    if (state.getFragmentCount() > 1)     _context.statManager().addRateData("udp.sendConfirmFragments",state.getFragmentCount(),state.getLifetime());
    if (numSends > 1)     _context.statManager().addRateData("udp.sendConfirmVolley",numSends,state.getFragmentCount());
    _transport.succeeded(state);
    int numFragments=state.getFragmentCount();
    messageACKed(numFragments * state.getFragmentSize(),state.getLifetime(),numSends);
    state.releaseResources();
    return numFragments;
  }
 else {
    if (_log.shouldLog(Log.DEBUG))     _log.debug("Received an ACK for a message not pending: " + messageId);
    return 0;
  }
}
