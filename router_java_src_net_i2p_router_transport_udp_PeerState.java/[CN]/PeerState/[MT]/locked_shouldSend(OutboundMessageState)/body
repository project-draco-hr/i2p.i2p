{
  long now=_context.clock().now();
  if (state.getNextSendTime() <= now) {
    if (!state.isFragmented()) {
      state.fragment(fragmentSize(getMTU()));
      if (state.getMessage() != null)       state.getMessage().timestamp("fragment into " + state.getFragmentCount());
      if (_log.shouldLog(Log.INFO))       _log.info("Fragmenting " + state);
    }
    if ((_retransmitter != null) && ((_retransmitter.isExpired() || _retransmitter.isComplete())))     _retransmitter=null;
    if ((_retransmitter != null) && (_retransmitter != state)) {
      _context.statManager().addRateData("udp.blockedRetransmissions",getPacketsRetransmitted(),getPacketsTransmitted());
      if ((state.getMaxSends() <= 0) && (!THROTTLE_INITIAL_SEND)) {
        if (state.getMessage() != null)         state.getMessage().timestamp("another message is retransmitting, but we want to send our first volley...");
      }
 else       if ((state.getMaxSends() <= 0) || (THROTTLE_RESENDS)) {
        if (state.getMessage() != null)         state.getMessage().timestamp("choked, with another message retransmitting");
        return false;
      }
 else {
        if (state.getMessage() != null)         state.getMessage().timestamp("another message is retransmitting, but since we've already begun sending...");
      }
    }
    int size=state.getUnackedSize();
    if (allocateSendingBytes(size,state.getPushCount())) {
      if (_log.shouldLog(Log.INFO))       _log.info("Allocation of " + size + " allowed with "+ getSendWindowBytesRemaining()+ "/"+ getSendWindowBytes()+ " remaining"+ " for message "+ state.getMessageId()+ ": "+ state);
      if (state.getPushCount() > 0)       _retransmitter=state;
      state.push();
      int rto=getRTO();
      state.setNextSendTime(now + rto);
      return true;
    }
 else {
      _context.statManager().addRateData("udp.sendRejected",state.getPushCount(),state.getLifetime());
      if (state.getMessage() != null)       state.getMessage().timestamp("send rejected, available=" + getSendWindowBytesRemaining());
      if (_log.shouldLog(Log.WARN))       _log.warn("Allocation of " + size + " rejected w/ wsize="+ getSendWindowBytes()+ " available="+ getSendWindowBytesRemaining()+ " for message "+ state.getMessageId()+ ": "+ state);
      state.setNextSendTime(now + (_context.random().nextInt(2 * ACKSender.ACK_FREQUENCY)));
      if (_log.shouldLog(Log.WARN))       _log.warn("Retransmit after choke for next send time in " + (state.getNextSendTime() - now) + "ms");
      if (state.getMessage() != null)       state.getMessage().timestamp("choked, not enough available, wsize=" + getSendWindowBytes() + " available="+ getSendWindowBytesRemaining());
      return false;
    }
  }
  return false;
}
