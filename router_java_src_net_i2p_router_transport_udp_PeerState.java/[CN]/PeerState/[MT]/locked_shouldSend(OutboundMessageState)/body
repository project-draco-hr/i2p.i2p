{
  long now=_context.clock().now();
  if (state.getNextSendTime() <= now) {
    if (!state.isFragmented()) {
      state.fragment(fragmentSize(getMTU()));
      if (state.getMessage() != null)       state.getMessage().timestamp("fragment into " + state.getFragmentCount());
      if (_log.shouldLog(Log.INFO))       _log.info("Fragmenting " + state);
    }
    OutboundMessageState retrans=_retransmitter;
    if ((retrans != null) && ((retrans.isExpired() || retrans.isComplete()))) {
      _retransmitter=null;
      retrans=null;
    }
    if ((retrans != null) && (retrans != state)) {
      _context.statManager().addRateData("udp.blockedRetransmissions",_packetsRetransmitted,_packetsTransmitted);
      int max=state.getMaxSends();
      if ((max <= 0) && (!THROTTLE_INITIAL_SEND)) {
      }
 else       if ((max <= 0) || (THROTTLE_RESENDS)) {
        return false;
      }
 else {
      }
    }
    int size=state.getUnackedSize();
    if (allocateSendingBytes(size,state.getPushCount())) {
      if (_log.shouldLog(Log.INFO))       _log.info("Allocation of " + size + " allowed with "+ getSendWindowBytesRemaining()+ "/"+ getSendWindowBytes()+ " remaining"+ " for message "+ state.getMessageId()+ ": "+ state);
      if (state.getPushCount() > 0)       _retransmitter=state;
      state.push();
      int rto=getRTO();
      state.setNextSendTime(now + rto);
      return true;
    }
 else {
      _context.statManager().addRateData("udp.sendRejected",state.getPushCount(),state.getLifetime());
      if (_log.shouldLog(Log.WARN))       _log.warn("Allocation of " + size + " rejected w/ wsize="+ getSendWindowBytes()+ " available="+ getSendWindowBytesRemaining()+ " for message "+ state.getMessageId()+ ": "+ state);
      state.setNextSendTime(now + (_context.random().nextInt(2 * ACKSender.ACK_FREQUENCY)));
      if (_log.shouldLog(Log.WARN))       _log.warn("Retransmit after choke for next send time in " + (state.getNextSendTime() - now) + "ms");
      return false;
    }
  }
  return false;
}
