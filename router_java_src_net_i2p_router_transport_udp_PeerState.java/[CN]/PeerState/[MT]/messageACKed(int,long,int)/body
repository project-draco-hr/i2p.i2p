{
  _consecutiveFailedSends=0;
  _lastFailedSendPeriod=-1;
  if (numSends < 2) {
    if (_sendWindowBytes <= _slowStartThreshold) {
      _sendWindowBytes+=bytesACKed;
    }
 else {
      if (false) {
        _sendWindowBytes+=16;
      }
 else {
        float prob=((float)bytesACKed) / ((float)(_sendWindowBytes << 1));
        float v=_context.random().nextFloat();
        if (v < 0)         v=0 - v;
        if (v <= prob)         _sendWindowBytes+=bytesACKed;
      }
    }
  }
  if (_sendWindowBytes > MAX_SEND_WINDOW_BYTES)   _sendWindowBytes=MAX_SEND_WINDOW_BYTES;
  _lastReceiveTime=_context.clock().now();
  _lastSendFullyTime=_lastReceiveTime;
  if (true) {
    if (_sendWindowBytesRemaining + bytesACKed <= _sendWindowBytes)     _sendWindowBytesRemaining+=bytesACKed;
 else     _sendWindowBytesRemaining=_sendWindowBytes;
  }
  _messagesSent++;
  if (numSends < 2) {
    recalculateTimeouts(lifetime);
    if (_mtu <= MIN_MTU) {
      if (_context.random().nextInt(50 * (int)_mtuDecreases) <= 0) {
        _context.statManager().addRateData("udp.mtuIncrease",_packetsRetransmitted,_packetsTransmitted);
        _mtu=LARGE_MTU;
        _mtuIncreases++;
      }
    }
  }
 else   if (_log.shouldLog(Log.WARN))   _log.warn("acked after numSends=" + numSends + " w/ lifetime="+ lifetime+ " and size="+ bytesACKed);
  _context.statManager().addRateData("udp.sendBps",_sendBps,lifetime);
}
