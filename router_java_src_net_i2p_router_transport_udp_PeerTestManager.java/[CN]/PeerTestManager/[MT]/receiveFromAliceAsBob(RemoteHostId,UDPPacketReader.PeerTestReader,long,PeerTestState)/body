{
  PeerState charlie=null;
  RouterInfo charlieInfo=null;
  if (state == null) {
    charlie=_transport.pickTestPeer(from);
    if (charlie != null)     charlieInfo=_context.netDb().lookupRouterInfoLocally(charlie.getRemotePeer());
  }
 else {
    charlie=_transport.getPeerState(new RemoteHostId(state.getCharlieIP().getAddress(),state.getCharliePort()));
    if (charlie != null)     charlieInfo=_context.netDb().lookupRouterInfoLocally(charlie.getRemotePeer());
  }
  if ((charlie == null) || (charlieInfo == null)) {
    if (_log.shouldLog(Log.WARN))     _log.warn("Unable to pick a charlie");
    return;
  }
  InetAddress aliceIP=null;
  SessionKey aliceIntroKey=null;
  try {
    aliceIP=InetAddress.getByAddress(from.getIP());
    aliceIntroKey=new SessionKey(new byte[SessionKey.KEYSIZE_BYTES]);
    testInfo.readIntroKey(aliceIntroKey.getData(),0);
    RouterAddress raddr=charlieInfo.getTargetAddress(UDPTransport.STYLE);
    if (raddr == null) {
      if (_log.shouldLog(Log.WARN))       _log.warn("Unable to pick a charlie");
      return;
    }
    UDPAddress addr=new UDPAddress(raddr);
    SessionKey charlieIntroKey=new SessionKey(addr.getIntroKey());
    boolean isNew=false;
    if (state == null) {
      isNew=true;
      state=new PeerTestState();
      state.setBeginTime(_context.clock().now());
    }
    state.setAliceIP(aliceIP);
    state.setAlicePort(from.getPort());
    state.setAliceIntroKey(aliceIntroKey);
    state.setNonce(nonce);
    state.setCharlieIP(charlie.getRemoteIPAddress());
    state.setCharliePort(charlie.getRemotePort());
    state.setCharlieIntroKey(charlieIntroKey);
    state.setLastSendTime(_context.clock().now());
    state.setOurRole(PeerTestState.BOB);
    state.setReceiveAliceTime(_context.clock().now());
    state.incrementPacketsRelayed();
    if (state.getPacketsRelayed() > MAX_RELAYED_PER_TEST) {
      if (_log.shouldLog(Log.WARN))       _log.warn("Receive from alice (" + aliceIP + ":"+ from.getPort()+ ") as bob, but we've already relayed too many packets to that test, so we're dropping it");
      return;
    }
    if (isNew) {
      _activeTests.put(Long.valueOf(nonce),state);
      _context.simpleScheduler().addEvent(new RemoveTest(nonce),MAX_CHARLIE_LIFETIME);
    }
    UDPPacket packet=_packetBuilder.buildPeerTestToCharlie(aliceIP,from.getPort(),aliceIntroKey,nonce,charlie.getRemoteIPAddress(),charlie.getRemotePort(),charlie.getCurrentCipherKey(),charlie.getCurrentMACKey());
    if (_log.shouldLog(Log.DEBUG))     _log.debug("Receive from alice as bob for " + nonce + ", picking charlie @ "+ charlie.getRemoteIPAddress()+ ":"+ charlie.getRemotePort()+ " for alice @ "+ aliceIP+ ":"+ from.getPort());
    _transport.send(packet);
  }
 catch (  UnknownHostException uhe) {
    if (_log.shouldLog(Log.WARN))     _log.warn("Unable to build the aliceIP from " + from,uhe);
    _context.statManager().addRateData("udp.testBadIP",1);
  }
}
