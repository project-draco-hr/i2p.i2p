{
  boolean isNew=false;
  if (state == null) {
    isNew=true;
    state=new PeerTestState();
    state.setOurRole(PeerTestState.CHARLIE);
  }
  if (_log.shouldLog(Log.DEBUG))   _log.debug("Receive test as charlie nonce " + nonce);
  int sz=testInfo.readIPSize();
  byte aliceIPData[]=new byte[sz];
  try {
    testInfo.readIP(aliceIPData,0);
    int alicePort=testInfo.readPort();
    InetAddress aliceIP=InetAddress.getByAddress(aliceIPData);
    InetAddress bobIP=InetAddress.getByAddress(from.getIP());
    SessionKey aliceIntroKey=new SessionKey(new byte[SessionKey.KEYSIZE_BYTES]);
    testInfo.readIntroKey(aliceIntroKey.getData(),0);
    state.setAliceIP(aliceIP);
    state.setAlicePort(alicePort);
    state.setAliceIntroKey(aliceIntroKey);
    state.setNonce(nonce);
    state.setBobIP(bobIP);
    state.setBobPort(from.getPort());
    state.setLastSendTime(_context.clock().now());
    state.setOurRole(PeerTestState.CHARLIE);
    state.setReceiveBobTime(_context.clock().now());
    PeerState bob=_transport.getPeerState(from);
    if (bob == null) {
      if (_log.shouldLog(Log.WARN))       _log.warn("Received from bob (" + from + ") who hasn't established a session with us, refusing to help him test "+ aliceIP+ ":"+ alicePort);
      return;
    }
 else {
      state.setBobCipherKey(bob.getCurrentCipherKey());
      state.setBobMACKey(bob.getCurrentMACKey());
    }
    state.incrementPacketsRelayed();
    if (state.getPacketsRelayed() > MAX_RELAYED_PER_TEST) {
      if (_log.shouldLog(Log.WARN))       _log.warn("Receive from bob (" + from + ") as charlie with alice @ "+ aliceIP+ ":"+ alicePort+ ", but we've already relayed too many packets to that test, so we're dropping it");
      return;
    }
    if (_log.shouldLog(Log.DEBUG))     _log.debug("Receive from bob (" + from + ") as charlie, sending back to bob and sending to alice @ "+ aliceIP+ ":"+ alicePort);
    if (isNew) {
      _activeTests.put(Long.valueOf(nonce),state);
      _context.simpleScheduler().addEvent(new RemoveTest(nonce),MAX_CHARLIE_LIFETIME);
    }
    UDPPacket packet=_packetBuilder.buildPeerTestToBob(bobIP,from.getPort(),aliceIP,alicePort,aliceIntroKey,nonce,state.getBobCipherKey(),state.getBobMACKey());
    _transport.send(packet);
    packet=_packetBuilder.buildPeerTestToAlice(aliceIP,alicePort,aliceIntroKey,_transport.getIntroKey(),nonce);
    _transport.send(packet);
  }
 catch (  UnknownHostException uhe) {
    if (_log.shouldLog(Log.WARN))     _log.warn("Unable to build the aliceIP from " + from + ", ip size: "+ sz+ " ip val: "+ Base64.encode(aliceIPData),uhe);
  }
}
