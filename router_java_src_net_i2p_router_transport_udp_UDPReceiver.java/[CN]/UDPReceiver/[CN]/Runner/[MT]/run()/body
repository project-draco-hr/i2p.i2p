{
  FIFOBandwidthLimiter.Request req=_context.bandwidthLimiter().createRequest();
  while (_keepRunning) {
    UDPPacket packet=UDPPacket.acquire(_context,true);
    if (_isAndroid)     packet.getPacket().setLength(UDPPacket.MAX_PACKET_SIZE);
    while (!_context.throttle().acceptNetworkMessage())     try {
      Thread.sleep(10);
    }
 catch (    InterruptedException ie) {
    }
    try {
      _socket.receive(packet.getPacket());
      int size=packet.getPacket().getLength();
      if (_log.shouldLog(Log.INFO))       _log.info("After blocking socket.receive: packet is " + size + " bytes on "+ System.identityHashCode(packet));
      packet.resetBegin();
      if (size >= UDPPacket.MAX_PACKET_SIZE) {
        throw new IOException("packet too large! truncated and dropped from: " + packet.getRemoteHost());
      }
      if (size > 0) {
        req=_context.bandwidthLimiter().requestInbound(size,"UDP receiver");
        while (req.getPendingInboundRequested() > 0)         req.waitForNextAllocation();
        int queued=receive(packet);
        _context.statManager().addRateData("udp.receivePacketSize",size,queued);
      }
 else {
        _context.statManager().addRateData("udp.receiveHolePunch",1,0);
        if (_log.shouldLog(Log.INFO))         _log.info("Received a 0 byte udp packet from " + packet.getPacket().getAddress() + ":"+ packet.getPacket().getPort());
        packet.release();
      }
    }
 catch (    IOException ioe) {
      if (_log.shouldLog(Log.WARN))       _log.warn("Error receiving",ioe);
      packet.release();
    }
  }
  if (_log.shouldLog(Log.DEBUG))   _log.debug("Stop receiving...");
}
