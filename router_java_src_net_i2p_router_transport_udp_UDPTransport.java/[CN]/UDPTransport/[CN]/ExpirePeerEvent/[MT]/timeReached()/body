{
  if (haveCapacity())   _expireTimeout=Math.min(_expireTimeout + 15 * 1000,EXPIRE_TIMEOUT);
 else   _expireTimeout=Math.max(_expireTimeout - 45 * 1000,MIN_EXPIRE_TIMEOUT);
  long now=_context.clock().now();
  long shortInactivityCutoff=now - _expireTimeout;
  long longInactivityCutoff=now - EXPIRE_TIMEOUT;
  long pingCutoff=now - (2 * 60 * 60* 1000);
  long pingFirewallCutoff=now - (60 * 1000);
  boolean shouldPingFirewall=_reachabilityStatus != CommSystemFacade.STATUS_OK;
  boolean pingOneOnly=shouldPingFirewall && _externalListenPort == _endpoint.getListenPort();
  _expireBuffer.clear();
  for (Iterator<PeerState> iter=_expirePeers.iterator(); iter.hasNext(); ) {
    PeerState peer=iter.next();
    long inactivityCutoff;
    if (peer.getWeRelayToThemAs() > 0 || peer.getIntroducerTime() > pingCutoff)     inactivityCutoff=longInactivityCutoff;
 else     inactivityCutoff=shortInactivityCutoff;
    if ((peer.getLastReceiveTime() < inactivityCutoff) && (peer.getLastSendTime() < inactivityCutoff)) {
      _expireBuffer.add(peer);
      iter.remove();
    }
 else     if (shouldPingFirewall && peer.getLastSendTime() < pingFirewallCutoff && peer.getLastReceiveTime() < pingFirewallCutoff) {
      if (_log.shouldLog(Log.DEBUG))       _log.debug("Pinging for firewall: " + peer);
      send(_destroyBuilder.buildPing(peer));
      if (pingOneOnly)       shouldPingFirewall=false;
    }
  }
  for (  PeerState peer : _expireBuffer) {
    sendDestroy(peer);
    dropPeer(peer,false,"idle too long");
  }
  _expireBuffer.clear();
  if (_alive)   schedule(30 * 1000);
}
