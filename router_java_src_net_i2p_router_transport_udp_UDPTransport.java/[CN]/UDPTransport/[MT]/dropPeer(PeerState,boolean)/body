{
  if (_log.shouldLog(Log.WARN)) {
    long now=_context.clock().now();
    StringBuffer buf=new StringBuffer(4096);
    long timeSinceSend=now - peer.getLastSendTime();
    long timeSinceRecv=now - peer.getLastReceiveTime();
    long timeSinceAck=now - peer.getLastACKSend();
    buf.append("Dropping remote peer: ").append(peer.toString()).append(" shitlist? ").append(shouldShitlist);
    buf.append(" lifetime: ").append(now - peer.getKeyEstablishedTime());
    buf.append(" time since send/recv/ack: ").append(timeSinceSend).append(" / ");
    buf.append(timeSinceRecv).append(" / ").append(timeSinceAck);
    _log.warn(buf.toString(),new Exception("Dropped by"));
  }
  peer.dropOutbound();
  peer.expireInboundMessages();
  _introManager.remove(peer);
  _fragments.dropPeer(peer);
  PeerState altByIdent=null;
  PeerState altByHost=null;
  if (peer.getRemotePeer() != null) {
    dropPeerCapacities(peer);
    if (shouldShitlist) {
      long now=_context.clock().now();
      _context.statManager().addRateData("udp.droppedPeer",now - peer.getLastReceiveTime(),now - peer.getKeyEstablishedTime());
      _context.shitlist().shitlistRouter(peer.getRemotePeer(),"dropped after too many retries");
    }
 else {
      long now=_context.clock().now();
      _context.statManager().addRateData("udp.droppedPeerInactive",now - peer.getLastReceiveTime(),now - peer.getKeyEstablishedTime());
    }
synchronized (_peersByIdent) {
      altByIdent=(PeerState)_peersByIdent.remove(peer.getRemotePeer());
    }
  }
  RemoteHostId remoteId=peer.getRemoteHostId();
  if (remoteId != null) {
synchronized (_peersByRemoteHost) {
      altByHost=(PeerState)_peersByRemoteHost.remove(remoteId);
    }
  }
  _activeThrottle.unchoke(peer.getRemotePeer());
  if (SHOULD_FLOOD_PEERS)   _flooder.removePeer(peer);
  _expireEvent.remove(peer);
  if (needsRebuild())   rebuildExternalAddress();
  if ((altByIdent != null) && (peer != altByIdent))   dropPeer(altByIdent,shouldShitlist);
  if ((altByHost != null) && (peer != altByHost))   dropPeer(altByHost,shouldShitlist);
}
