{
  if (msg == null)   return;
  if (msg.getTarget() == null)   return;
  if (msg.getTarget().getIdentity() == null)   return;
  msg.timestamp("sending on UDP transport");
  Hash to=msg.getTarget().getIdentity().calculateHash();
  PeerState peer=getPeerState(to);
  if (peer != null) {
    long lastSend=peer.getLastSendFullyTime();
    long lastRecv=peer.getLastReceiveTime();
    long now=_context.clock().now();
    if ((lastSend > 0) && (lastRecv > 0)) {
      if ((now - lastSend > MAX_IDLE_TIME) && (now - lastRecv > MAX_IDLE_TIME) && (peer.getConsecutiveFailedSends() > 0)) {
        dropPeer(peer,false);
        msg.timestamp("peer is really idle, dropping con and reestablishing");
        _establisher.establish(msg);
        _context.statManager().addRateData("udp.proactiveReestablish",now - lastSend,now - peer.getKeyEstablishedTime());
        return;
      }
    }
    msg.timestamp("enqueueing for an already established peer");
    _outboundMessages.add(msg);
  }
 else {
    msg.timestamp("establishing a new connection");
    _establisher.establish(msg);
  }
}
