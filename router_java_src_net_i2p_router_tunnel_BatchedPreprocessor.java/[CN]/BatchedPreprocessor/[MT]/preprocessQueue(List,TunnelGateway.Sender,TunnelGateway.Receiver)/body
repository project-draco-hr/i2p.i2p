{
  if (_log.shouldLog(Log.DEBUG))   _log.debug("Preprocess queue with " + pending.size() + " to send");
  int batchCount=0;
  int beforeLooping=pending.size();
  while (pending.size() > 0) {
    int allocated=0;
    for (int i=0; i < pending.size(); i++) {
      TunnelGateway.Pending msg=(TunnelGateway.Pending)pending.get(i);
      int instructionsSize=getInstructionsSize(msg);
      instructionsSize+=getInstructionAugmentationSize(msg,allocated,instructionsSize);
      int curWanted=msg.getData().length - msg.getOffset() + instructionsSize;
      allocated+=curWanted;
      if (allocated >= FULL_SIZE) {
        if (allocated - curWanted + instructionsSize >= FULL_SIZE) {
          i--;
          msg=(TunnelGateway.Pending)pending.get(i);
          allocated-=curWanted;
          if (_log.shouldLog(Log.DEBUG))           _log.debug("Pushback of " + curWanted + " (message "+ (i + 1)+ " in "+ pending+ ")");
        }
        if (_pendingSince > 0) {
          long waited=_context.clock().now() - _pendingSince;
          _context.statManager().addRateData("tunnel.batchDelaySent",pending.size(),waited);
        }
        _pendingSince=0;
        send(pending,0,i,sender,rec);
        if (_log.shouldLog(Log.INFO))         _log.info("Allocated=" + allocated + " so we sent "+ (i + 1)+ " (last complete? "+ (msg.getOffset() >= msg.getData().length)+ ", off="+ msg.getOffset()+ ", count="+ pending.size()+ ")");
        for (int j=0; j < i; j++) {
          TunnelGateway.Pending cur=(TunnelGateway.Pending)pending.remove(0);
          if (cur.getOffset() < cur.getData().length)           throw new IllegalArgumentException("i=" + i + " j="+ j+ " off="+ cur.getOffset()+ " len="+ cur.getData().length+ " alloc="+ allocated);
          notePreprocessing(cur.getMessageId(),cur.getFragmentNumber(),cur.getData().length,cur.getMessageIds(),"flushed allocated");
          _context.statManager().addRateData("tunnel.writeDelay",cur.getLifetime(),cur.getData().length);
        }
        if (msg.getOffset() >= msg.getData().length) {
          TunnelGateway.Pending cur=(TunnelGateway.Pending)pending.remove(0);
          notePreprocessing(cur.getMessageId(),cur.getFragmentNumber(),msg.getData().length,msg.getMessageIds(),"flushed tail, remaining: " + pending);
          _context.statManager().addRateData("tunnel.writeDelay",cur.getLifetime(),cur.getData().length);
        }
        if (i > 0)         _context.statManager().addRateData("tunnel.batchMultipleCount",i + 1,0);
        allocated=0;
        batchCount++;
      }
    }
    display(allocated,pending,"after looping to clear " + (beforeLooping - pending.size()));
    if (allocated > 0) {
      if ((pending.size() > FORCE_BATCH_FLUSH) || ((_pendingSince > 0) && (getDelayAmount() <= 0))) {
        if (pending.size() > 1)         _context.statManager().addRateData("tunnel.batchMultipleCount",pending.size(),0);
        _context.statManager().addRateData("tunnel.batchDelaySent",pending.size(),0);
        send(pending,0,pending.size() - 1,sender,rec);
        int beforeSize=pending.size();
        for (int i=0; i < pending.size(); i++) {
          TunnelGateway.Pending cur=(TunnelGateway.Pending)pending.get(i);
          if (cur.getOffset() >= cur.getData().length) {
            pending.remove(i);
            notePreprocessing(cur.getMessageId(),cur.getFragmentNumber(),cur.getData().length,cur.getMessageIds(),"flushed remaining");
            _context.statManager().addRateData("tunnel.writeDelay",cur.getLifetime(),cur.getData().length);
            i--;
          }
        }
        if (pending.size() > 0) {
          _pendingSince=_context.clock().now();
          _context.statManager().addRateData("tunnel.batchFlushRemaining",pending.size(),beforeSize);
          display(allocated,pending,"flushed, some remain");
          return true;
        }
 else {
          long delayAmount=_context.clock().now() - _pendingSince;
          _pendingSince=0;
          if (batchCount > 1)           _context.statManager().addRateData("tunnel.batchCount",batchCount,0);
          display(allocated,pending,"flushed " + (beforeSize) + ", no remaining after "+ delayAmount);
          return false;
        }
      }
 else {
        _context.statManager().addRateData("tunnel.batchDelay",pending.size(),0);
        if (_pendingSince <= 0)         _pendingSince=_context.clock().now();
        if (batchCount > 1)         _context.statManager().addRateData("tunnel.batchCount",batchCount,0);
        display(allocated,pending,"dont flush");
        return true;
      }
    }
 else {
    }
  }
  if (_log.shouldLog(Log.DEBUG))   _log.debug("Sent everything on the list (pending=" + pending.size() + ")");
  return false;
}
