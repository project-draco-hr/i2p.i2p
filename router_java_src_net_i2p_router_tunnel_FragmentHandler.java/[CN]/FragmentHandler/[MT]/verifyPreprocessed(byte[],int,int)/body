{
  int paddingEnd=HopProcessor.IV_LENGTH + 4;
  while (preprocessed[offset + paddingEnd] != (byte)0x00) {
    paddingEnd++;
    if (offset + paddingEnd >= length) {
      if (_log.shouldLog(Log.ERROR))       _log.error("Corrupt tunnel message padding");
      if (_log.shouldLog(Log.WARN))       _log.warn("cannot verify, going past the end [off=" + offset + " len="+ length+ " paddingEnd="+ paddingEnd+ " data:\n"+ Base64.encode(preprocessed,offset,length));
      return false;
    }
  }
  paddingEnd++;
  ByteArray ba=_validateCache.acquire();
  byte preV[]=ba.getData();
  int validLength=length - offset - paddingEnd + HopProcessor.IV_LENGTH;
  System.arraycopy(preprocessed,offset + paddingEnd,preV,0,validLength - HopProcessor.IV_LENGTH);
  System.arraycopy(preprocessed,0,preV,validLength - HopProcessor.IV_LENGTH,HopProcessor.IV_LENGTH);
  if (_log.shouldLog(Log.DEBUG))   _log.debug("endpoint IV: " + Base64.encode(preV,validLength - HopProcessor.IV_LENGTH,HopProcessor.IV_LENGTH));
  Hash v=_context.sha().calculateHash(preV,0,validLength);
  boolean eq=DataHelper.eq(v.getData(),0,preprocessed,offset + HopProcessor.IV_LENGTH,4);
  if (!eq) {
    if (_log.shouldLog(Log.ERROR))     _log.error("Corrupt tunnel message - verification fails");
    if (_log.shouldLog(Log.WARN))     _log.warn("nomatching endpoint: # pad bytes: " + (paddingEnd - (HopProcessor.IV_LENGTH + 4) - 1) + "\n"+ " offset="+ offset+ " length="+ length+ " paddingEnd="+ paddingEnd+ Base64.encode(preprocessed,offset,length));
  }
  _validateCache.release(ba);
  if (eq) {
    int excessPadding=paddingEnd - (HopProcessor.IV_LENGTH + 4 + 1);
    if (excessPadding > 0)     _context.statManager().addRateData("tunnel.smallFragments",excessPadding,0);
 else     _context.statManager().addRateData("tunnel.fullFragments",1,0);
  }
  return eq;
}
