{
  ByteArray ivBuf=_ivCache.acquire();
  byte iv[]=ivBuf.getData();
  _context.random().nextBytes(iv);
  SHA256EntryCache.CacheEntry cache=_context.sha().cache().acquire(PREPROCESSED_SIZE);
  System.arraycopy(iv,0,fragments,fragmentLength,IV_SIZE);
  Hash h=_context.sha().calculateHash(fragments,0,fragmentLength + IV_SIZE,cache);
  int distance=PREPROCESSED_SIZE - fragmentLength;
  System.arraycopy(fragments,0,fragments,distance,fragmentLength);
  java.util.Arrays.fill(fragments,0,distance,(byte)0x0);
  int offset=0;
  System.arraycopy(iv,0,fragments,offset,IV_SIZE);
  offset+=IV_SIZE;
  System.arraycopy(h.getData(),0,fragments,offset,4);
  offset+=4;
  _context.sha().cache().release(cache);
  _ivCache.release(ivBuf);
  int numPadBytes=PREPROCESSED_SIZE - IV_SIZE - 4- 1- fragmentLength;
  int paddingRemaining=numPadBytes;
  while (paddingRemaining > 0) {
    byte b=(byte)(_context.random().nextInt() & 0xFF);
    if (b != 0x00) {
      fragments[offset]=b;
      offset++;
      paddingRemaining--;
    }
  }
  fragments[offset]=0x0;
  offset++;
  if (_log.shouldLog(Log.DEBUG))   _log.debug("Preprocessing beginning of the fragment instructions at " + offset);
}
