{
  _context=ctx;
  _log=ctx.logManager().getLog(TunnelDispatcher.class);
  _outboundGateways=new ConcurrentHashMap();
  _outboundEndpoints=new ConcurrentHashMap();
  _participants=new ConcurrentHashMap();
  _inboundGateways=new ConcurrentHashMap();
  _participatingConfig=new ConcurrentHashMap();
  _pumper=new TunnelGatewayPumper(ctx);
  _leaveJob=new LeaveTunnel(ctx);
  ctx.statManager().createRequiredRateStat("tunnel.participatingTunnels","Tunnels routed for others","Tunnels",new long[]{60 * 1000,10 * 60 * 1000l,60 * 60 * 1000l,3 * 60 * 60* 1000l,24 * 60 * 60* 1000l});
  ctx.statManager().createRateStat("tunnel.dispatchOutboundPeer","How many messages we send out a tunnel targetting a peer?","Tunnels",new long[]{10 * 60 * 1000l,60 * 60 * 1000l});
  ctx.statManager().createRateStat("tunnel.dispatchOutboundTunnel","How many messages we send out a tunnel targetting a tunnel?","Tunnels",new long[]{10 * 60 * 1000l,60 * 60 * 1000l});
  ctx.statManager().createRateStat("tunnel.dispatchInbound","How many messages we send through our tunnel gateway?","Tunnels",new long[]{10 * 60 * 1000l,60 * 60 * 1000l});
  ctx.statManager().createRateStat("tunnel.dispatchParticipant","How many messages we send through a tunnel we are participating in?","Tunnels",new long[]{10 * 60 * 1000l,60 * 60 * 1000l});
  ctx.statManager().createRateStat("tunnel.dispatchEndpoint","How many messages we receive as the outbound endpoint of a tunnel?","Tunnels",new long[]{10 * 60 * 1000l,60 * 60 * 1000l});
  ctx.statManager().createRateStat("tunnel.joinOutboundGateway","How many tunnels we join as the outbound gateway?","Tunnels",new long[]{10 * 60 * 1000l,60 * 60 * 1000l});
  ctx.statManager().createRateStat("tunnel.joinOutboundGatewayZeroHop","How many zero hop tunnels we join as the outbound gateway?","Tunnels",new long[]{10 * 60 * 1000l,60 * 60 * 1000l});
  ctx.statManager().createRateStat("tunnel.joinInboundEndpoint","How many tunnels we join as the inbound endpoint?","Tunnels",new long[]{10 * 60 * 1000l,60 * 60 * 1000l});
  ctx.statManager().createRateStat("tunnel.joinInboundEndpointZeroHop","How many zero hop tunnels we join as the inbound endpoint?","Tunnels",new long[]{10 * 60 * 1000l,60 * 60 * 1000l});
  ctx.statManager().createRateStat("tunnel.joinParticipant","How many tunnels we join as a participant?","Tunnels",new long[]{10 * 60 * 1000l,60 * 60 * 1000l});
  ctx.statManager().createRateStat("tunnel.joinOutboundEndpoint","How many tunnels we join as the outbound endpoint?","Tunnels",new long[]{10 * 60 * 1000l,60 * 60 * 1000l});
  ctx.statManager().createRateStat("tunnel.joinInboundGateway","How many tunnels we join as the inbound gateway?","Tunnels",new long[]{10 * 60 * 1000l,60 * 60 * 1000l});
  ctx.statManager().createRequiredRateStat("tunnel.participatingBandwidth","Participating traffic received (Bytes/sec)","Tunnels",new long[]{60 * 1000l,60 * 10 * 1000l});
  ctx.statManager().createRequiredRateStat("tunnel.participatingBandwidthOut","Participating traffic sent (Bytes/sec)","Tunnels",new long[]{60 * 1000l,60 * 10 * 1000l});
  ctx.statManager().createRateStat("tunnel.participatingMessageDropped","Dropped for exceeding share limit","Tunnels",new long[]{60 * 1000l,60 * 10 * 1000l});
  ctx.statManager().createRequiredRateStat("tunnel.participatingMessageCount","Number of 1KB participating messages","Tunnels",new long[]{60 * 1000l,60 * 10 * 1000l,60 * 60 * 1000l});
  ctx.statManager().createRateStat("tunnel.ownedMessageCount","How many messages are sent through a tunnel we created (period == failures)?","Tunnels",new long[]{60 * 1000l,10 * 60 * 1000l,60 * 60 * 1000l});
  ctx.statManager().createRateStat("tunnel.failedCompletelyMessages","How many messages are sent through a tunnel that failed prematurely (period == failures)?","Tunnels",new long[]{60 * 1000l,10 * 60 * 1000l,60 * 60 * 1000l});
  ctx.statManager().createRateStat("tunnel.failedPartially","How many messages are sent through a tunnel that only failed partially (period == failures)?","Tunnels",new long[]{60 * 1000l,10 * 60 * 1000l,60 * 60 * 1000l});
  ctx.statManager().createRateStat("tunnel.batchMultipleCount","How many messages are batched into a tunnel message","Tunnels",new long[]{10 * 60 * 1000,60 * 60 * 1000});
  ctx.statManager().createRateStat("tunnel.batchDelay","How many messages were pending when the batching waited","Tunnels",new long[]{10 * 60 * 1000,60 * 60 * 1000});
  ctx.statManager().createRateStat("tunnel.batchDelaySent","How many messages were flushed when the batching delay completed","Tunnels",new long[]{10 * 60 * 1000,60 * 60 * 1000});
  ctx.statManager().createRateStat("tunnel.batchCount","How many groups of messages were flushed together","Tunnels",new long[]{10 * 60 * 1000,60 * 60 * 1000});
  ctx.statManager().createRateStat("tunnel.batchDelayAmount","How long we should wait before flushing the batch","Tunnels",new long[]{10 * 60 * 1000,60 * 60 * 1000});
  ctx.statManager().createRateStat("tunnel.batchFlushRemaining","How many messages remain after flushing","Tunnels",new long[]{10 * 60 * 1000,60 * 60 * 1000});
  ctx.statManager().createRateStat("tunnel.writeDelay","How long after a message reaches the gateway is it processed (lifetime is size)","Tunnels",new long[]{10 * 60 * 1000,60 * 60 * 1000});
  ctx.statManager().createRateStat("tunnel.batchSmallFragments","How many outgoing pad bytes are in small fragments?","Tunnels",new long[]{10 * 60 * 1000l,60 * 60 * 1000l});
  ctx.statManager().createRateStat("tunnel.batchFullFragments","How many outgoing tunnel messages use the full data area?","Tunnels",new long[]{10 * 60 * 1000l,60 * 60 * 1000l});
  ctx.statManager().createRateStat("tunnel.batchFragmentation","Avg. number of fragments per msg","Tunnels",new long[]{10 * 60 * 1000,60 * 60 * 1000});
  ctx.statManager().createRateStat("tunnel.distributeLookupSuccess","Was a deferred lookup successful?","Tunnels",new long[]{60 * 60 * 1000});
  ctx.statManager().createRateStat("tunnel.outboundLookupSuccess","Was a deferred lookup successful?","Tunnels",new long[]{60 * 60 * 1000});
  ctx.statManager().createRateStat("tunnel.inboundLookupSuccess","Was a deferred lookup successful?","Tunnels",new long[]{60 * 60 * 1000});
  ctx.statManager().createRateStat("tunnel.participantLookupSuccess","Was a deferred lookup successful?","Tunnels",new long[]{60 * 60 * 1000});
  ctx.statManager().createRateStat("tunnel.buildRequestDup","How frequently we get dup build request messages","Tunnels",new long[]{60 * 60 * 1000});
  ctx.statManager().createRateStat("tunnel.smallFragments","How many pad bytes are in small fragments?","Tunnels",RATES);
  ctx.statManager().createRateStat("tunnel.fullFragments","How many tunnel messages use the full data area?","Tunnels",RATES);
  ctx.statManager().createRateStat("tunnel.fragmentedComplete","How many fragments were in a completely received message?","Tunnels",RATES);
  ctx.statManager().createRequiredRateStat("tunnel.fragmentedDropped","Number of dropped fragments","Tunnels",RATES);
  ctx.statManager().createRequiredRateStat("tunnel.corruptMessage","Corrupt messages received","Tunnels",RATES);
  ctx.statManager().createRateStat("tunnel.dropDangerousClientTunnelMessage","How many tunnel messages come down a client tunnel that we shouldn't expect (lifetime is the 'I2NP type')","Tunnels",new long[]{60 * 60 * 1000});
  ctx.statManager().createRateStat("tunnel.handleLoadClove","When do we receive load test cloves","Tunnels",new long[]{60 * 60 * 1000});
}
