{
  List partTunnels=listParticipatingTunnels();
  if ((partTunnels == null) || (partTunnels.size() == 0)) {
    if (_log.shouldLog(Log.ERROR))     _log.error("Not dropping tunnel, since partTunnels was null or had 0 items!");
    return;
  }
  long periodWithoutDrop=_context.clock().now() - _lastDropTime;
  if (periodWithoutDrop < DROP_BASE_INTERVAL) {
    if (_log.shouldLog(Log.WARN))     _log.error("Not dropping tunnel, since last drop was " + periodWithoutDrop + " ms ago!");
    return;
  }
  HopConfig biggest=null;
  HopConfig current=null;
  long biggestMessages=0;
  long biggestAge=-1;
  double biggestRate=0;
  for (int i=0; i < partTunnels.size(); i++) {
    current=(HopConfig)partTunnels.get(i);
    long currentMessages=current.getProcessedMessagesCount();
    long currentAge=(_context.clock().now() - current.getCreation());
    double currentRate=((double)currentMessages / (currentAge / 1000));
    if ((currentMessages > 20) && ((biggest == null) || (currentRate > biggestRate))) {
      biggest=current;
      biggestMessages=biggest.getProcessedMessagesCount();
      biggestAge=(_context.clock().now() - current.getCreation());
      biggestRate=((double)biggestMessages / (biggestAge / 1000));
    }
  }
  if (biggest == null) {
    if (_log.shouldLog(Log.ERROR))     _log.error("Not dropping tunnel, since no suitable tunnel was found.");
    return;
  }
  if (_log.shouldLog(Log.ERROR))   _log.error("Dropping tunnel with " + biggestRate + " messages/s and "+ biggestMessages+ " messages, last drop was "+ (periodWithoutDrop / 1000)+ " s ago.");
  remove(biggest);
  _lastDropTime=_context.clock().now() + _context.random().nextInt(DROP_RANDOM_BOOST);
}
