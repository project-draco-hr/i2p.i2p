{
  _messagesSent++;
  boolean delayedFlush=false;
  long delayAmount=-1;
  int remaining=0;
  long beforeLock=_context.clock().now();
  long afterAdded=-1;
  Pending cur=new PendingImpl(msg,toRouter,toTunnel);
synchronized (_queue) {
    _queue.add(cur);
    afterAdded=_context.clock().now();
    delayedFlush=_preprocessor.preprocessQueue(_queue,_sender,_receiver);
    if (delayedFlush)     delayAmount=_preprocessor.getDelayAmount();
    _lastFlush=_context.clock().now();
    for (int i=0; i < _queue.size(); i++) {
      Pending m=(Pending)_queue.get(i);
      if (m.getExpiration() + Router.CLOCK_FUDGE_FACTOR < _lastFlush) {
        if (_log.shouldLog(Log.ERROR))         _log.error("Expire on the queue (size=" + _queue.size() + "): "+ m);
        _queue.remove(i);
        i--;
      }
    }
    remaining=_queue.size();
  }
  if (delayedFlush) {
    FlushTimer.getInstance().addEvent(_delayedFlush,delayAmount);
  }
  _context.statManager().addRateData("tunnel.lockedGatewayAdd",afterAdded - beforeLock,remaining);
}
