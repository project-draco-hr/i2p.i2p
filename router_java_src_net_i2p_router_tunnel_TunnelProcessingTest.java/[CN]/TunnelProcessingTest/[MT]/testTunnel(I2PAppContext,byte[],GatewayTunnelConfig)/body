{
  Log log=ctx.logManager().getLog(TunnelProcessingTest.class);
  log.debug("H[orig] = " + ctx.sha().calculateHash(orig).toBase64());
  log.debug("\n\nEncrypting the payload");
  byte cur[]=new byte[orig.length];
  System.arraycopy(orig,0,cur,0,cur.length);
  GatewayMessage msg=new GatewayMessage(ctx);
  msg.setPayload(cur);
  msg.encrypt(cfg);
  int size=msg.getExportedSize();
  byte message[]=new byte[size];
  int exp=msg.export(message,0);
  if (exp != size)   throw new RuntimeException("Foo!");
  TunnelMessageProcessor proc=new TunnelMessageProcessor();
  for (int i=0; i < GatewayMessage.HOPS; i++) {
    log.debug("\n\nUnwrapping step " + i);
    boolean ok=proc.unwrapMessage(ctx,message,cfg.getSessionKey(i));
    if (!ok)     log.error("Unwrap failed at step " + i);
 else     log.info("** Unwrap succeeded at step " + i);
    boolean match=msg.compareChecksumBlock(ctx,message,i);
  }
  log.debug("\n\nVerifying the tunnel processing");
  for (int i=0; i < orig.length; i++) {
    if (orig[i] != message[16 + i]) {
      log.error("Finished payload does not match at byte " + i + ctx.sha().calculateHash(message,16,orig.length).toBase64());
      break;
    }
  }
  boolean ok=proc.verifyChecksum(ctx,message);
  if (!ok)   log.error("Checksum could not be verified");
 else   log.error("** Checksum verified");
}
