{
  _isRunning=true;
  List<TunnelPool> wanted=new ArrayList(MAX_CONCURRENT_BUILDS);
  List<TunnelPool> pools=new ArrayList(8);
  int pendingRemaining=0;
  long afterBuildReal=0;
  long afterHandleInbound=0;
  while (!_manager.isShutdown()) {
    try {
      _repoll=pendingRemaining > 0;
      _manager.listPools(pools);
      for (int i=0; i < pools.size(); i++) {
        TunnelPool pool=pools.get(i);
        if (!pool.isAlive())         continue;
        int howMany=pool.countHowManyToBuild();
        for (int j=0; j < howMany; j++)         wanted.add(pool);
      }
      int allowed=allowed();
      allowed=buildZeroHopTunnels(wanted,allowed);
      TunnelManagerFacade mgr=_context.tunnelManager();
      if ((mgr == null) || (mgr.selectInboundTunnel() == null) || (mgr.selectOutboundTunnel() == null)) {
synchronized (_currentlyBuilding) {
          if (!_repoll) {
            if (_log.shouldLog(Log.DEBUG))             _log.debug("No tunnel to build with (allowed=" + allowed + ", wanted="+ wanted.size()+ ", pending="+ pendingRemaining+ "), wait for a while");
            try {
              _currentlyBuilding.wait(1 * 1000 + _context.random().nextInt(1 * 1000));
            }
 catch (            InterruptedException ie) {
            }
          }
        }
      }
 else {
        if ((allowed > 0) && (!wanted.isEmpty())) {
          Collections.shuffle(wanted,_context.random());
          Collections.sort(wanted,new TunnelPoolComparator());
          if (allowed > 2)           allowed=2;
          for (int i=0; (i < allowed) && (!wanted.isEmpty()); i++) {
            TunnelPool pool=wanted.remove(0);
            PooledTunnelCreatorConfig cfg=pool.configureNewTunnel();
            if (cfg != null) {
              if (cfg.getLength() <= 1 && !pool.needFallback()) {
                if (_log.shouldLog(Log.DEBUG))                 _log.debug("We don't need more fallbacks for " + pool);
                i--;
                pool.buildComplete(cfg);
                continue;
              }
              if (_log.shouldLog(Log.DEBUG))               _log.debug("Configuring new tunnel " + i + " for "+ pool+ ": "+ cfg);
              buildTunnel(pool,cfg);
            }
 else {
              i--;
            }
          }
        }
        try {
synchronized (_currentlyBuilding) {
            if (!_repoll) {
              _currentlyBuilding.wait((LOOP_TIME / 2) + _context.random().nextInt(LOOP_TIME));
            }
          }
        }
 catch (        InterruptedException ie) {
        }
      }
      afterBuildReal=System.currentTimeMillis();
      pendingRemaining=_handler.handleInboundRequests();
      afterHandleInbound=System.currentTimeMillis();
      if (pendingRemaining > 0)       _context.statManager().addRateData("tunnel.pendingRemaining",pendingRemaining,afterHandleInbound - afterBuildReal);
      wanted.clear();
      pools.clear();
    }
 catch (    RuntimeException e) {
      if (_log.shouldLog(Log.CRIT))       _log.log(Log.CRIT,"B0rked in the tunnel builder",e);
    }
  }
  if (_log.shouldLog(Log.WARN))   _log.warn("Done building");
  _isRunning=false;
}
