{
  long reqId=receivedMessage.getUniqueId();
  PooledTunnelCreatorConfig cfg=_exec.removeFromBuilding(reqId);
  if (_log.shouldLog(Log.DEBUG))   _log.debug("Receive tunnel build message " + reqId + " from "+ (from != null ? from.calculateHash().toBase64() : fromHash != null ? fromHash.toBase64() : "tunnels")+ ", found matching tunnel? "+ (cfg != null));
  if (cfg != null) {
    if (!cfg.isInbound()) {
      _log.error("received it, but its not inbound? " + cfg);
    }
    BuildEndMessageState state=new BuildEndMessageState(cfg,receivedMessage);
    handleRequestAsInboundEndpoint(state);
  }
 else {
    if (_exec.wasRecentlyBuilding(reqId)) {
      if (_log.shouldLog(Log.WARN))       _log.warn("Dropping the reply " + reqId + ", as we used to be building that");
      _context.statManager().addRateData("tunnel.buildReplyTooSlow",1,0);
    }
 else {
      int sz=_inboundBuildMessages.size();
      BuildMessageState cur=_inboundBuildMessages.peek();
      boolean accept=true;
      if (cur != null) {
        long age=System.currentTimeMillis() - cur.recvTime;
        if (age >= BuildRequestor.REQUEST_TIMEOUT / 4) {
          _context.statManager().addRateData("tunnel.dropLoad",age,sz);
          _context.throttle().setTunnelStatus(_x("Dropping tunnel requests: High load"));
          _context.statManager().addRateData("tunnel.dropLoadBacklog",sz,sz);
          accept=false;
        }
      }
      if (accept) {
        int queueTime=estimateQueueTime(sz);
        float pDrop=queueTime / ((float)BuildRequestor.REQUEST_TIMEOUT * 3);
        pDrop=(float)Math.pow(pDrop,16);
        float f=_context.random().nextFloat();
        if (pDrop > f) {
          _context.throttle().setTunnelStatus(_x("Dropping tunnel requests: Queue time"));
          _context.statManager().addRateData("tunnel.dropLoadProactive",queueTime,sz);
        }
 else {
          accept=_inboundBuildMessages.offer(new BuildMessageState(receivedMessage,from,fromHash));
          if (accept) {
            _exec.repoll();
          }
 else {
            _context.throttle().setTunnelStatus(_x("Dropping tunnel requests: High load"));
            _context.statManager().addRateData("tunnel.dropLoadBacklog",sz,sz);
          }
        }
      }
    }
  }
  return _buildMessageHandlerJob;
}
