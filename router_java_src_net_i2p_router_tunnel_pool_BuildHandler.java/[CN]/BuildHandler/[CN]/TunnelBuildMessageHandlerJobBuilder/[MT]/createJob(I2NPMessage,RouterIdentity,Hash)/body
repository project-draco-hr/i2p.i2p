{
  long reqId=receivedMessage.getUniqueId();
  PooledTunnelCreatorConfig cfg=null;
  List building=_exec.locked_getCurrentlyBuilding();
  List ids=new ArrayList();
synchronized (building) {
    for (int i=0; i < building.size(); i++) {
      PooledTunnelCreatorConfig cur=(PooledTunnelCreatorConfig)building.get(i);
      ids.add(new Long(cur.getReplyMessageId()));
      if ((cur.isInbound()) && (cur.getReplyMessageId() == reqId)) {
        building.remove(i);
        cfg=cur;
        break;
      }
 else       if (cur.getReplyMessageId() == reqId) {
        _log.error("received it, but its not inbound? " + cur);
      }
    }
  }
  if (_log.shouldLog(Log.DEBUG))   _log.debug("Receive tunnel build message " + reqId + " from "+ (from != null ? from.calculateHash().toBase64() : fromHash != null ? fromHash.toBase64() : "tunnels")+ ", waiting ids: "+ ids+ ", found matching tunnel? "+ (cfg != null),null);
  if (cfg != null) {
    BuildEndMessageState state=new BuildEndMessageState(cfg,receivedMessage,from,fromHash);
    if (HANDLE_REPLIES_INLINE) {
      handleRequestAsInboundEndpoint(state);
    }
 else {
synchronized (_inboundBuildEndMessages) {
        _inboundBuildEndMessages.add(state);
      }
      _exec.repoll();
    }
  }
 else {
    if (DROP_ALL_REQUESTS || _exec.wasRecentlyBuilding(reqId)) {
      if (_log.shouldLog(Log.WARN))       _log.warn("Dropping the reply " + reqId + ", as we used to be building that");
    }
 else {
synchronized (_inboundBuildMessages) {
        boolean removed=false;
        int dropped=0;
        for (int i=0; i < _inboundBuildMessages.size(); i++) {
          BuildMessageState cur=(BuildMessageState)_inboundBuildMessages.get(i);
          long age=System.currentTimeMillis() - cur.recvTime;
          if (age >= BuildRequestor.REQUEST_TIMEOUT / 2) {
            _inboundBuildMessages.remove(i);
            i--;
            dropped++;
            _context.statManager().addRateData("tunnel.dropLoad",age,_inboundBuildMessages.size());
          }
        }
        if (dropped > 0) {
          _context.statManager().addRateData("tunnel.dropLoadBacklog",_inboundBuildMessages.size(),_inboundBuildMessages.size());
        }
 else {
          int queueTime=estimateQueueTime(_inboundBuildMessages.size());
          float pDrop=queueTime / ((float)BuildRequestor.REQUEST_TIMEOUT * 3);
          pDrop=(float)Math.pow(pDrop,16);
          float f=_context.random().nextFloat();
          if ((pDrop > f) && (allowProactiveDrop())) {
            _context.statManager().addRateData("tunnel.dropLoadProactive",queueTime,_inboundBuildMessages.size());
          }
 else {
            _inboundBuildMessages.add(new BuildMessageState(receivedMessage,from,fromHash));
          }
        }
      }
      _exec.repoll();
    }
  }
  return _buildMessageHandlerJob;
}
