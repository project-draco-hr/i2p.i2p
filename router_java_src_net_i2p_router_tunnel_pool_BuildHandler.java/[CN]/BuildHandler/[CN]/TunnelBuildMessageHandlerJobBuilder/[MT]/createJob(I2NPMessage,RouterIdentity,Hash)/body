{
  long reqId=receivedMessage.getUniqueId();
  PooledTunnelCreatorConfig cfg=_exec.removeFromBuilding(reqId);
  if (_log.shouldLog(Log.DEBUG))   _log.debug("Receive tunnel build message " + reqId + " from "+ (from != null ? from.calculateHash().toBase64() : fromHash != null ? fromHash.toBase64() : "tunnels")+ ", found matching tunnel? "+ (cfg != null));
  if (cfg != null) {
    if (!cfg.isInbound()) {
      _log.error("received it, but its not inbound? " + cfg);
    }
    BuildEndMessageState state=new BuildEndMessageState(cfg,receivedMessage);
    if (HANDLE_REPLIES_INLINE) {
      handleRequestAsInboundEndpoint(state);
    }
 else {
synchronized (_inboundBuildEndMessages) {
        _inboundBuildEndMessages.add(state);
      }
      _exec.repoll();
    }
  }
 else {
    if (_exec.wasRecentlyBuilding(reqId)) {
      if (_log.shouldLog(Log.WARN))       _log.warn("Dropping the reply " + reqId + ", as we used to be building that");
      _context.statManager().addRateData("tunnel.buildReplyTooSlow",1,0);
    }
 else {
synchronized (_inboundBuildMessages) {
        boolean removed=false;
        int dropped=0;
        for (int i=0; i < _inboundBuildMessages.size(); i++) {
          BuildMessageState cur=(BuildMessageState)_inboundBuildMessages.get(i);
          long age=System.currentTimeMillis() - cur.recvTime;
          if (age >= BuildRequestor.REQUEST_TIMEOUT / 4) {
            _inboundBuildMessages.remove(i);
            i--;
            dropped++;
            _context.statManager().addRateData("tunnel.dropLoad",age,_inboundBuildMessages.size());
          }
        }
        if (dropped > 0) {
          _context.throttle().setTunnelStatus(_x("Dropping tunnel requests: High load"));
          _context.statManager().addRateData("tunnel.dropLoadBacklog",_inboundBuildMessages.size(),_inboundBuildMessages.size());
        }
 else {
          int queueTime=estimateQueueTime(_inboundBuildMessages.size());
          float pDrop=queueTime / ((float)BuildRequestor.REQUEST_TIMEOUT * 3);
          pDrop=(float)Math.pow(pDrop,16);
          float f=_context.random().nextFloat();
          if ((pDrop > f) && (allowProactiveDrop())) {
            _context.throttle().setTunnelStatus(_x("Dropping tunnel requests: Queue time"));
            _context.statManager().addRateData("tunnel.dropLoadProactive",queueTime,_inboundBuildMessages.size());
          }
 else {
            _inboundBuildMessages.add(new BuildMessageState(receivedMessage,from,fromHash));
          }
        }
      }
      _exec.repoll();
    }
  }
  return _buildMessageHandlerJob;
}
