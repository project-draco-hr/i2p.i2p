{
  _context=ctx;
  _log=ctx.logManager().getLog(getClass());
  _exec=exec;
  int sz=Math.min(MAX_QUEUE,Math.max(MIN_QUEUE,TunnelDispatcher.getShareBandwidth(ctx) * MIN_QUEUE / 48));
  _inboundBuildMessages=new LinkedBlockingQueue(sz);
  _context.statManager().createRateStat("tunnel.reject.10","How often we reject a tunnel probabalistically","Tunnels",new long[]{60 * 1000,10 * 60 * 1000});
  _context.statManager().createRateStat("tunnel.reject.20","How often we reject a tunnel because of transient overload","Tunnels",new long[]{60 * 1000,10 * 60 * 1000});
  _context.statManager().createRateStat("tunnel.reject.30","How often we reject a tunnel because of bandwidth overload","Tunnels",new long[]{60 * 1000,10 * 60 * 1000});
  _context.statManager().createRateStat("tunnel.reject.50","How often we reject a tunnel because of a critical issue (shutdown, etc)","Tunnels",new long[]{60 * 1000,10 * 60 * 1000});
  _context.statManager().createRateStat("tunnel.decryptRequestTime","How long it takes to decrypt a new tunnel build request","Tunnels",new long[]{60 * 1000,10 * 60 * 1000});
  _context.statManager().createRateStat("tunnel.rejectTimeout","How often we reject a tunnel because we can't find the next hop","Tunnels",new long[]{60 * 1000,10 * 60 * 1000});
  _context.statManager().createRateStat("tunnel.rejectTimeout2","How often we fail a tunnel because we can't contact the next hop","Tunnels",new long[]{60 * 1000,10 * 60 * 1000});
  _context.statManager().createRateStat("tunnel.rejectOverloaded","How long we had to wait before processing the request (when it was rejected)","Tunnels",new long[]{60 * 1000,10 * 60 * 1000});
  _context.statManager().createRateStat("tunnel.acceptLoad","Delay before processing the accepted request","Tunnels",new long[]{60 * 1000,10 * 60 * 1000});
  _context.statManager().createRateStat("tunnel.dropConnLimits","Drop instead of reject due to conn limits","Tunnels",new long[]{60 * 1000,10 * 60 * 1000});
  _context.statManager().createRateStat("tunnel.dropLoad","How long we had to wait before finally giving up on an inbound request (period is queue count)?","Tunnels",new long[]{60 * 1000,10 * 60 * 1000});
  _context.statManager().createRateStat("tunnel.dropLoadDelay","How long we had to wait before finally giving up on an inbound request?","Tunnels",new long[]{60 * 1000,10 * 60 * 1000});
  _context.statManager().createRateStat("tunnel.dropLoadBacklog","How many requests were pending when they were so lagged that we had to drop a new inbound request??","Tunnels",new long[]{60 * 1000,10 * 60 * 1000});
  _context.statManager().createRateStat("tunnel.dropLoadProactive","What the estimated queue time was when we dropped an inbound request (period is num pending)","Tunnels",new long[]{60 * 1000,10 * 60 * 1000});
  _context.statManager().createRateStat("tunnel.dropLoadProactiveAbort","How often we would have proactively dropped a request, but allowed it through?","Tunnels",new long[]{60 * 1000,10 * 60 * 1000});
  _context.statManager().createRateStat("tunnel.handleRemaining","How many pending inbound requests were left on the queue after one pass?","Tunnels",new long[]{60 * 1000,10 * 60 * 1000});
  _context.statManager().createRateStat("tunnel.buildReplyTooSlow","How often a tunnel build reply came back after we had given up waiting for it?","Tunnels",new long[]{60 * 1000,10 * 60 * 1000});
  _context.statManager().createRateStat("tunnel.receiveRejectionProbabalistic","How often we are rejected probabalistically?","Tunnels",new long[]{10 * 60 * 1000l,60 * 60 * 1000l,24 * 60 * 60* 1000l});
  _context.statManager().createRateStat("tunnel.receiveRejectionTransient","How often we are rejected due to transient overload?","Tunnels",new long[]{10 * 60 * 1000l,60 * 60 * 1000l,24 * 60 * 60* 1000l});
  _context.statManager().createRateStat("tunnel.receiveRejectionBandwidth","How often we are rejected due to bandwidth overload?","Tunnels",new long[]{10 * 60 * 1000l,60 * 60 * 1000l,24 * 60 * 60* 1000l});
  _context.statManager().createRateStat("tunnel.receiveRejectionCritical","How often we are rejected due to critical failure?","Tunnels",new long[]{10 * 60 * 1000l,60 * 60 * 1000l,24 * 60 * 60* 1000l});
  _context.statManager().createRateStat("tunnel.corruptBuildReply","","Tunnels",new long[]{24 * 60 * 60* 1000l});
  _processor=new BuildMessageProcessor(ctx);
  _throttler=new ParticipatingThrottler(ctx);
  _buildMessageHandlerJob=new TunnelBuildMessageHandlerJob(ctx);
  _buildReplyMessageHandlerJob=new TunnelBuildReplyMessageHandlerJob(ctx);
  TunnelBuildMessageHandlerJobBuilder tbmhjb=new TunnelBuildMessageHandlerJobBuilder();
  TunnelBuildReplyMessageHandlerJobBuilder tbrmhjb=new TunnelBuildReplyMessageHandlerJobBuilder();
  ctx.inNetMessagePool().registerHandlerJobBuilder(TunnelBuildMessage.MESSAGE_TYPE,tbmhjb);
  ctx.inNetMessagePool().registerHandlerJobBuilder(TunnelBuildReplyMessage.MESSAGE_TYPE,tbrmhjb);
  ctx.inNetMessagePool().registerHandlerJobBuilder(VariableTunnelBuildMessage.MESSAGE_TYPE,tbmhjb);
  ctx.inNetMessagePool().registerHandlerJobBuilder(VariableTunnelBuildReplyMessage.MESSAGE_TYPE,tbrmhjb);
}
