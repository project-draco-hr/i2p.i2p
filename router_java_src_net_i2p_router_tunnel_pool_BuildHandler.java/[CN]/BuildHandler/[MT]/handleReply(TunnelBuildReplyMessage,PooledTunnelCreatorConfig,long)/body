{
  long requestedOn=cfg.getExpiration() - 10 * 60 * 1000;
  long rtt=_context.clock().now() - requestedOn;
  if (_log.shouldLog(Log.DEBUG))   _log.debug(msg.getUniqueId() + ": Handling the reply after " + rtt+ ", delayed "+ delay+ " waiting for "+ cfg);
  BuildReplyHandler handler=new BuildReplyHandler();
  List order=cfg.getReplyOrder();
  int statuses[]=handler.decrypt(_context,msg,cfg,order);
  if (statuses != null) {
    boolean allAgree=true;
    for (int i=0; i < cfg.getLength(); i++) {
      Hash peer=cfg.getPeer(i);
      int record=order.indexOf(new Integer(i));
      int howBad=statuses[record];
      if (_log.shouldLog(Log.INFO))       _log.info(msg.getUniqueId() + ": Peer " + peer.toBase64()+ " replied with status "+ howBad);
      if (howBad == 0) {
        _context.profileManager().tunnelJoined(peer,rtt);
      }
 else {
        allAgree=false;
switch (howBad) {
case TunnelHistory.TUNNEL_REJECT_BANDWIDTH:
          _context.statManager().addRateData("tunnel.receiveRejectionBandwidth",1,0);
        break;
case TunnelHistory.TUNNEL_REJECT_TRANSIENT_OVERLOAD:
      _context.statManager().addRateData("tunnel.receiveRejectionTransient",1,0);
    break;
case TunnelHistory.TUNNEL_REJECT_PROBABALISTIC_REJECT:
  _context.statManager().addRateData("tunnel.receiveRejectionProbabalistic",1,0);
break;
case TunnelHistory.TUNNEL_REJECT_CRIT:
default :
_context.statManager().addRateData("tunnel.receiveRejectionCritical",1,0);
}
_context.profileManager().tunnelRejected(peer,rtt,howBad);
_context.messageHistory().tunnelParticipantRejected(peer,"peer rejected after " + rtt + " with "+ howBad+ ": "+ cfg.toString());
}
}
if (allAgree) {
_exec.buildComplete(cfg,cfg.getTunnelPool());
if (cfg.isInbound()) _context.tunnelDispatcher().joinInbound(cfg);
 else _context.tunnelDispatcher().joinOutbound(cfg);
cfg.getTunnelPool().addTunnel(cfg);
_exec.buildSuccessful(cfg);
ExpireJob expireJob=new ExpireJob(_context,cfg,cfg.getTunnelPool());
cfg.setExpireJob(expireJob);
_context.jobQueue().addJob(expireJob);
if (cfg.getDestination() == null) _context.statManager().addRateData("tunnel.buildExploratorySuccess",rtt,rtt);
 else _context.statManager().addRateData("tunnel.buildClientSuccess",rtt,rtt);
}
 else {
_exec.buildComplete(cfg,cfg.getTunnelPool());
if (cfg.getDestination() == null) _context.statManager().addRateData("tunnel.buildExploratoryReject",rtt,rtt);
 else _context.statManager().addRateData("tunnel.buildClientReject",rtt,rtt);
}
}
 else {
if (_log.shouldLog(Log.WARN)) _log.warn(msg.getUniqueId() + ": Tunnel reply could not be decrypted for tunnel " + cfg);
}
}
