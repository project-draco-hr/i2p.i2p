{
  boolean connected=true;
  boolean rv=false;
  int remaining=0;
  int wanted=_settings.getQuantity() + _settings.getBackupQuantity();
  if ((_settings.getDestination() != null) && (!_context.clientManager().isLocal(_settings.getDestination())))   connected=false;
synchronized (_tokens) {
    if (!connected) {
      _tokens.remove(token);
      rv=false;
    }
 else {
      rv=_tokens.contains(token);
    }
    remaining=_tokens.size();
  }
  if (remaining <= 0) {
    _manager.removeTunnels(_settings.getDestination());
  }
  if (!rv) {
    if (_log.shouldLog(Log.INFO))     _log.info(toString() + ": keepBuilding does NOT want building to continue (want " + wanted+ ", have "+ remaining);
  }
 else {
    boolean needed=true;
    int valid=0;
synchronized (_tunnels) {
      if (_tunnels.size() > wanted) {
        for (int i=0; i < _tunnels.size(); i++) {
          TunnelInfo info=(TunnelInfo)_tunnels.get(i);
          if (info.getExpiration() > _context.clock().now() + 3 * _settings.getRebuildPeriod()) {
            valid++;
            if (valid >= wanted * 2)             break;
          }
        }
        if (valid >= wanted * 2)         needed=false;
      }
    }
    if (!needed) {
      if (_log.shouldLog(Log.WARN))       _log.warn(toString() + ": keepBuilding wants building to continue, but not " + " with the current object... # tunnels = "+ valid+ ", wanted = "+ wanted);
synchronized (_tokens) {
        _tokens.remove(token);
      }
      return false;
    }
  }
  return rv;
}
