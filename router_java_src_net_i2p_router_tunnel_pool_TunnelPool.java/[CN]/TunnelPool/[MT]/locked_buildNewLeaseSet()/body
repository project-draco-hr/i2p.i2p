{
  if (!_alive)   return null;
  long expireAfter=_context.clock().now();
  List leases=new ArrayList(_tunnels.size());
  for (int i=0; i < _tunnels.size(); i++) {
    TunnelInfo tunnel=(TunnelInfo)_tunnels.get(i);
    if (tunnel.getExpiration() <= expireAfter)     continue;
    TunnelId inId=tunnel.getReceiveTunnelId(0);
    Hash gw=tunnel.getPeer(0);
    if ((inId == null) || (gw == null)) {
      _log.error(toString() + ": wtf, tunnel has no inbound gateway/tunnelId? " + tunnel);
      continue;
    }
    Lease lease=new Lease();
    lease.setEndDate(new Date(tunnel.getExpiration()));
    lease.setTunnelId(inId);
    lease.setGateway(gw);
    leases.add(lease);
  }
  int wanted=_settings.getQuantity();
  if (leases.size() < wanted) {
    if (_log.shouldLog(Log.WARN))     _log.warn(toString() + ": Not enough leases (" + leases.size()+ ", wanted "+ wanted+ ")");
    return null;
  }
 else {
    while (leases.size() > wanted) {
      int earliestIndex=-1;
      long earliestExpiration=-1;
      for (int i=0; i < leases.size(); i++) {
        Lease cur=(Lease)leases.get(i);
        if ((earliestExpiration < 0) || (cur.getEndDate().getTime() < earliestExpiration)) {
          earliestIndex=i;
          earliestExpiration=cur.getEndDate().getTime();
        }
      }
      leases.remove(earliestIndex);
    }
  }
  LeaseSet ls=new LeaseSet();
  for (int i=0; i < leases.size(); i++)   ls.addLease((Lease)leases.get(i));
  if (_log.shouldLog(Log.INFO))   _log.info(toString() + ": built new leaseSet: " + ls);
  return ls;
}
