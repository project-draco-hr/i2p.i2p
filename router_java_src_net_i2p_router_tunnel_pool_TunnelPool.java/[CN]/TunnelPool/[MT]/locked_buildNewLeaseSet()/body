{
  if (!_alive)   return null;
  int wanted=Math.min(_settings.getQuantity(),LeaseSet.MAX_LEASES);
  if (_tunnels.size() < wanted) {
    if (_log.shouldLog(Log.WARN))     _log.warn(toString() + ": Not enough tunnels (" + _tunnels.size()+ ", wanted "+ wanted+ ")");
    if (_tunnels.size() <= 0)     return null;
  }
  long expireAfter=_context.clock().now();
  TreeSet leases=new TreeSet(new LeaseComparator());
  for (int i=0; i < _tunnels.size(); i++) {
    TunnelInfo tunnel=(TunnelInfo)_tunnels.get(i);
    if (tunnel.getExpiration() <= expireAfter)     continue;
    TunnelId inId=tunnel.getReceiveTunnelId(0);
    Hash gw=tunnel.getPeer(0);
    if ((inId == null) || (gw == null)) {
      _log.error(toString() + ": wtf, tunnel has no inbound gateway/tunnelId? " + tunnel);
      continue;
    }
    Lease lease=new Lease();
    lease.setEndDate(new Date(tunnel.getExpiration()));
    lease.setTunnelId(inId);
    lease.setGateway(gw);
    leases.add(lease);
  }
  if (leases.size() < wanted) {
    if (_log.shouldLog(Log.WARN))     _log.warn(toString() + ": Not enough leases (" + leases.size()+ ", wanted "+ wanted+ ")");
    if (leases.size() <= 0)     return null;
  }
  LeaseSet ls=new LeaseSet();
  Iterator iter=leases.iterator();
  int count=Math.min(leases.size(),wanted);
  for (int i=0; i < count; i++)   ls.addLease((Lease)iter.next());
  if (_log.shouldLog(Log.INFO))   _log.info(toString() + ": built new leaseSet: " + ls);
  return ls;
}
