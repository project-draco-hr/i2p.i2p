{
  if (!_alive)   return null;
  long expireAfter=_context.clock().now();
  LeaseSet ls=new LeaseSet();
  for (int i=0; i < _tunnels.size(); i++) {
    TunnelInfo tunnel=(TunnelInfo)_tunnels.get(i);
    if (tunnel.getExpiration() <= expireAfter)     continue;
    TunnelId inId=tunnel.getReceiveTunnelId(0);
    Hash gw=tunnel.getPeer(0);
    if ((inId == null) || (gw == null)) {
      _log.error(toString() + ": wtf, tunnel has no inbound gateway/tunnelId? " + tunnel);
      continue;
    }
    Lease lease=new Lease();
    lease.setEndDate(new Date(tunnel.getExpiration()));
    lease.setTunnelId(inId);
    lease.setGateway(gw);
    ls.addLease(lease);
  }
  int wanted=_settings.getQuantity();
  if (ls.getLeaseCount() < wanted) {
    if (_log.shouldLog(Log.WARN))     _log.warn(toString() + ": Not enough leases (" + ls.getLeaseCount()+ ", wanted "+ wanted+ ")");
    return null;
  }
 else {
    while (ls.getLeaseCount() > wanted) {
      int earliestIndex=-1;
      long earliestExpiration=-1;
      for (int i=0; i < ls.getLeaseCount(); i++) {
        Lease cur=ls.getLease(i);
        if ((earliestExpiration < 0) || (cur.getEndDate().getTime() < earliestExpiration)) {
          earliestIndex=i;
          earliestExpiration=cur.getEndDate().getTime();
        }
      }
      if (_log.shouldLog(Log.DEBUG))       _log.debug(toString() + ": Dropping older lease from the leaseSet: " + earliestIndex+ " out of "+ ls.getLeaseCount());
      ls.removeLease(earliestIndex);
    }
    return ls;
  }
}
