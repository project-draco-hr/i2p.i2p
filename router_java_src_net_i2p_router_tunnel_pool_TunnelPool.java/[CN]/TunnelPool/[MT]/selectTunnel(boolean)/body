{
  boolean avoidZeroHop=((getSettings().getLength() + getSettings().getLengthVariance()) > 0);
  long period=curPeriod();
synchronized (_tunnels) {
    if (_lastSelectionPeriod == period) {
      if ((_lastSelected != null) && (_lastSelected.getExpiration() > period) && (_tunnels.contains(_lastSelected)))       return _lastSelected;
    }
    _lastSelectionPeriod=period;
    _lastSelected=null;
    if (_tunnels.size() <= 0) {
      if (_log.shouldLog(Log.WARN))       _log.warn(toString() + ": No tunnels to select from");
    }
 else {
      Collections.shuffle(_tunnels,_context.random());
      if (avoidZeroHop) {
        for (int i=0; i < _tunnels.size(); i++) {
          TunnelInfo info=(TunnelInfo)_tunnels.get(i);
          if ((info.getLength() > 1) && (info.getExpiration() > _context.clock().now())) {
            _lastSelected=info;
            return info;
          }
        }
      }
      for (int i=0; i < _tunnels.size(); i++) {
        TunnelInfo info=(TunnelInfo)_tunnels.get(i);
        if (info.getExpiration() > _context.clock().now()) {
          _lastSelected=info;
          return info;
        }
      }
      if (_log.shouldLog(Log.WARN))       _log.warn(toString() + ": after " + _tunnels.size()+ " tries, no unexpired ones were found: "+ _tunnels);
    }
  }
  if (_alive && _settings.getAllowZeroHop())   buildFallback();
  if (allowRecurseOnFail)   return selectTunnel(false);
 else   return null;
}
