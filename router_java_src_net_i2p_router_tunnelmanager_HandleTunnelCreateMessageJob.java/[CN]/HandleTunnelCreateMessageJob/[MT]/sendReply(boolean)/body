{
  if (_log.shouldLog(Log.DEBUG))   _log.debug("Sending reply to a tunnel create of id " + _message.getTunnelId() + " with ok ("+ ok+ ") to tunnel "+ _message.getReplyTunnel()+ " on router "+ _message.getReplyPeer());
  getContext().messageHistory().receiveTunnelCreate(_message.getTunnelId(),_message.getNextRouter(),new Date(getContext().clock().now() + 1000 * _message.getTunnelDurationSeconds()),ok,_message.getReplyPeer());
  TunnelCreateStatusMessage msg=new TunnelCreateStatusMessage(getContext());
  msg.setFromHash(getContext().routerHash());
  msg.setTunnelId(_message.getTunnelId());
  if (ok) {
    msg.setStatus(TunnelCreateStatusMessage.STATUS_SUCCESS);
  }
 else {
    msg.setStatus(TunnelCreateStatusMessage.STATUS_FAILED_OVERLOADED);
  }
  msg.setMessageExpiration(new Date(getContext().clock().now() + TIMEOUT));
  GarlicMessage reply=createReply(msg);
  TunnelId outTunnelId=selectReplyTunnel();
  SendTunnelMessageJob job=new SendTunnelMessageJob(getContext(),reply,outTunnelId,_message.getReplyPeer(),_message.getReplyTunnel(),(Job)null,(ReplyJob)null,(Job)null,(MessageSelector)null,TIMEOUT,PRIORITY);
  getContext().jobQueue().addJob(job);
}
