{
  super(context);
  _log=context.logManager().getLog(RequestTunnelJob.class);
  context.statManager().createFrequencyStat("tunnel.buildFrequency","How often does the router build a tunnel?","Tunnels",new long[]{60 * 1000l,60 * 60 * 1000l,24 * 60 * 60* 1000l});
  context.statManager().createFrequencyStat("tunnel.buildFailFrequency","How often does a peer in the tunnel fail to join??","Tunnels",new long[]{60 * 1000l,60 * 60 * 1000l,24 * 60 * 60* 1000l});
  _pool=pool;
  _tunnelGateway=tunnelGateway;
  _timeoutMs=timeoutMs;
  _expiration=-1;
  _isInbound=isInbound;
  _failedTunnelParticipants=new HashSet();
  _complete=false;
  List participants=new ArrayList();
  TunnelInfo cur=_tunnelGateway;
  while (cur != null) {
    if (_log.shouldLog(Log.DEBUG))     _log.debug("Tunnel " + cur.getTunnelId() + " includes "+ cur.getThisHop().toBase64());
    participants.add(cur);
    cur=cur.getNextHopInfo();
  }
  if (isInbound) {
    if (_log.shouldLog(Log.INFO))     _log.info("Requesting inbound tunnel " + _tunnelGateway.getTunnelId() + " with "+ participants.size()+ " participants in it");
  }
 else {
    if (_log.shouldLog(Log.INFO))     _log.info("Requesting outbound tunnel " + _tunnelGateway.getTunnelId() + " with "+ participants.size()+ " participants in it");
  }
  _timeoutMs*=participants.size() + 1;
  _toBeRequested=new ArrayList(participants.size());
  for (int i=participants.size() - 1; i >= 0; i--) {
    TunnelInfo peer=(TunnelInfo)participants.get(i);
    if (null != _context.netDb().lookupRouterInfoLocally(peer.getThisHop())) {
      _toBeRequested.add(participants.get(i));
    }
 else {
      if (_log.shouldLog(Log.WARN))       _log.warn("ok who the fuck requested someone we don't know about? (dont answer that");
    }
  }
}
