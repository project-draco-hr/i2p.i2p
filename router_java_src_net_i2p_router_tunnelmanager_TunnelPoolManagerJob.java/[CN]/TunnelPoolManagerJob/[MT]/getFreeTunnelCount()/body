{
  Set freeTunnels=_pool.getFreeTunnels();
  int free=0;
  int minLength=_pool.getPoolSettings().getDepthInbound();
  long mustExpireAfter=_context.clock().now() + EXPIRE_FUDGE_PERIOD;
  for (Iterator iter=freeTunnels.iterator(); iter.hasNext(); ) {
    TunnelId id=(TunnelId)iter.next();
    TunnelInfo info=_pool.getFreeTunnel(id);
    if ((info != null) && (info.getIsReady())) {
      if (info.getSettings().getExpiration() > mustExpireAfter) {
        if (info.getLength() >= minLength) {
          if (info.getDestination() == null) {
            free++;
          }
 else {
            _log.error("Why is a free inbound tunnel allocated to a destination? [" + info.getTunnelId().getTunnelId() + " to "+ info.getDestination().toBase64()+ "]");
          }
        }
 else {
          free++;
        }
      }
 else {
        _log.info("Inbound tunnel " + id + " is expiring in the upcoming period, consider it not-free");
      }
    }
  }
  return free;
}
